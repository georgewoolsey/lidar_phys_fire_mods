[["index.html", "Aerial LiDAR for Fire Model Inputs Section 1 Introduction 1.1 Objective 1.2 Data", " Aerial LiDAR for Fire Model Inputs George Woolsey 28 February, 2025 Section 1 Introduction Code in support of “Using aerial LiDAR data for object-based physical fire modeling in conifer forests of the southwestern US” 1.1 Objective The objective of this study is to demonstrate the use of aerial LiDAR data to create inputs for physics-based fire models in frequent-fire forests of the southwestern United States. We review the methods used to extract tree location, species, and physical form from aerial LiDAR data. We evaluate this canopy crown detection methodology using a benchmark data set created to standardize evaluation metrics (Weinstein et al. 2021). We explain how to format this data for seamless integration with two commonly used object-based physical fire modeling tools. We demonstrate the end-to-end process using a case study from the southwestern United States. 1.2 Data Lidar data from the Mogollon Rim area of the Coconino National Forest about 20 km north of Payson, Arizona, USA was acquired from the USGS LidarExplorer. The aerial lidar data was collected between August 2013 and October 2014 under lidar project “AZ_USFS_3DEP_Processing_2019_D20” (project ID: 195122). "],["point-cloud-processing.html", "Section 2 Point Cloud Processing 2.1 Lidar Data Location 2.2 Individial Tree Detection Tuning: itd_tuning() 2.3 Point Cloud Tree Extraction: cloud2trees() 2.4 DBH Modeling: trees_dbh() 2.5 CBH Modeling: trees_cbh()", " Section 2 Point Cloud Processing In this section we’ll process the raw point cloud data using the cloud2trees R package developed to provide accessible routines for processing point cloud data collected by airborne lidar or generated using UAS imagery and photogrammetry (e.g. structure from motion). The cloud2trees package can be installed by following the directions listed in the README file on GitHub. If one is still experiencing difficulties installing the package, see the example.R file which details how to install the package using a virgin R instance. ## remotes helps us get packages hosted on github install.packages(&quot;remotes&quot;) ## get cloud2trees remotes::install_github(repo = &quot;georgewoolsey/cloud2trees&quot;, upgrade = F) Load the standard libraries we use to do work # bread-and-butter library(tidyverse) # the tidyverse library(viridis) # viridis colors library(harrypotter) # hp colors library(RColorBrewer) # brewer colors library(scales) # work with number and plot scales library(latex2exp) # visualization library(mapview) # interactive html maps library(kableExtra) # tables library(patchwork) # combine plots # spatial analysis library(terra) # raster library(sf) # simple features library(lidR) # lidar data library(cloud2trees) # the cloud2trees 2.1 Lidar Data Location Let’s check out the lidar data we got from the Mogollon Rim area of the Coconino National Forest about 20 km north of Payson, Arizona, USA using the USGS LidarExplorer. # directory with the downloaded .las|.laz files f &lt;- &quot;e:/lidar_phys_fire_mods/data/mogollon_rim_az_lidar/&quot; # is there data? list.files(f, pattern = &quot;.*\\\\.(laz|las)$&quot;) %&gt;% length() ## [1] 42 # what files are in here? list.files(f, pattern = &quot;.*\\\\.(laz|las)$&quot;)[1:3] ## [1] &quot;USGS_LPC_AZ_USFS_3DEP_Processing_2019_D20_w0467n3808.laz&quot; ## [2] &quot;USGS_LPC_AZ_USFS_3DEP_Processing_2019_D20_w0467n3809.laz&quot; ## [3] &quot;USGS_LPC_AZ_USFS_3DEP_Processing_2019_D20_w0467n3810.laz&quot; We’ll plot our point cloud data tiles real quick to orient ourselves lidR::readLAScatalog(f) %&gt;% purrr::pluck(&quot;data&quot;) %&gt;% mapview::mapview(popup = F, layer.name = &quot;point cloud tile&quot;) 2.2 Individial Tree Detection Tuning: itd_tuning() The cloud2trees package performs individual tree detection using lidR::locate_trees() with the lidR::lmf() algorithm. The local maximum filter algorithm allows for a constant window size or a variable window size defined by a function. See the lidR package book section by point cloud processing expert Jean-Romain Roussel for excellent detail on ITD and defining window size. The itd_tuning() function is used to visually assess tree crown delineation results from different window size functions used for the detection of individual trees. itd_tuning() allows users to test different window size functions on a sample of data to determine which function is most suitable for the area being analyzed. The preferred function can then be used in the ws parameter in raster2trees() and cloud2trees(). Let’s run itd_tuning() on our data starting with default window size functions # run itd_tuning() itd_tuning_ans &lt;- cloud2trees::itd_tuning(f) # what did we get? itd_tuning_ans %&gt;% names() ## [1] &quot;plot_samples&quot; &quot;ws_fn_list&quot; check the ws_fn_list return which includes the different window size functions tested # what ws_fn_list itd_tuning_ans$ws_fn_list %&gt;% str() ## List of 3 ## $ lin_fn:function (x) ## $ exp_fn:function (x) ## $ log_fn:function (x) let’s look at the function definition for the linear function (lin_fn) # the linear function itd_tuning_ans$ws_fn_list$lin_fn ## function (x) ## { ## y &lt;- dplyr::case_when(is.na(x) ~ 0.001, x &lt; 0 ~ 0.001, x &lt; ## 2 ~ 1, x &gt; 30 ~ 5, TRUE ~ 0.75 + (x * 0.14)) ## return(y) ## } ## &lt;bytecode: 0x00000242e3f81338&gt; ## &lt;environment: 0x00000242e3f881c0&gt; let’s plot all of the functions we tested with our call to itd_tuning() using the defaults # shape of the ws functions ggplot() + geom_function(aes(color = &quot;lin_fn&quot;),fun=itd_tuning_ans$ws_fn_list$lin_fn, lwd=1.2) + geom_function(aes(color = &quot;nonlin_fn&quot;),fun=itd_tuning_ans$ws_fn_list$nonlin_fn, lwd=1.2) + geom_function(aes(color = &quot;exp_fn&quot;),fun=itd_tuning_ans$ws_fn_list$exp_fn, lwd=1.2) + xlim(-5,60) + harrypotter::scale_color_hp_d(option = &quot;hermionegranger&quot;) + labs(x = &quot;heights&quot;, y = &quot;ws&quot;, color = &quot;ws function&quot;) + theme_light() now, let’s see how those window size functions impacted individual tree detection by checking the plot_samples return # tuning plot itd_tuning_ans$plot_samples Looking at the first sample, the exponential function (exp_fn) resulted in too few trees detected in the overstory class. The clearest evidence of this is in the center of the left-hand side of the plot in the first sample. There is a clear “valley” in the CHM which the linear (lin_fn) and non-linear (nonlin_fn) correctly split into two trees but the exponential function misses this split. Furthermore, the exponential function results in too many tree splits for short trees as can be seen in the second sample plot in the lower-left corner small tree group. The linear and the non-linear function are very similar in detecting overstory trees but the linear function perhaps does a better job splitting up clumps of smaller trees. In the third sample plot the linear function does a better job splitting up the short tree group in the upper-right corner small tree group compared to the non-linear function (there is no way that a tree that short [3-6 m tall] would have such a large crown area as in the non-linear split). If we had one gripe about the linear function, it’s maybe that it results in too many trees in small-tree patches. Let’s define our own custom linear function that slightly increases the window size for shorter trees compared to the default linear function. # custom linear function custom_lin &lt;- function (x){ y &lt;- dplyr::case_when( is.na(x) ~ 0.001 , x &lt; 0 ~ 0.001 , x &lt; 2 ~ 1.2 , x &gt; 30 ~ 5 , TRUE ~ 0.9 + (x * 0.139) ) return(y) } # shape of the ws functions ggplot() + geom_function(aes(color = &quot;lin_fn&quot;),fun=itd_tuning_ans$ws_fn_list$lin_fn, lwd=1.2) + geom_function(aes(color = &quot;nonlin_fn&quot;),fun=itd_tuning_ans$ws_fn_list$nonlin_fn, lwd=1.2) + geom_function(aes(color = &quot;custom_lin&quot;),fun=custom_lin, lwd=1.2) + xlim(-5,60) + harrypotter::scale_color_hp_d(option = &quot;hermionegranger&quot;) + labs(x = &quot;heights&quot;, y = &quot;ws&quot;, color = &quot;ws function&quot;) + theme_light() We’ll run another sample test using itd_tuning()with our new function (call it “my_custom_lin” for extra clarity) compared to the default linear and non-linear functions and this time we’ll ask for four sample plots of 0.1 ha. itd_tuning_ans2 &lt;- cloud2trees::itd_tuning( f , ws_fn_list = list( my_custom_lin = custom_lin , lin_fn = itd_tuning_ans$ws_fn_list$lin_fn , nonlin_fn = itd_tuning_ans$ws_fn_list$nonlin_fn ) , n_samples = 4 ) now, let’s see how those window size functions impacted individual tree detection by checking the plot_samples return # tuning plot itd_tuning_ans2$plot_samples Our custom linear function (my_custom_lin) strikes a good balance between detection of lower canopy trees (e.g. &lt;10 m in height) without improperly subdividing dominant canopy trees based on the areas sampled. Let’s move forward with our custom linear function in the raster2trees() and cloud2trees() functions. 2.3 Point Cloud Tree Extraction: cloud2trees() The cloud2trees() function combines methods in the cloud2trees package for an all-in-one approach. We’ll call this function without estimating any of the additional tree components (the estimate_* parameters) which we will do separately to show the full process. With all other options turned off, cloud2trees() will: 1) generate a CHM from the point cloud using cloud2raster(); and 2) perform individual tree detection using raster2trees(). cloud2trees_ans &lt;- cloud2trees::cloud2trees( output_dir = &quot;../data&quot; , input_las_dir = f # we defined this above , accuracy_level = 2 , dtm_res_m = 1 , chm_res_m = 0.25 , min_height = 2 , ws = custom_lin # here it is , keep_intrmdt = T # these are turned off by default but we&#39;ll be explicit , estimate_tree_dbh = F , estimate_tree_competition = F , estimate_tree_type = F , estimate_tree_hmd = F , estimate_tree_cbh = F ) we should have a spatial tree list with tree height attached cloud2trees_ans$crowns_sf %&gt;% dplyr::select(treeID, tree_x, tree_y, tree_height_m, crown_area_m2) %&gt;% dplyr::glimpse() ## Rows: 2,629,495 ## Columns: 6 ## $ treeID &lt;chr&gt; &quot;1877144&quot;, &quot;1876803&quot;, &quot;1876566&quot;, &quot;1875427&quot;, &quot;1872834&quot;, &quot;… ## $ tree_x &lt;dbl&gt; 467000.1, 467000.1, 467000.1, 467000.1, 467000.1, 467000… ## $ tree_y &lt;dbl&gt; 3808063, 3808065, 3808067, 3808074, 3808091, 3808124, 38… ## $ tree_height_m &lt;dbl&gt; 2.15, 2.34, 2.02, 2.11, 3.66, 4.37, 2.03, 5.60, 17.72, 2… ## $ crown_area_m2 &lt;dbl&gt; 0.3750, 0.7500, 0.2500, 0.3750, 1.2500, 0.9375, 0.3750, … ## $ geom &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((467000 3808..., MULTIPOLYGO… That’s a lot of trees! The cloud2trees() function dropped off a lot of additional data in a folder titled “point_cloud_processing_delivery” which is nested where we told the command to write the data (output_dir = \"../data\" parameter setting). Let’s load in the “processed_tracking_data.csv” file to see how long that cloud2trees() process took to run. Run times are, of course, dependent on computer processing and I am working on a laptop typical of a spatial analyst (especially outside of the US Federal Government) running Windows with an Intel i7-10750H 6-core computer processor unit and 32 gigabytes of random-access memory. # load processed_tracking_data.csv processing_data &lt;- readr::read_csv( file = &quot;../data/point_cloud_processing_delivery/processed_tracking_data.csv&quot; , progress = F , show_col_types = F ) # what? processing_data %&gt;% dplyr::select(1:4) %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 4 ## $ number_of_points &lt;dbl&gt; 571949084 ## $ las_area_m2 &lt;dbl&gt; 41999160 ## $ timer_cloud2raster_mins &lt;dbl&gt; 135.4638 ## $ timer_raster2trees_mins &lt;dbl&gt; 93.28212 let’s do some math # total tree extraction time trees_mins_temp &lt;- processing_data$timer_cloud2raster_mins[1] + processing_data$timer_raster2trees_mins[1] # ha ha_temp &lt;- round(processing_data$las_area_m2[1]/10000) # secs per ha rate_temp &lt;- (trees_mins_temp*60) / ha_temp # point density dens_temp &lt;- processing_data$number_of_points[1] / processing_data$las_area_m2[1] Tree extraction over 4,200 hectares took a total of 228.7 minutes at processing rate of 3.27 seconds per hectare on lidar data with a point density of 13.6 points per square meter. 2.4 DBH Modeling: trees_dbh() The trees_dbh() function uses the TreeMap FIA plot data in the area of the tree list to estimate the height-DBH allometry relationship. The height predicting DBH model built from the FIA data is then used to predict DBH based on tree height in the tree list. trees_dbh_ans &lt;- cloud2trees::trees_dbh() 2.5 CBH Modeling: trees_cbh() The trees_cbh() function does work # where should we save the file? cbh_fn &lt;- &quot;../data/point_cloud_processing_delivery/cbh_data.csv&quot; # if we don&#39;t already have the data, run it if(!file.exists(cbh_fn)){ # sample size nsamp_temp &lt;- 99999 # time it st_temp &lt;- Sys.time() # run it trees_cbh_ans &lt;- cloud2trees::trees_cbh( trees_poly = cloud2trees_ans$crowns_sf , norm_las = &quot;../data/point_cloud_processing_delivery/norm_las/&quot; , tree_sample_n = nsamp_temp # , tree_sample_prop = 0.08 , which_cbh = &quot;lowest&quot; , estimate_missing_cbh = TRUE , min_vhp_n = 3 , voxel_grain_size_m = 1 , dist_btwn_bins_m = 1 , min_fuel_layer_ht_m = 1 , lad_pct_gap = 25 , lad_pct_base = 25 , num_jump_steps = 1 , min_lad_pct = 10 , frst_layer_min_ht_m = 1 , force_same_crs = T ) # timer ## author note: test 1 with 20k sample took 58.56778 mins mins_temp &lt;- difftime(Sys.time(),st_temp,units = &quot;mins&quot;) %&gt;% as.numeric() processing_data$timer_trees_cbh_mins &lt;- mins_temp processing_data$sttng_cbh_tree_sample_n &lt;- nsamp_temp processing_data$sttng_cbh_tree_sample_prop &lt;- NA # save cbh trees_cbh_ans %&gt;% sf::st_drop_geometry() %&gt;% write.csv(file = cbh_fn, row.names = F, append = F) # save tracking processing_data %&gt;% write.csv( file = &quot;../data/point_cloud_processing_delivery/processed_tracking_data.csv&quot; , row.names = F, append = F ) }else{ # cbh data trees_cbh_ans &lt;- readr::read_csv(cbh_fn, progress = F, show_col_types = F) # re-cast treeID if needed if( !inherits( trees_cbh_ans$treeID , class(cloud2trees_ans$crowns_sf$treeID) ) ){ if(inherits(cloud2trees_ans$crowns_sf$treeID, &quot;character&quot;)){ trees_cbh_ans$treeID &lt;- as.character(trees_cbh_ans$treeID) }else if(inherits(cloud2trees_ans$crowns_sf$treeID, &quot;numeric&quot;)){ trees_cbh_ans$treeID &lt;- as.numeric(trees_cbh_ans$treeID) } } } CBH extraction for 50,000 trees took a total of 159.4 minutes at processing rate of 3.19 minutes per 1,000 trees…this is not fast and mostly a limitation of the LadderFuelsR which only allows for processing one tree at a time. Perhaps the author of cloud2trees will enable parallel processing at some point in the future??? Let’s see what we got back from trees_cbh() trees_cbh_ans %&gt;% dplyr::select(treeID, tree_cbh_m, is_training_cbh) %&gt;% dplyr::glimpse() ## Rows: 2,629,495 ## Columns: 3 ## $ treeID &lt;chr&gt; &quot;1877144&quot;, &quot;1876803&quot;, &quot;1876566&quot;, &quot;1875427&quot;, &quot;1872834&quot;,… ## $ tree_cbh_m &lt;dbl&gt; 2.001330, 2.178191, 1.880319, 1.964096, 3.193244, 3.20… ## $ is_training_cbh &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE… We requested CBH extraction for 50,000 trees. For how many trees was CBH successfully extracted from the point cloud? trees_cbh_ans %&gt;% dplyr::count(is_training_cbh) ## # A tibble: 2 × 2 ## is_training_cbh n ## &lt;lgl&gt; &lt;int&gt; ## 1 FALSE 2615015 ## 2 TRUE 14480 That’s not a great success ;( … Someone should do something (or should they?) "],["validate-tree-detection-and-crown-delineation.html", "Section 3 Validate Tree Detection and Crown Delineation 3.1 NeonTreeEvaluation overview 3.2 lidar data in NeonTreeEvaluation 3.3 Example validation process 3.4 Full validation process", " Section 3 Validate Tree Detection and Crown Delineation In this section we’ll use the benchmark data made available in the NeonTreeEvaluation data set (Weinstein et al. 2021) to evaluate our process for lidar-based tree detection. We’ll implement our tree detection process via the [cloud2trees]https://github.com/georgewoolsey/cloud2trees) package First, load the standard libraries # bread-and-butter library(tidyverse) # the tidyverse library(viridis) # viridis colors library(harrypotter) # hp colors library(RColorBrewer) # brewer colors library(scales) # work with number and plot scales library(latex2exp) # visualization library(mapview) # interactive html maps library(kableExtra) # tables library(patchwork) # combine plots library(ggnewscale) # ggnewscale library(rgl) # rgl plotting # spatial analysis library(sf) # simple features library(lidR) # lidar data library(cloud2trees) # tha cloud2trees library(NeonTreeEvaluation) # benchmark data 3.1 NeonTreeEvaluation overview Weinstein et al. (2021) developed: a benchmark dataset of individual canopy crowns derived from multi-sensor imagery in the National Ecological Observatory Network (Table 1) that provides: 1) co-registered remote sensing data from multiple sensors (LiDAR, RGB imagery, and hyperspectral imagery) to allow comparisons of methods based on any single sensor (e.g., for LiDAR based methods), or any combination of sensors (e.g., combining RGB and hyperspectral), and 2) three types of evaluation data to allow assessing both ‘tree detection’, defined as the identifying the location of individual trees using evaluation data with a point at the crown center , and ‘crown delineation’ defined as identifying the boundary edge of crowns across a broad range of forest types. The benchmark is designed to allow flexibility in both workflow and sensor selection. (p. 2) Table 1. Summary of datasets included in the benchmark dataset. All sensor data has been cropped to the extent of NEON field sampling plots. Note the three data labeled as “Evaluation data” in the table. If you are asking “why three evaluation datasets?”, the authors provide some detail: The inclusion of multiple evaluation types is critical because each type of evaluation data has strengths and limitations in evaluating model performance. Field collected stems are the most common evaluation data used in crown detection work due to high confidence that each stem represents a location of a single tree. However, the position of a tree stem can fail to accurately represent the position of the crown as viewed from above due to a combination of spatial errors in alignment with the image data and the tendency for trees to grow at acute angles (tree lean is not measured in the NEON data), such that the center of the crown and position of the stem can be offset by several meters….Image-annotated crowns are relatively easy to scale, allowing the collection of data for a wide range of forest types and for annotation of every visible crown in the image. Using image-annotated crowns supports the evaluation of methods across a broad range of forest types and allows both recall and precision to be calculated. However, since these annotations are not generated by an observer in the field there can be errors due to interpreting the images. This problem is solved using field-annotated crowns in which an observer annotates the remote-sensing imagery on a tablet while in the field [33]. The main limitation to this approach is that it is labor intensive, meaning that only a relatively small amount of validation data can be collected, making it difficult to obtain a large number of crowns across broad scales or assess model precision. Given the tradeoffs in each evaluation type, providing multiple criteria is a useful way of balancing the need for broad scale model verification with rigorous evaluation of field-based measurements. (p. 14-15) To evaluate the performance of our aerial point cloud-based algorithm for 1) tree detection and 2) crown delineation using NeonTreeEvaluation we need to ensure our tree polygon data is formatted properly: This package takes a standard submission format of predicted crowns in either bounding box or polygons as input and returns the evaluation scores of the detections for each of the three evaluation datasets. This reproducible workflow will facilitate creating a transparent process for future comparisons among crown detection algorithms. (p. 14) The authors describe the “standard submission format” on the package GitHub: Each row contains information for one predicted bounding box. The plot_name should be named the same as the files in the dataset without extension (e.g. SJER_021_2018 not SJER_021_2018.tif) and not the full path to the file on disk. Not all evaluation data are available for all plots. Functions like evaluate_field_crowns and evaluate_image_crowns will look for matching plot name and ignore other plots. Depending on the speed of the algorithm, the simplest thing to do is predict all images in the RGB folder (see list_rgb()) and the package will handle matching images with the correct data to the correct evaluation procedure…Instead of bounding boxes, some methods may return polygons. To submit as polygons, create a single unprojected shapefile with polygons in image coordinates. Polygons must be complete with no holes. Here is an example of the above csv file in polygon format. Here the xmin, xmax, etc. columns are ignored since the information is stored in the geometry data. Simple feature collection with 6 features and 7 fields geometry type: POLYGON dimension: XY bbox: xmin: 30.39723 ymin: 122.1164 xmax: 397.5746 ymax: 400 CRS: NA xmin ymin xmax ymax score label plot_name 1 41.01716 230.8854 151.08607 342.6985 0.8098674 Tree DSNY_014_2019 2 357.32129 122.1164 397.57458 159.3758 0.6968824 Tree DSNY_014_2019 3 30.39723 136.9157 73.79434 184.9473 0.5713338 Tree DSNY_014_2019 4 260.65921 285.6689 299.68811 326.7933 0.5511004 Tree DSNY_014_2019 5 179.34564 371.6130 232.49385 400.0000 0.4697072 Tree DSNY_014_2019 6 316.27377 378.9802 363.67542 400.0000 0.3259409 Tree DSNY_014_2019 st_sfc.lst. 1 POLYGON ((41.01716 230.8854... 2 POLYGON ((357.3213 122.1164... 3 POLYGON ((30.39723 136.9157... 4 POLYGON ((260.6592 285.6689... 5 POLYGON ((179.3456 371.613,... 6 POLYGON ((316.2738 378.9802... So we are going to: run cloud2trees::cloud2trees() on all lidar data, combine into a single tree list with a row unique by a detected tree and the plot_name column (e.g. “SJER_021_2018”), as an unprojected sf data with polygons in image coordinates. We may need to run cloud2trees::simplify_multipolygon_crowns() prior to submission. 3.2 lidar data in NeonTreeEvaluation we first have to download evaluation data from the Zenodo archive (1GB), use the download() function to place the data in the correct package location. Download the much larger training data, set training=TRUE. NeonTreeEvaluation::download(training = T, force = F) let’s find what data is available # i did some digging around and the lidar data is here lidar_dir_temp &lt;- system.file(package = &quot;NeonTreeEvaluation&quot;, &quot;extdata&quot;, &quot;NeonTreeEvaluation&quot;, &quot;evaluation&quot;, &quot;LiDAR&quot;) # files lidar_files_temp &lt;- lidar_dir_temp %&gt;% list.files(recursive = T, pattern = &quot;.*\\\\.(laz|las)$&quot;, full.names = T) %&gt;% unique() # look at this lidar_files_temp %&gt;% basename() %&gt;% sample(size = 9) ## [1] &quot;TEAK_051_2019.laz&quot; ## [2] &quot;BART_039_2019.laz&quot; ## [3] &quot;WREF_073_2019.laz&quot; ## [4] &quot;2018_SJER_3_253000_4109000_image_573.laz&quot; ## [5] &quot;TALL_021_2019.laz&quot; ## [6] &quot;CLBJ_050_2019.laz&quot; ## [7] &quot;SOAP_010_2018.laz&quot; ## [8] &quot;OSBS_120.las&quot; ## [9] &quot;DEJU_023_2019.laz&quot; # let&#39;s pull out all sites with `.laz` data and create a data frame for tracking purposes lidar_df &lt;- lidar_files_temp %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename(f_path = 1) %&gt;% # create some other variables dplyr::mutate( plot_name = f_path %&gt;% basename() %&gt;% stringr::str_remove_all(&quot;\\\\.(laz|las)$&quot;) ) # what? lidar_df %&gt;% dplyr::glimpse() ## Rows: 2,186 ## Columns: 2 ## $ f_path &lt;chr&gt; &quot;C:/Program Files/R/R-4.3.0/library/NeonTreeEvaluation/extda… ## $ plot_name &lt;chr&gt; &quot;2018_SJER_3_252000_4104000_image_628&quot;, &quot;2018_SJER_3_252000_… that’s a lot of files…let’s only process the sites with evaluation data # there are functions to get a list of all evaluation data # let&#39;s use these to filter our lidar files plotnames_temp &lt;- c( NeonTreeEvaluation::list_annotations() , NeonTreeEvaluation::list_field_stems() # this one includes file paths, so we have to clean , NeonTreeEvaluation::list_field_crowns() %&gt;% stringr::str_match(pattern=&quot;(\\\\w+).tif&quot;) %&gt;% .[,2] # there are plot_names from the submission data too , NeonTreeEvaluation::submission_polygons$plot_name %&gt;% unique() , NeonTreeEvaluation::submission$plot_name %&gt;% unique() ) %&gt;% unique() # huh? plotnames_temp %&gt;% sample(11) ## [1] &quot;2018_TEAK_3_319000_4102000_image_281&quot; ## [2] &quot;UNDE_055_2017&quot; ## [3] &quot;HARV_001_2019&quot; ## [4] &quot;RMNP_049&quot; ## [5] &quot;UNDE_030_2020&quot; ## [6] &quot;RMNP_009&quot; ## [7] &quot;MLBS_20_competition&quot; ## [8] &quot;NIWO_018_2018&quot; ## [9] &quot;unnamed_plot_52_competition&quot; ## [10] &quot;SOAP_002_2019&quot; ## [11] &quot;2018_SJER_3_255000_4108000_image_256&quot; filter our lidar data list lidar_df &lt;- lidar_df %&gt;% #filter based on plots in evaluation data dplyr::filter(plot_name %in% plotnames_temp) %&gt;% # pull out site dplyr::mutate( siteID = stringr::str_extract(plot_name, &quot;[A-Z]+&quot;) ) # what? lidar_df %&gt;% dplyr::glimpse() ## Rows: 1,732 ## Columns: 3 ## $ f_path &lt;chr&gt; &quot;C:/Program Files/R/R-4.3.0/library/NeonTreeEvaluation/extda… ## $ plot_name &lt;chr&gt; &quot;2018_SJER_3_252000_4104000_image_628&quot;, &quot;2018_SJER_3_252000_… ## $ siteID &lt;chr&gt; &quot;SJER&quot;, &quot;SJER&quot;, &quot;SJER&quot;, &quot;SJER&quot;, &quot;SJER&quot;, &quot;SJER&quot;, &quot;SJER&quot;, &quot;SJE… we will want to limit our evaluation to only sites with conifer trees since cloud2trees implements methods developed specifically to quantify conifer forest structure that may not be appropriate for other uses. we’ll use the field data in the package to look for NEON sites with conifer trees. We’ll use the NEON plant list to identify conifer species: https://data.neonscience.org/taxonomic-lists?taxonTypeCode=PLANT (click “DOWNLOAD TAXONOMIC LIST”). We’ll filter for species belonging to Class Pinopsida. conifer_spp &lt;- readr::read_csv( &quot;../data/OS_TAXON_PLANT-20220330T142149.csv&quot; , show_col_types = F , progress = F ) %&gt;% dplyr::filter( tolower(`class`) %in% c(&quot;pinopsida&quot;) ) %&gt;% dplyr::mutate( taxonID = toupper(taxonID) , vernacularName = tolower(vernacularName) , genus = stringr::str_to_title(genus) ) %&gt;% dplyr::distinct(taxonID, vernacularName, genus) what are some of these conifers? # huh? conifer_spp %&gt;% dplyr::slice_sample(n = 10) %&gt;% kableExtra::kbl(caption = &quot;Conifer species taxonID examples&quot;) %&gt;% kableExtra::kable_styling() Table 3.1: Conifer species taxonID examples taxonID vernacularName genus JUNIPSPP juniper Juniperus JUMOM oneseed juniper Juniperus LALA tamarack Larix PISO NA Pinus AGATH2SPP agathis Agathis PITO torrey pine Pinus ABFR fraser fir Abies ABCO white fir Abies PITA loblolly pine Pinus ARAUC2 araucaria Araucaria filter for NEON sites that have conifer trees based on field data from all terrestrial NEON sites with qualifying woody vegetation: https://data.neonscience.org/data-products/DP1.10098.001 conifer_sites &lt;- NeonTreeEvaluation::field %&gt;% dplyr::left_join( conifer_spp %&gt;% dplyr::mutate(is_conifer = 1) , by = &quot;taxonID&quot; ) %&gt;% dplyr::mutate(is_conifer = dplyr::coalesce(is_conifer, 0)) %&gt;% dplyr::group_by(siteID) %&gt;% dplyr::summarise( tot = dplyr::n() , conifer = sum(is_conifer) , latitude = mean(plotLatitude) , longitude = mean(plotLongitude) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate(pct_conifer = conifer/tot) what is the breakdown of woody vegetation sampled in NEON sites by the percent conifer? conifer_sites %&gt;% dplyr::select(-c(longitude,latitude)) %&gt;% dplyr::arrange(desc(pct_conifer), desc(tot)) %&gt;% dplyr::slice_head(n = 19) %&gt;% kableExtra::kbl(caption = &quot;Conifers in NEON sites&quot;, digits = 2) %&gt;% kableExtra::kable_styling() Table 3.2: Conifers in NEON sites siteID tot conifer pct_conifer NIWO 1804 1804 1.00 ONAQ 88 88 1.00 MOAB 29 29 1.00 HEAL 21 21 1.00 YELL 13 13 1.00 TEAK 621 619 1.00 DEJU 173 169 0.98 ABBY 268 241 0.90 RMNP 1375 1083 0.79 SOAP 503 389 0.77 DSNY 34 26 0.76 TALL 2144 1521 0.71 OSBS 1288 858 0.67 JERC 562 336 0.60 HARV 3736 1701 0.46 TREE 1303 430 0.33 BART 3636 1022 0.28 BONA 188 48 0.26 STEI 754 151 0.20 let’s only keep NEON sites with &gt;50% of the woody vegetation sampled as conifer # minimum pct conifer min_conifer_pct &lt;- .5 # data frame of sites conifer_sites &lt;- conifer_sites %&gt;% dplyr::filter(pct_conifer&gt;min_conifer_pct) finally, we’ll filter our lidar processing data for only these conifer sites lidar_df &lt;- lidar_df %&gt;% dplyr::inner_join(conifer_sites, by = &quot;siteID&quot;) %&gt;% sf::st_as_sf(coords = c(&quot;longitude&quot;,&quot;latitude&quot;), crs = 4326, remove = F) %&gt;% # filter out corrupt las files dplyr::filter( !plot_name %in% c( &quot;NIWO_005_2018&quot; , &quot;SOAP_014_2018&quot; , &quot;MOAB_003_2018&quot; , &quot;NIWO_009_2018&quot; , &quot;TEAK_028_2018&quot; , &quot;YELL_058_2020&quot; , &quot;RMNP_011_2018&quot; , &quot;YELL_030_2018&quot; , &quot;YELL_051_2019&quot; , &quot;SOAP_014_2019&quot; , &quot;TEAK_005_2018&quot; ) ) what NEON sites have conifers and the most lidar plots lidar_df %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(siteID) %&gt;% dplyr::arrange(desc(n)) %&gt;% dplyr::slice_head(n=11) %&gt;% kableExtra::kbl(caption = &quot;NEON sites with conifers and lidar plots&quot;) %&gt;% kableExtra::kable_styling() Table 3.3: NEON sites with conifers and lidar plots siteID n TEAK 120 DEJU 87 YELL 83 OSBS 71 SOAP 71 NIWO 63 ABBY 55 TALL 54 JERC 50 DSNY 46 HEAL 29 what is the spatial distribution of these sites? lidar_df %&gt;% dplyr::count(siteID) %&gt;% mapview::mapview( zcol = &quot;siteID&quot;, legend = F , layer.name = &quot;NEON site&quot; , col.regions = viridis::turbo(n=nrow(conifer_sites)) ) that’s pretty good geographic coverage and in places that we expect to have conifers ;D 3.3 Example validation process now that we have our lidar data that we can test our point cloud-based tree detection and crown segmentation process against, let’s walk through the validation for a single plot we’ll test with a single point cloud in our filtered list from conifer sites with validation data lidar_df_row &lt;- 1 # lidar_df$f_path[47] %&gt;% lidR::readLAS() %&gt;% lidR::st_crs() 3.3.1 Preliminaries 3.3.1.1 View the point cloud this step isn’t necessary for validation, but let’s see what this point cloud data looks like We can plot the point cloud with and color by the point height lidar_df$f_path[lidar_df_row] %&gt;% lidR::readLAS() %&gt;% lidR::plot( color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;, legend = T , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) there are trees in there for sure (and conifer trees by the looks of it) let’s look at the co-registered RGB imagery (notice that the NeonTreeEvaluation commands rely on the deprecated raster package :) # read rgb rgb_temp &lt;- lidar_df$plot_name[lidar_df_row] %&gt;% NeonTreeEvaluation::get_data(type = &quot;rgb&quot;) %&gt;% raster::stack() # read image annotated crown data and make polygons polys_temp &lt;- lidar_df$plot_name[lidar_df_row] %&gt;% NeonTreeEvaluation::get_data(type = &quot;annotations&quot;) %&gt;% NeonTreeEvaluation::xml_parse() polys_temp &lt;- NeonTreeEvaluation::boxes_to_spatial_polygons(polys_temp,rgb_temp) # plot terra::plotRGB(rgb_temp %&gt;% terra::rast()) terra::plot( polys_temp %&gt;% terra::vect() , col = NA, border = &quot;red&quot; , lwd = 2 , add = TRUE ) 3.3.1.2 ITD variable window We discussed our method for individual tree detection (ITD) in this prior section. For our validation, we’ll be using the default window size in the cloud2trees::cloud2trees() and cloud2trees::raster2trees() settings. Let’s see what that looks like ws_temp &lt;- cloud2trees::itd_ws_functions()[[&quot;log_fn&quot;]] ggplot() + geom_function(fun=ws_temp, lwd=1.2, color = &quot;navy&quot;) + xlim(-5,60) + labs( x = &quot;heights&quot;, y = &quot;ws&quot; , subtitle = &quot;`cloud2trees` default ITD variable window function&quot; ) + theme_light() 3.3.2 Filter for “canopy” trees First, we’ll process the point cloud and get a tree list using our cloud2trees::cloud2trees() method with all defaults except we’ll raise the minimum height of trees to search to 3 m. The (Weinstein et al. 2021) benchmark was developed specifically for “canopy” trees and the field-collected stems evaluation data only includes &gt;10 cm DBH trees: NEON field crews sample all trees within a plot that are greater than 10cm DBH, regardless of whether the tree crown can be seen in the remote sensing image data. While understory tree detection is an important area of future work, the scope of this benchmark is focused on crowns in the canopy that are visible from above. (p. 10) In order to set up our point cloud-based algorithm to find “canopy” trees, we’ll identify the shortest live tree in the field-collected stems data to set our min_height in cloud2trees::cloud2trees() we’ll use the filters found in clean_field_data() from NeonTreeEvaluation as an internal function percentile_for_ht &lt;- 0.05 # get non-na heights from neon field measured trees neon_field_heights &lt;- NeonTreeEvaluation::field %&gt;% # filters found in `clean_field_data()` dplyr::filter( !is.na(itcEasting) , !stringr::str_detect(eventID,&quot;2014&quot;) , growthForm %in% c(&quot;single bole tree&quot;,&quot;multi-bole tree&quot;,&quot;small tree&quot;,&quot;sapling&quot;) , stemDiameter&gt;15 , (height&gt;3|is.na(height)) ) %&gt;% # getting only non-na dplyr::filter(!is.na(height)) # get 5th tile ht by site neon_site_heights &lt;- neon_field_heights %&gt;% dplyr::group_by(siteID) %&gt;% dplyr::summarise( site_prcntl_ht = quantile(floor(height), probs = percentile_for_ht, na.rm = T) ) %&gt;% dplyr::ungroup() look at the summary of height data across all sites and plots summary(neon_field_heights$height) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 3.10 11.60 15.90 16.48 20.30 119.80 what does this look like for each NEON site? neon_field_heights %&gt;% dplyr::inner_join(neon_site_heights) %&gt;% ggplot(aes(x = height, group = siteID)) + geom_density(color = &quot;gold&quot;,fill = &quot;gold&quot;, alpha = 0.7, lwd = 1.2) + geom_vline(aes(xintercept = site_prcntl_ht), linetype = &quot;dashed&quot;) + facet_wrap(facets = vars(siteID), ncol = 7, scales = &quot;free&quot;) + scale_x_continuous(breaks = scales::breaks_extended(6)) + labs( x = &quot;height (m)&quot;, y = &quot;&quot; , subtitle = paste0( &quot;heights of \\&quot;canopy\\&quot; trees in NeonTreeEvaluation with &quot; , scales::number(percentile_for_ht*100, accuracy = 1) , &quot;th percentile by site&quot; ) ) + theme_light() + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) what is the overall 5th percentile to use for minimum height? (neon_min_ht &lt;- quantile(neon_field_heights$height, probs = percentile_for_ht) %&gt;% floor()) ## 5% ## 6 let’s attach this to our data frame of lidar data files lidar_df &lt;- lidar_df %&gt;% dplyr::left_join(neon_site_heights, by = &quot;siteID&quot;) %&gt;% dplyr::mutate(site_prcntl_ht = dplyr::coalesce(site_prcntl_ht,neon_min_ht)) 3.3.3 cloud2trees::cloud2trees() ans &lt;- cloud2trees::cloud2trees( input_las_dir = lidar_df$f_path[lidar_df_row] , output_dir = tempdir() , min_height = lidar_df$site_prcntl_ht[lidar_df_row] ) ## Read files headers: [==========] 100% (1 threads) Overall: [ ] 0% (1 threads) | : no progress Overall: [ ] 0% (1 threads) | read_las: [ ] 0% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [ ] 1% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [ ] 2% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [ ] 3% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [ ] 4% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [ ] 5% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [ ] 6% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [ ] 7% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [ ] 8% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [ ] 9% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [= ] 10% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [= ] 11% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [= ] 12% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [= ] 13% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [= ] 14% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [= ] 15% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [= ] 16% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [= ] 17% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [= ] 18% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [= ] 19% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [== ] 20% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [== ] 21% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [== ] 22% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [== ] 23% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [== ] 24% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [== ] 25% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [== ] 26% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [== ] 27% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [== ] 28% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [== ] 29% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [=== ] 30% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [=== ] 31% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [=== ] 32% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [=== ] 33% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [=== ] 34% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [=== ] 35% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [=== ] 36% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [=== ] 37% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [=== ] 38% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [=== ] 39% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==== ] 40% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==== ] 41% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==== ] 42% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==== ] 43% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==== ] 44% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==== ] 45% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==== ] 46% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==== ] 47% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==== ] 48% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==== ] 49% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [===== ] 50% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [===== ] 51% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [===== ] 52% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [===== ] 53% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [===== ] 54% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [===== ] 55% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [===== ] 56% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [===== ] 57% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [===== ] 58% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [===== ] 59% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [====== ] 60% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [====== ] 61% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [====== ] 62% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [====== ] 63% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [====== ] 64% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [====== ] 65% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [====== ] 66% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [====== ] 67% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [====== ] 68% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [====== ] 69% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======= ] 70% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======= ] 71% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======= ] 72% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======= ] 73% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======= ] 74% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======= ] 75% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======= ] 76% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======= ] 77% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======= ] 78% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======= ] 79% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======== ] 80% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======== ] 81% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======== ] 82% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======== ] 83% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======== ] 84% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======== ] 85% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======== ] 86% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======== ] 87% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======== ] 88% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [======== ] 89% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [========= ] 90% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [========= ] 91% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [========= ] 92% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [========= ] 93% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [========= ] 94% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [========= ] 95% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [========= ] 96% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [========= ] 97% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [========= ] 98% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [========= ] 99% (1 threads) Overall: [ ] 0% (1 threads) | read_las: [==========] 100% (1 threads) Overall: [ ] 0% (1 threads) | CSF: no progress Overall: [ ] 0% (1 threads) | Delaunay triangulation: no progress Overall: [ ] 0% (1 threads) | Delaunay triangulation: no progress Overall: [ ] 0% (1 threads) | Interpolation: [ ] 0% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 1% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 2% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 3% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 4% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 5% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 6% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 7% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 8% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 9% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [==========] 100% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 0% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 1% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 2% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 3% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 4% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 5% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 6% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 7% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 8% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [ ] 9% (10 threads) Overall: [ ] 0% (1 threads) | Interpolation: [==========] 100% (10 threads) Overall: [ ] 0% (1 threads) | Write LAS: [ ] 0% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [ ] 1% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [ ] 2% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [ ] 3% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [ ] 4% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [ ] 5% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [ ] 6% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [ ] 7% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [ ] 8% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [ ] 9% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [= ] 10% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [= ] 11% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [= ] 12% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [= ] 13% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [= ] 14% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [= ] 15% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [= ] 16% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [= ] 17% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [= ] 18% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [= ] 19% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [== ] 20% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [== ] 21% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [== ] 22% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [== ] 23% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [== ] 24% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [== ] 25% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [== ] 26% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [== ] 27% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [== ] 28% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [== ] 29% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [=== ] 30% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [=== ] 31% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [=== ] 32% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [=== ] 33% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [=== ] 34% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [=== ] 35% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [=== ] 36% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [=== ] 37% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [=== ] 38% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [=== ] 39% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==== ] 40% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==== ] 41% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==== ] 42% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==== ] 43% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==== ] 44% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==== ] 45% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==== ] 46% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==== ] 47% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==== ] 48% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==== ] 49% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [===== ] 50% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [===== ] 51% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [===== ] 52% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [===== ] 53% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [===== ] 54% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [===== ] 55% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [===== ] 56% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [===== ] 57% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [===== ] 58% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [===== ] 59% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [====== ] 60% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [====== ] 61% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [====== ] 62% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [====== ] 63% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [====== ] 64% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [====== ] 65% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [====== ] 66% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [====== ] 67% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [====== ] 68% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [====== ] 69% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======= ] 70% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======= ] 71% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======= ] 72% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======= ] 73% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======= ] 74% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======= ] 75% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======= ] 76% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======= ] 77% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======= ] 78% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======= ] 79% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======== ] 80% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======== ] 81% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======== ] 82% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======== ] 83% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======== ] 84% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======== ] 85% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======== ] 86% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======== ] 87% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======== ] 88% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [======== ] 89% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [========= ] 90% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [========= ] 91% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [========= ] 92% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [========= ] 93% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [========= ] 94% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [========= ] 95% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [========= ] 96% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [========= ] 97% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [========= ] 98% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [========= ] 99% (1 threads) Overall: [ ] 0% (1 threads) | Write LAS: [==========] 100% (1 threads) Overall: [==========] 100% (1 threads) | Overall: [==========] 100% (1 threads) quick check our our heights ans$crowns_sf$tree_height_m %&gt;% summary() ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 6.498 11.685 15.795 23.470 33.645 52.462 3.3.4 Format extracted tree polygons we need to format our extracted trees for NeonTreeEvaluation evaluation and submission first, we’ll simplify multipolygon crowns ans$crowns_sf &lt;- cloud2trees::simplify_multipolygon_crowns(ans$crowns_sf) check out our extracted trees ggplot2::ggplot() + ggplot2::geom_tile( data = ans$chm_rast %&gt;% terra::as.data.frame(xy=T) %&gt;% dplyr::rename(f=3) , mapping = ggplot2::aes(x = x, y = y, fill = f) , na.rm = T ) + harrypotter::scale_fill_hp( option = &quot;gryffindor&quot; , breaks = scales::breaks_extended(n=10) ) + ggplot2::geom_sf( data = ans$crowns_sf , fill = NA, color = &quot;gray33&quot;, lwd = 1 ) + ggplot2::scale_x_continuous(expand = c(0, 0)) + ggplot2::scale_y_continuous(expand = c(0, 0)) + ggplot2::labs(x = &quot;&quot;, y = &quot;&quot;, fill = &quot;CHM (m)&quot;) + ggplot2::theme_light() + ggplot2::theme(axis.text = ggplot2::element_blank()) we’ll reserve judgement and let the data talk format the data for NeonTreeEvaluation submission and evaluation return_sf &lt;- ans$crowns_sf %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% dplyr::rowwise(&quot;treeID&quot;) %&gt;% dplyr::mutate( xmin = sf::st_bbox(geometry)[1] , ymin = sf::st_bbox(geometry)[2] , xmax = sf::st_bbox(geometry)[3] , ymax = sf::st_bbox(geometry)[4] ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( label = &quot;Tree&quot; , plot_name = lidar_df$plot_name[lidar_df_row] ) %&gt;% dplyr::select(xmin,xmax,ymin,ymax,label,plot_name) %&gt;% sf::st_set_crs(NA) # what? return_sf %&gt;% dplyr::glimpse() ## Rows: 36 ## Columns: 7 ## $ xmin &lt;dbl&gt; 314489.2, 314481.0, 314456.0, 314489.8, 314481.2, 314457.0, … ## $ xmax &lt;dbl&gt; 314490.2, 314483.2, 314463.2, 314496.0, 314491.5, 314458.8, … ## $ ymin &lt;dbl&gt; 4099619, 4099617, 4099611, 4099610, 4099606, 4099609, 409960… ## $ ymax &lt;dbl&gt; 4099620, 4099620, 4099620, 4099620, 4099619, 4099611, 409961… ## $ label &lt;chr&gt; &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tre… ## $ plot_name &lt;chr&gt; &quot;2018_TEAK_3_314000_4099000_image_334&quot;, &quot;2018_TEAK_3_314000_… ## $ geometry &lt;POLYGON&gt; POLYGON ((314489.2 4099620,..., POLYGON ((314481 4099620… does this match the submission polygon data from the NeonTreeEvaluation package? NeonTreeEvaluation::submission_polygons %&gt;% dplyr::glimpse() ## Rows: 126,574 ## Columns: 8 ## $ xmin &lt;dbl&gt; 41.01716, 357.32129, 30.39723, 260.65921, 179.34564, 316.2… ## $ ymin &lt;dbl&gt; 230.8854218, 122.1164017, 136.9156647, 285.6688843, 371.61… ## $ xmax &lt;dbl&gt; 151.08607, 397.57458, 73.79434, 299.68811, 232.49385, 363.… ## $ ymax &lt;dbl&gt; 342.69846, 159.37578, 184.94730, 326.79330, 400.00000, 400… ## $ score &lt;dbl&gt; 0.8098674, 0.6968824, 0.5713338, 0.5511004, 0.4697072, 0.3… ## $ label &lt;chr&gt; &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;T… ## $ plot_name &lt;chr&gt; &quot;DSNY_014_2019&quot;, &quot;DSNY_014_2019&quot;, &quot;DSNY_014_2019&quot;, &quot;DSNY_0… ## $ st_sfc.lst. &lt;POLYGON&gt; POLYGON ((41.01716 230.8854..., POLYGON ((357.3213 122… yes, except for the “score” column which I’m pretty sure is an artifact from after evaluation? 3.3.5 Test evaluation We compared our tree detection and crown delineation results to the three types of evaluation data (i.e. “ground truth” data) presented by Weinstein et al. (2021): field-collected stems, image-annotated crowns, and field-annotated crowns. Field-collected stems offer precise tree locations but might not align with the position of the tree crown as viewed from above (e.g. due to tree lean), image-annotated crowns outline crown boundaries but are subjective, and field-annotated crowns combine the benefits of both but are highly resource-intensive. 3.3.5.1 Scores for an image-annotated crowns The main data source are image-annotated crowns, in which a single observer annotated visible trees in 200 40m x 40m images from across the United States. Get the benchmark score image-annotated “ground truth” data. in testing, including the sf polygon data did not work…switching to the bbox method with sf::st_drop_geometry() rslt_img_annttd_crwns &lt;- NeonTreeEvaluation::evaluate_image_crowns( predictions = return_sf %&gt;% sf::st_drop_geometry() , show = T , summarize = T ) ## [1] &quot;2018_TEAK_3_314000_4099000_image_334&quot; in the plot (if there is a plot), “red” boxes are crowns our point cloud-based method extracted and “black” are the image annotated crowns it looks like the overlay is generally the same but we are still extracting trees that may not be considered “canopy” trees ; what is in the return from NeonTreeEvaluation::evaluate_image_crowns() ? rslt_img_annttd_crwns %&gt;% names() ## [1] &quot;overall&quot; &quot;by_site&quot; &quot;plot_level&quot; &quot;count_error&quot; overall: must be across all NEON sites, plots, and trees included for evaluation rslt_img_annttd_crwns$overall ## # A tibble: 1 × 2 ## precision recall ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.194 0.28 by_site: must be across plots, and trees included for evaluation in a NEON sites rslt_img_annttd_crwns$by_site ## # A tibble: 1 × 3 ## # Groups: Site [1] ## Site recall precision ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 TEAK 0.28 0.194 plot_level: must be across trees included for evaluation in a NEON site, plot combination rslt_img_annttd_crwns$plot_level ## # A tibble: 1 × 3 ## # Groups: plot_name [1] ## plot_name recall precision ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2018_TEAK_3_314000_4099000_image_334 0.28 0.194 count_error is the number of predicted trees minus the number of “ground truth” trees but in graphical form so we’ll skip it 3.3.5.2 Scores for an field-annotated crowns The second data source is a small number of field-annotated crowns from two geographic sites. These crowns were drawn on a tablet while physically standing in the field, thereby reducing the uncertainty in crown segmentation. not all plots have field-annotated crowns NeonTreeEvaluation::evaluate_field_crowns() returns an error if “No plot names matching the field crown data, see list_field_crowns for paths to RGB field crown imagery.”… so, we’ll have to capture errors in our checks? # safe it safe_evaluate_field_crowns &lt;- purrr::safely(NeonTreeEvaluation::evaluate_field_crowns) # test it rslt_fld_crwns &lt;- safe_evaluate_field_crowns( predictions = return_sf %&gt;% sf::st_drop_geometry() , show = T , summarize = T ) did it do it? rslt_fld_crwns$error ## &lt;simpleError in .f(...): No plot names matching the field crown data, see list_field_crowns for paths to RGB field crown imagery.&gt; nope! 3.3.5.3 Scores for an field-collected stems The third data source is the NEON Woody Vegetation Structure Dataset. Each tree stem is represented by a single point. This data has been filtered to represent overstory trees visible in the remote sensing imagery. not all plots have field-collected stems NeonTreeEvaluation::evaluate_field_stems() returns an error if “No submitted plot_names with matching field stem data, see list_field_stems()”… so, we’ll have to capture errors in our checks? # safe it safe_evaluate_field_stems &lt;- purrr::safely(NeonTreeEvaluation::evaluate_field_stems) # test it rslt_fld_stems &lt;- safe_evaluate_field_stems( predictions = return_sf %&gt;% sf::st_drop_geometry() , show = T , summarize = T ) did it do it? rslt_fld_stems$error ## &lt;simpleError in .f(...): No submitted plot_names with matching field stem data, see list_field_stems()&gt; nope! 3.4 Full validation process Above, we tested the validation process for a single sample plot. Here we’ll create a function to detect trees and delineate tree crowns using our cloud2trees::cloud2trees() method to apply over all sample plots. Then we’ll compare our tree detection and crown delineation results to the three types of evaluation data (i.e. “ground truth” data) presented by Weinstein et al. (2021): field-collected stems, image-annotated crowns, and field-annotated crowns. Field-collected stems offer precise tree locations but might not align with the position of the tree crown as viewed from above (e.g. due to tree lean), image-annotated crowns outline crown boundaries but are subjective, and field-annotated crowns combine the benefits of both but are highly resource-intensive. 3.4.1 Function to extract trees let’s create a function to extract trees and format for evaluation using our lidar_df data which includes a data frame of file paths with the appropriate plot name cloud2trees_for_eval &lt;- function(lidar_df_row, lidar_df, ws, min_height = NA) { # message message(paste0(&quot;doing the work for ...... &quot;, lidar_df$plot_name[lidar_df_row])) # run c2t qc2t &lt;- purrr::safely(cloud2trees::cloud2trees) ans &lt;- qc2t( input_las_dir = lidar_df$f_path[lidar_df_row] , output_dir = tempdir() , min_height = dplyr::coalesce(min_height, lidar_df$site_prcntl_ht[lidar_df_row], 2) , ws = ws ) if(!is.null(ans$error)){return(NULL)} ans &lt;- ans$result # simp ans$crowns_sf &lt;- cloud2trees::simplify_multipolygon_crowns(ans$crowns_sf) # return return_sf &lt;- ans$crowns_sf %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% dplyr::rowwise(&quot;treeID&quot;) %&gt;% dplyr::mutate( xmin = sf::st_bbox(geometry)[1] , ymin = sf::st_bbox(geometry)[2] , xmax = sf::st_bbox(geometry)[3] , ymax = sf::st_bbox(geometry)[4] ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( label = &quot;Tree&quot; , plot_name = lidar_df$plot_name[lidar_df_row] ) %&gt;% dplyr::select(xmin,xmax,ymin,ymax,label,plot_name) %&gt;% sf::st_set_crs(NA) # give the workers a rest Sys.sleep(3) return(return_sf) } 3.4.2 Build evaluation data let’s run each point cloud through our lidar-based tree detection implemented via cloud2trees::cloud2trees() # where should we save the file? submission_fn &lt;- &quot;../data/NeonTreeEvaluation_submission.gpkg&quot; # if we don&#39;t already have the data, run it if(!file.exists(submission_fn)){ # if(T){ my_submission &lt;- # 1:nrow(lidar_df) %&gt;% # uncomment this when it gets real sample(1:nrow(lidar_df), size = 222) %&gt;% purrr::map(\\(x) cloud2trees_for_eval( lidar_df_row = x , lidar_df = lidar_df , ws = cloud2trees::itd_ws_functions()[[&quot;log_fn&quot;]] ) ) %&gt;% dplyr::bind_rows() # save it sf::st_write(my_submission, submission_fn, append = F) }else{ my_submission &lt;- sf::st_read(submission_fn) } what did we get? my_submission %&gt;% dplyr::glimpse() ## Rows: 9,547 ## Columns: 7 ## $ xmin &lt;dbl&gt; 553118.8, 553114.0, 553114.5, 553119.0, 553102.2, 553102.5, … ## $ xmax &lt;dbl&gt; 553120.0, 553115.5, 553115.8, 553119.8, 553103.0, 553103.2, … ## $ ymin &lt;dbl&gt; 5065836, 5065821, 5065821, 5065819, 5065812, 5065812, 410758… ## $ ymax &lt;dbl&gt; 5065837, 5065823, 5065823, 5065819, 5065813, 5065812, 410758… ## $ label &lt;chr&gt; &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tree&quot;, &quot;Tre… ## $ plot_name &lt;chr&gt; &quot;ABBY_021_2019&quot;, &quot;ABBY_021_2019&quot;, &quot;ABBY_021_2019&quot;, &quot;ABBY_021… ## $ geom &lt;POLYGON&gt; POLYGON ((553119.2 5065837,..., POLYGON ((553114.8 50658… trees detected by plot my_submission %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(plot_name) %&gt;% dplyr::slice_sample(n=14) %&gt;% dplyr::arrange(plot_name) %&gt;% kableExtra::kbl(caption = &quot;cloud2trees ITD results by plot&quot;, digits = 0) %&gt;% kableExtra::kable_styling() Table 3.4: cloud2trees ITD results by plot plot_name n 2018_TEAK_3_318000_4107000_image_416 9 2018_TEAK_3_318000_4107000_image_718 1 DEJU_029_2018 3 JERC_036_2018 67 NIWO_017_2018 109 OSBS_009_2018 43 OSBS_029_2019 95 OSBS_051_2019 15 SOAP_009_2019 47 SOAP_024_2019 45 SOAP_045_2019 24 TALL_007_2019 47 TEAK_030_2018 7 YELL_051_2018 6 3.4.3 Full evaluation We compared our tree detection and crown delineation results to the three types of evaluation data (i.e. “ground truth” data) presented by Weinstein et al. (2021): field-collected stems, image-annotated crowns, and field-annotated crowns. Field-collected stems offer precise tree locations but might not align with the position of the tree crown as viewed from above (e.g. due to tree lean), image-annotated crowns outline crown boundaries but are subjective, and field-annotated crowns combine the benefits of both but are highly resource-intensive. 3.4.3.1 Scores for an image-annotated crowns The main data source are image-annotated crowns, in which a single observer annotated visible trees in 200 40m x 40m images from across the United States. Get the benchmark score image-annotated “ground truth” data. in testing, including the sf polygon data did not work…switching to the bbox method with sf::st_drop_geometry() rslt_img_annttd_crwns &lt;- NeonTreeEvaluation::evaluate_image_crowns( predictions = my_submission %&gt;% sf::st_drop_geometry() , show = F , summarize = T ) overall: must be across all NEON sites, plots, and trees included for evaluation rslt_img_annttd_crwns$overall %&gt;% kableExtra::kbl( caption = &quot;Overall: cloud2trees ITD performance versus image-annotated crowns&quot; , digits = 3 ) %&gt;% kableExtra::kable_styling() Table 3.5: Overall: cloud2trees ITD performance versus image-annotated crowns precision recall 0.301 0.42 by_site: must be across plots, and trees included for evaluation in a NEON sites rslt_img_annttd_crwns$by_site %&gt;% kableExtra::kbl( caption = &quot;NEON site-level: cloud2trees ITD performance versus image-annotated crowns&quot; , digits = 3 ) %&gt;% kableExtra::kable_styling() Table 3.6: NEON site-level: cloud2trees ITD performance versus image-annotated crowns Site recall precision ABBY 0.702 0.541 DSNY 1.000 0.250 JERC 0.857 0.316 NIWO 0.274 0.353 OSBS 0.469 0.303 SOAP 0.220 0.224 TALL 0.241 0.359 TEAK 0.365 0.316 plot_level: must be across trees included for evaluation in a NEON site, plot combination rslt_img_annttd_crwns$plot_level %&gt;% dplyr::ungroup() %&gt;% dplyr::slice_sample(n=14) %&gt;% dplyr::arrange(plot_name) %&gt;% kableExtra::kbl( caption = &quot;NEON plot-level: cloud2trees ITD performance versus image-annotated crowns&quot; , digits = 3 ) %&gt;% kableExtra::kable_styling() Table 3.7: NEON plot-level: cloud2trees ITD performance versus image-annotated crowns plot_name recall precision 2018_TEAK_3_314000_4099000_image_334 0.240 0.261 2018_TEAK_3_318000_4102000_image_483 0.667 0.308 2018_TEAK_3_318000_4107000_image_718 0.000 0.000 2018_TEAK_3_320000_4095000_image_616 0.302 0.381 2018_TEAK_3_322000_4096000_image_368 0.286 0.222 DSNY_005_2018 1.000 0.250 OSBS_023_2019 0.500 0.105 OSBS_029_2019 0.619 0.411 OSBS_032_2019 0.405 0.238 OSBS_051_2019 0.750 0.400 SOAP_031_2019 0.220 0.224 TEAK_049_2018 0.440 0.407 TEAK_053_2018 0.300 0.375 TEAK_061_2018 0.171 0.219 how many plots did we evaluate that met all criteria?: had point cloud data in the benchmark was from a NEON site with primarily conifer trees *had image-annotated crowns for evaluation # how many plots did we evaluate that met all criteria? rslt_img_annttd_crwns$plot_level %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct(plot_name) %&gt;% nrow() ## [1] 31 how many plots were evaluated using cloud2trees::cloud2trees() by NEON site? img_annttd_crwn_plots_temp &lt;- lidar_df %&gt;% dplyr::inner_join( rslt_img_annttd_crwns$plot_level %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct(plot_name) , by = &quot;plot_name&quot; ) # plots evaluated by neon site img_annttd_crwn_plots_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(siteID) %&gt;% dplyr::arrange(desc(n)) %&gt;% kableExtra::kbl( caption = &quot;Number of 40m x 40m plots with image-annotated crowns evaluated using cloud2trees by NEON site&quot; , digits = 3 ) %&gt;% kableExtra::kable_styling() Table 3.8: Number of 40m x 40m plots with image-annotated crowns evaluated using cloud2trees by NEON site siteID n TEAK 17 OSBS 6 NIWO 3 ABBY 1 DSNY 1 JERC 1 SOAP 1 TALL 1 where are these NEON sites evaluated using cloud2trees::cloud2trees()? img_annttd_crwn_plots_temp %&gt;% dplyr::count(siteID) %&gt;% mapview::mapview( cex = &quot;n&quot;, legend = F , layer.name = &quot;NEON site&quot; ) let’s review some figures comparing the image-annotated crowns versus the bounding box of our delineated crown polygons in the RGB plots: “red” boxes are crowns from our point cloud-based method extracted and “black” are the image annotated crowns rslt_img_annttd_crwns$plot_level %&gt;% dplyr::ungroup() %&gt;% dplyr::slice_sample(n=4) %&gt;% dplyr::pull(plot_name) %&gt;% purrr::map(\\(x) NeonTreeEvaluation::image_crowns( predictions = my_submission %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(plot_name==x) , show = T , project_boxes = F )) in the RGB plots: “red” boxes are crowns from our point cloud-based method extracted and “black” are the image annotated crowns 3.4.3.2 Scores for an field-annotated crowns The second data source is a small number of field-annotated crowns from two geographic sites. These crowns were drawn on a tablet while physically standing in the field, thereby reducing the uncertainty in crown segmentation. none of the field-annotated crown sites have aerial lidar data # i did some digging around and the lidar data is here lidar_dir_temp &lt;- system.file(package = &quot;NeonTreeEvaluation&quot;, &quot;extdata&quot;, &quot;NeonTreeEvaluation&quot;, &quot;evaluation&quot;, &quot;LiDAR&quot;) # files lidar_files_temp &lt;- lidar_dir_temp %&gt;% list.files(recursive = T, pattern = &quot;.*\\\\.(laz|las)$&quot;, full.names = T) %&gt;% basename() %&gt;% stringr::str_remove_all(&quot;\\\\.(laz|las)$&quot;) %&gt;% unique() # what sites have field annotated crowns? fc_temp &lt;- NeonTreeEvaluation::list_field_crowns() %&gt;% stringr::str_match(pattern=&quot;(\\\\w+).tif&quot;) %&gt;% .[,2] # are any lidar files available for these sites? lidar_files_temp[lidar_files_temp %in% fc_temp] %&gt;% length() ## [1] 0 nope! 3.4.3.3 Scores for an field-collected stems The third data source is the NEON Woody Vegetation Structure Dataset. Each tree stem is represented by a single point. This data has been filtered to represent overstory trees visible in the remote sensing imagery. not all plots have field-collected stems in testing, including the sf polygon data did not work…switching to the bbox method with sf::st_drop_geometry() rslt_fld_stems &lt;- evaluate_field_stems( predictions = my_submission %&gt;% sf::st_drop_geometry() , show = F , summarize = T ) overall: must be across all NEON sites, plots, and trees included for evaluation rslt_fld_stems$overall %&gt;% kableExtra::kbl( caption = &quot;Overall: cloud2trees ITD performance versus field-collected stems&quot; , digits = 3 ) %&gt;% kableExtra::kable_styling() Table 3.9: Overall: cloud2trees ITD performance versus field-collected stems recall 0.776 by_site: must be across plots, and trees included for evaluation in a NEON sites rslt_fld_stems$by_site %&gt;% kableExtra::kbl( caption = &quot;NEON site-level: cloud2trees ITD performance versus field-collected stems&quot; , digits = 3 ) %&gt;% kableExtra::kable_styling() Table 3.10: NEON site-level: cloud2trees ITD performance versus field-collected stems Site recall ABBY 0.333 DEJU 0.885 JERC 0.743 MOAB 0.909 NIWO 0.501 OSBS 0.914 TALL 0.667 plot_level: must be across trees included for evaluation in a NEON site, plot combination rslt_fld_stems$plot_level %&gt;% dplyr::ungroup() %&gt;% dplyr::slice_sample(n=14) %&gt;% dplyr::arrange(plot_name) %&gt;% kableExtra::kbl( caption = &quot;NEON plot-level: cloud2trees ITD performance versus field-collected stems&quot; , digits = 3 ) %&gt;% kableExtra::kable_styling() Table 3.11: NEON plot-level: cloud2trees ITD performance versus field-collected stems siteID plot_name recall n DEJU DEJU_014 0.714 7 DEJU DEJU_016 1.000 2 DEJU DEJU_062 0.667 3 JERC JERC_051 0.714 7 NIWO NIWO_005 0.571 14 NIWO NIWO_007 0.407 54 NIWO NIWO_010 0.622 37 NIWO NIWO_040 0.450 40 OSBS OSBS_009 0.800 5 OSBS OSBS_026 0.833 18 OSBS OSBS_029 0.750 20 OSBS OSBS_035 1.167 12 OSBS OSBS_038 0.722 18 TALL TALL_050 0.667 24 how many plots did we evaluate that met all criteria?: had point cloud data in the benchmark was from a NEON site with primarily conifer trees *had field-collected stems for evaluation # how many plots did we evaluate that met all criteria? rslt_fld_stems$plot_level %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct(plot_name) %&gt;% nrow() ## [1] 43 how many plots were evaluated using cloud2trees::cloud2trees() by NEON site? fld_stems_plots_temp &lt;- lidar_df %&gt;% dplyr::mutate( sht_plt = plot_name %&gt;% stringr::str_extract( rslt_fld_stems$plot_level %&gt;% dplyr::ungroup() %&gt;% dplyr::distinct(plot_name) %&gt;% dplyr::pull(plot_name) %&gt;% paste(collapse = &quot;|&quot;) ) ) %&gt;% dplyr::filter(!is.na(sht_plt)) %&gt;% dplyr::group_by(siteID,sht_plt) %&gt;% dplyr::summarise(n=dplyr::n()) %&gt;% dplyr::ungroup() %&gt;% dplyr::rename(plot_name=sht_plt) # plots evaluated by neon site fld_stems_plots_temp %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(siteID) %&gt;% dplyr::arrange(desc(n)) %&gt;% kableExtra::kbl( caption = &quot;Number of 40m x 40m plots with field-collected stems evaluated using cloud2trees by NEON site&quot; , digits = 3 ) %&gt;% kableExtra::kable_styling() Table 3.12: Number of 40m x 40m plots with field-collected stems evaluated using cloud2trees by NEON site siteID n OSBS 16 DEJU 9 NIWO 9 JERC 5 TALL 2 ABBY 1 MOAB 1 where are these NEON sites evaluated using cloud2trees::cloud2trees()? fld_stems_plots_temp %&gt;% dplyr::count(siteID) %&gt;% mapview::mapview( cex = &quot;n&quot;, legend = F , layer.name = &quot;NEON site&quot; ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
