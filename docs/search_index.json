[["index.html", "Aerial LiDAR for Fire Model Inputs Section 1 Introduction 1.1 Objective 1.2 Data", " Aerial LiDAR for Fire Model Inputs George Woolsey 06 November, 2024 Section 1 Introduction Code in support of “Using aerial LiDAR data for object-based physical fire modeling in conifer forests of the southwestern US” 1.1 Objective The objective of this study is to demonstrate the use of aerial LiDAR data to create inputs for physics-based fire models in frequent-fire forests of the southwestern United States. We review the methods used to extract tree location, species, and physical form from aerial LiDAR data. We evaluate this canopy crown detection methodology using a benchmark data set created to standardize evaluation metrics (Weinstein et al. 2021). We explain how to format this data for seamless integration with two commonly used object-based physical fire modeling tools. We demonstrate the end-to-end process using a case study from the southwestern United States. 1.2 Data LiDAR data from the southwest US "],["s01.html", "Section 2 Data Load and Methods Explore 2.1 NeonTreeEvaluation 2.2 cloud2trees 2.3 LadderFuelsR 2.4 LadderFuelsR - simplified", " Section 2 Data Load and Methods Explore In this section we’ll review the packages we’ll be using to process and evaluate the lidar data. None of the analysis is happening here, just reviewing the methodologies. Load the standard libraries # bread-and-butter library(tidyverse) # the tidyverse library(viridis) # viridis colors library(harrypotter) # hp colors library(RColorBrewer) # brewer colors library(scales) # work with number and plot scales library(latex2exp) # visualization library(mapview) # interactive html maps library(kableExtra) # tables library(patchwork) # combine plots library(ggnewscale) # ggnewscale library(plot3D) # 3d plotting library(rgl) # rgl plotting # spatial analysis library(terra) # raster library(sf) # simple features library(lidR) # lidar data # models library(brms) # bayesian modelling # utilities library(rvest) # web scraping Load the libraries from GitHub. Here we’ll load: NeonTreeEvaluation: benchmark data set to evaluate lidar-based tree detection (Weinstein et al. 2021) cloud2trees: routines for processing point cloud data collected by airborne lidar to detect forest trees (Woolsey and Tinkham, 2024) LadderFuelsR: vertical fuel continuity quantification and crown base height (CBH) calculation (Viedma et al. 2024) lasR: complex processing pipelines on lidar data (Roussel 2024) leafR: set of functions for analyzing the ecological structure of forests based on LAI and LAD measures derived from LiDAR data (Roussel 2024). Data from this package used in the LadderFuelsR workflow even though this process is never explained by Viedma et al. 2024. library(pak) # load them c(&quot;NeonTreeEvaluation&quot;, &quot;cloud2trees&quot;, &quot;LadderFuelsR&quot;, &quot;lasR&quot;, &quot;leafR&quot;) %&gt;% # install and load purrr::map(function(x){ # locations df &lt;- dplyr::tibble( p = c(&quot;NeonTreeEvaluation&quot;, &quot;cloud2trees&quot;, &quot;LadderFuelsR&quot;, &quot;lasR&quot;, &quot;leafR&quot;) , l = c( &quot;weecology/NeonTreeEvaluation_package&quot; , &quot;georgewoolsey/cloud2trees&quot; , &quot;olgaviedma/LadderFuelsR&quot; , &quot;r-lidar/lasR&quot; , &quot;DRAAlmeida/leafR&quot; ) ) # install if needed if(!require(x, character.only = T)){ pak::pkg_install( pkg = df %&gt;% dplyr::filter(tolower(p)==tolower(x)) %&gt;% dplyr::pull(l) , upgrade = T ) } # load library(x, character.only = T) }) 2.1 NeonTreeEvaluation Weinstein et al. (2021) developed: a benchmark dataset of individual canopy crowns derived from multi-sensor imagery in the National Ecological Observatory Network (Table 1) that provides: 1) co-registered remote sensing data from multiple sensors (LiDAR, RGB imagery, and hyperspectral imagery) to allow comparisons of methods based on any single sensor (e.g., for LiDAR based methods), or any combination of sensors (e.g., combining RGB and hyperspectral), and 2) three types of evaluation data to allow assessing both ‘tree detection’, defined as the identifying the location of individual trees using evaluation data with a point at the crown center , and ‘crown delineation’ defined as identifying the boundary edge of crowns across a broad range of forest types. The benchmark is designed to allow flexibility in both workflow and sensor selection. (p. 2) Table 1. Summary of datasets included in the benchmark dataset. All sensor data has been cropped to the extent of NEON field sampling plots. The objective of the present analysis is to evaluate the use of this benchmark data set (Weinstein et al. 2021) for a scientific publication describing a workflow to ingest raw LiDAR data and export a tabular tree list for use as an input to the QUIC-Fire physics-based fire spread model (Linn et al. 2020). Weinstein et al. (2021) describe the LiDAR data in the benchmark data set: The LiDAR data are 3D coordinates (~5 points/m2) that provide high resolution information about canopy crown shape and height. LiDAR data are stored as 1000m x 1000m.laz files (Fig 2). These files contain the x,y,z coordinates for each return, as well as metadata on return intensity and point classification. Boundaries of individual canopy crowns are often apparent due to gaps among neighboring trees or differences in height among overlapping canopy crowns. For more information on NEON LiDAR data processing see NEON technical document NEON.DOC.001292. Due to the large spatial coverage of the collection effort, the point density of the NEON LiDAR clouds is much lower than the point density used for most studies of crown detection models ([20, 21]; point densities of 8–1000 pt/m2). (p. 4) what’s in this package? lsf.str(&quot;package:NeonTreeEvaluation&quot;) ## boxes_to_spatial_polygons : function (boxes, raster_object, project_boxes = TRUE) ## canopy_model : function (las, res = 0.5) ## check_download : function () ## compute_precision_recall : function (ground_truth, predictions, threshold = 0.4, summarize = TRUE) ## download : function (training = FALSE, savedir = NULL, force = F) ## evaluate_field_crowns : function (predictions, summarize = TRUE, show = TRUE, project = FALSE) ## evaluate_field_stems : function (predictions, project = TRUE, show = T, summarize = T) ## evaluate_image_crowns : function (predictions, project = FALSE, show = TRUE, summarize = TRUE) ## field_crowns : function (x, show = TRUE, project_boxes = TRUE) ## get_data : function (plot_name, type) ## grand_summary : function (results, threshold = 0.4) ## image_crowns : function (predictions, show = TRUE, project_boxes = TRUE) ## list_annotations : function () ## list_chm : function () ## list_field_crowns : function () ## list_field_stems : function () ## list_rgb : function () ## load_field_crown : function (plot_name, show = TRUE) ## load_ground_truth : function (plot_name, show = TRUE) ## xml_parse : function (path) ## zenodo_url : function (concept_rec_id = 3723356, rec_version = &quot;latest&quot;, rec_id = NULL) ## zenodo_versions : function (concept_rec_id, arg_checks = TRUE) we first have to download evaluation data from the Zenodo archive (1GB), use the download() function to place the data in the correct package location. Download the much larger training data, set training=TRUE. NeonTreeEvaluation::download(training = T, force = F) ## NULL what data is in this package? # what/where is this data paste0(system.file(package = &quot;NeonTreeEvaluation&quot;),&quot;/extdata/&quot;) %&gt;% list.files(recursive = T, pattern = &quot;.*\\\\.(laz|las)$&quot;, full.names = F) %&gt;% sample() %&gt;% .[1:10] ## [1] &quot;NeonTreeEvaluation/evaluation/LiDAR/OSBS_268.las&quot; ## [2] &quot;NeonTreeEvaluation/evaluation/LiDAR/TEAK_002_2019.laz&quot; ## [3] &quot;NeonTreeEvaluation/evaluation/LiDAR/TEAK_050_2018.laz&quot; ## [4] &quot;NeonTreeEvaluation/evaluation/LiDAR/BONA_074_2019.laz&quot; ## [5] &quot;NeonTreeEvaluation/evaluation/LiDAR/DEJU_027_2019.laz&quot; ## [6] &quot;NeonTreeEvaluation/evaluation/LiDAR/SOAP_057_2019.laz&quot; ## [7] &quot;NeonTreeEvaluation/evaluation/LiDAR/JORN_002_2019.laz&quot; ## [8] &quot;NeonTreeEvaluation/evaluation/LiDAR/SJER_057_2018.laz&quot; ## [9] &quot;NeonTreeEvaluation/evaluation/LiDAR/BLAN_007_2019.laz&quot; ## [10] &quot;NeonTreeEvaluation/evaluation/LiDAR/unnamed_plot_134.las&quot; For a list of NEON site abbreviations https://www.neonscience.org/field-sites/field-sites-map NeonTreeEvaluation::list_annotations looks into package contents for ground truth annotations for the image-annotated crowns. # list_annotations NeonTreeEvaluation::list_annotations() %&gt;% sample() %&gt;% .[1:10] ## [1] &quot;OSBS_022_2019&quot; ## [2] &quot;2018_TEAK_3_314000_4108000_image_86&quot; ## [3] &quot;8&quot; ## [4] &quot;TEAK_045_2018&quot; ## [5] &quot;2019_LENO_5_383000_3523000_image_crop&quot; ## [6] &quot;DELA_047_2019&quot; ## [7] &quot;DSNY_012_2018&quot; ## [8] &quot;UNDE_006_2017&quot; ## [9] &quot;2018_TEAK_3_316000_4097000_image_493&quot; ## [10] &quot;TEAK_050_2018&quot; The field collected stems are individual points for each tree. They overlap with a subset of the sensor data. Use the NeonTreeEvaluation::list_field_stems function to determine which plots have stem data. # list_field_stems NeonTreeEvaluation::list_field_stems() %&gt;% sample() %&gt;% .[1:10] ## [1] &quot;DELA_039&quot; &quot;SERC_002&quot; &quot;LENO_017&quot; &quot;STEI_002&quot; &quot;RMNP_013&quot; &quot;MLBS_017&quot; ## [7] &quot;MLBS_073&quot; &quot;OSBS_038&quot; &quot;TALL_009&quot; &quot;SCBI_011&quot; The NeonTreeEvaluation::crown_polygons function lists “field-annotated crowns” in which an observer annotates a polygon on the remote-sensing image on a tablet while standing in the field. From Ordway Swisher Biological Station, Florida and Mountain Lake Biological Station. # crown_polygons NeonTreeEvaluation::crown_polygons %&gt;% dplyr::glimpse() ## Rows: 564 ## Columns: 7 ## $ indvdID &lt;chr&gt; &quot;MLBSE00007&quot;, &quot;MLBSE00012&quot;, &quot;MLBSE00027&quot;, &quot;MLBSE00049&quot;, &quot;… ## $ geometry &lt;POLYGON [m]&gt; POLYGON ((541983.5 4136174,..., POLYGON ((542127 … ## $ plotID &lt;fct&gt; MLBS_14, MLBS_37, MLBS_42, MLBS_1, MLBS_21, MLBS_23, MLBS… ## $ siteID &lt;fct&gt; MLBS, MLBS, MLBS, MLBS, MLBS, MLBS, MLBS, MLBS, MLBS, MLB… ## $ utmZone &lt;fct&gt; 17N, 17N, 17N, 17N, 17N, 17N, 17N, 17N, 17N, 17N, 17N, 17… ## $ plotEasting &lt;dbl&gt; 541986.3, 542125.7, 542267.8, 541883.4, 542053.1, 542075.… ## $ plotNorthing &lt;dbl&gt; 4136173, 4136182, 4136994, 4136586, 4136390, 4136400, 413… Sites with field annotated crowns # crown_polygons NeonTreeEvaluation::crown_polygons %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(siteID) ## # A tibble: 2 × 2 ## siteID n ## &lt;fct&gt; &lt;int&gt; ## 1 MLBS 106 ## 2 OSBS 458 hmmm this data only exists for two NEON sites The woody vegetation structure data contains information on field estimated height and maximum crown diameter for the majority of field collected stems. We annotated all trees in the 40x40 m plot, regardless of health status, provided they were visible in the image. NeonTreeEvaluation::field %&gt;% dplyr::glimpse() ## Rows: 37,776 ## Columns: 67 ## $ uid &lt;fct&gt; 411f5c60-79c4-41ef-b3d0-4e9b5365870e, 0d… ## $ namedLocation &lt;fct&gt; ABBY_063.basePlot.vst, ABBY_063.basePlot… ## $ date &lt;fct&gt; 2015-07-23, 2015-07-23, 2015-07-23, 2015… ## $ tagEventID &lt;fct&gt; vst_ABBY_2015, vst_ABBY_2015, vst_ABBY_2… ## $ domainID &lt;fct&gt; D16, D16, D16, D16, D16, D16, D16, D16, … ## $ siteID &lt;fct&gt; ABBY, ABBY, ABBY, ABBY, ABBY, ABBY, ABBY… ## $ plotID &lt;fct&gt; ABBY_063, ABBY_063, ABBY_063, ABBY_063, … ## $ subplotID &lt;int&gt; 39, 21, 21, 21, 39, 39, 39, 39, 39, 39, … ## $ nestedSubplotID &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ pointID &lt;int&gt; 57, 21, 21, 21, 39, 41, 41, 41, 41, 41, … ## $ stemDistance &lt;dbl&gt; 3.0, 23.8, 23.8, 23.8, 26.2, 16.0, 16.0,… ## $ stemAzimuth &lt;dbl&gt; 111.0, 50.0, 50.0, 50.0, 45.4, 346.0, 34… ## $ recordType &lt;fct&gt; , , , , , , , , , , , , , , , , , , , , … ## $ individualID &lt;fct&gt; NEON.PLA.D16.ABBY.00441, NEON.PLA.D16.AB… ## $ supportingStemIndividualID &lt;fct&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ previouslyTaggedAs &lt;fct&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ samplingProtocolVersion &lt;fct&gt; NEON.DOC.000987vE, NEON.DOC.000987vE, NE… ## $ taxonID &lt;fct&gt; PSMEM, PSMEM, PSMEM, PSMEM, PSMEM, PSMEM… ## $ scientificName &lt;fct&gt; &quot;Pseudotsuga menziesii (Mirb.) Franco va… ## $ taxonRank &lt;fct&gt; variety, variety, variety, variety, vari… ## $ identificationReferences &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ morphospeciesID &lt;fct&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ morphospeciesIDRemarks &lt;fct&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ identificationQualifier &lt;fct&gt; , , , , , , , , , , , , , , , , , , , , … ## $ remarks &lt;fct&gt; &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;corrected using 201… ## $ measuredBy &lt;fct&gt; krian@neoninc.org, krian@neoninc.org, kr… ## $ recordedBy &lt;fct&gt; kzias@field-ops.org, kzias@field-ops.org… ## $ dataQF &lt;fct&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ plotType &lt;fct&gt; tower, tower, tower, tower, tower, tower… ## $ subtype &lt;fct&gt; basePlot, basePlot, basePlot, basePlot, … ## $ plotLatitude &lt;dbl&gt; 45.76074, 45.76037, 45.76037, 45.76037, … ## $ plotLongitude &lt;dbl&gt; -122.3303, -122.3303, -122.3303, -122.33… ## $ datum &lt;fct&gt; WGS84, WGS84, WGS84, WGS84, WGS84, WGS84… ## $ utmZone &lt;fct&gt; 10N, 10N, 10N, 10N, 10N, 10N, 10N, 10N, … ## $ plotEasting &lt;dbl&gt; 552081.2, 552079.1, 552079.1, 552079.1, … ## $ plotNorthing &lt;dbl&gt; 5067683, 5067642, 5067642, 5067642, 5067… ## $ horzUncert &lt;dbl&gt; 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10… ## $ crdSource &lt;fct&gt; Geo 7X, Geo 7X, Geo 7X, Geo 7X, Geo 7X, … ## $ elevation &lt;dbl&gt; 363.22, 362.29, 362.29, 362.29, 362.34, … ## $ vertUncert &lt;dbl&gt; 0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10… ## $ nlcdClass &lt;fct&gt; evergreenForest, evergreenForest, evergr… ## $ appMods &lt;fct&gt; bbc|bgc|cdw|cfc|dhp|hbp|ltr|sme|vst, bbc… ## $ geometry &lt;fct&gt; &quot;c(-122.330278, 45.76074)&quot;, &quot;c(-122.3303… ## $ itcEasting &lt;dbl&gt; 552084.0, 552097.3, 552097.3, 552097.3, … ## $ itcNorthing &lt;dbl&gt; 5067682, 5067657, 5067657, 5067657, 5067… ## $ itcLongitude &lt;dbl&gt; -122.3302, -122.3301, -122.3301, -122.33… ## $ itcLatitude &lt;dbl&gt; 45.76073, 45.76051, 45.76051, 45.76051, … ## $ eventID &lt;fct&gt; vst_ABBY_2015, vst_ABBY_2016, vst_ABBY_2… ## $ tempShrubStemID &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ tagStatus &lt;fct&gt; NA, ok, ok, ok, NA, NA, ok, ok, ok, NA, … ## $ growthForm &lt;fct&gt; single bole tree, single bole tree, sing… ## $ plantStatus &lt;fct&gt; &quot;Standing dead&quot;, &quot;Standing dead&quot;, &quot;Dead,… ## $ stemDiameter &lt;dbl&gt; 40.0, 90.0, 89.1, 88.3, 105.0, 28.3, 29.… ## $ measurementHeight &lt;int&gt; 130, 130, 130, 130, 130, 130, 140, 130, … ## $ height &lt;dbl&gt; NA, 7.5, 6.7, 6.8, NA, NA, NA, 22.5, 21.… ## $ baseCrownHeight &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ breakHeight &lt;dbl&gt; NA, NA, NA, 6.8, NA, NA, NA, NA, NA, NA,… ## $ breakDiameter &lt;dbl&gt; NA, NA, 61, NA, NA, NA, NA, NA, NA, NA, … ## $ maxCrownDiameter &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ ninetyCrownDiameter &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ canopyPosition &lt;fct&gt; NA, , NA, NA, NA, NA, , NA, NA, NA, , NA… ## $ shape &lt;fct&gt; , , , , , , , , , , , , , , , , , , , , … ## $ basalStemDiameter &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ basalStemDiameterMsrmntHeight &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ maxBaseCrownDiameter &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ ninetyBaseCrownDiameter &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ area &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … Nice, there appears to be some useful data in here: uid, siteID, plotID, stemDiameter, height, maxCrownDiameter, ninetyCrownDiameter, baseCrownHeight, plantStatus, taxonID Also, I just found that there is a hidden function in the package to filter the field tree data …except for I’m going to change the minimum diameter from 15 cm to 10 cm clean_field_data&lt;-function(field){ field$area&lt;-field$maxCrownDiameter*field$ninetyCrownDiameter field&lt;-field %&gt;% filter(!is.na(itcEasting),!stringr::str_detect(eventID,&quot;2014&quot;),growthForm %in% c(&quot;single bole tree&quot;,&quot;multi-bole tree&quot;,&quot;small tree&quot;,&quot;sapling&quot;),stemDiameter&gt;10) %&gt;% droplevels() %&gt;% filter(height&gt;3|is.na(height)) #Limit difference in heights to_remove&lt;-field %&gt;% group_by(individualID) %&gt;% summarize(mean=mean(height),sum_difference = abs(sum(diff(height)))) %&gt;% filter(sum_difference &gt; 8) field&lt;-field %&gt;% filter(!individualID %in% to_remove$individualID) } clean this data and filter it # filter it field_trees &lt;- NeonTreeEvaluation::field %&gt;% clean_field_data() %&gt;% dplyr::select( uid, siteID, plotID, stemDiameter , height, maxCrownDiameter, ninetyCrownDiameter , baseCrownHeight, plantStatus, taxonID ) %&gt;% dplyr::filter(!is.na(maxCrownDiameter) &amp; !is.na(height)) %&gt;% dplyr::mutate(CrownRadius = maxCrownDiameter/2) # see it field_trees %&gt;% dplyr::glimpse() ## Rows: 6,878 ## Columns: 11 ## $ uid &lt;fct&gt; b4305401-a7d9-4e79-afc4-a7f0c82e98d3, 346b66a5-cd8… ## $ siteID &lt;fct&gt; ABBY, ABBY, ABBY, ABBY, ABBY, ABBY, ABBY, ABBY, AB… ## $ plotID &lt;fct&gt; ABBY_007, ABBY_007, ABBY_007, ABBY_007, ABBY_007, … ## $ stemDiameter &lt;dbl&gt; 68.2, 54.1, 54.7, 58.0, 68.1, 20.2, 15.6, 19.6, 18… ## $ height &lt;dbl&gt; 49.6, 13.1, 22.9, 35.6, 50.2, 19.0, 10.8, 12.5, 9.… ## $ maxCrownDiameter &lt;dbl&gt; 9.7, 3.2, 9.1, 9.5, 11.3, 8.6, 4.5, 4.7, 5.2, 4.3,… ## $ ninetyCrownDiameter &lt;dbl&gt; 8.5, 0.0, 7.8, 7.9, 6.7, 7.6, 4.2, 4.5, 4.8, 3.8, … ## $ baseCrownHeight &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ plantStatus &lt;fct&gt; &quot;Live&quot;, &quot;Dead, broken bole&quot;, &quot;Live&quot;, &quot;Live&quot;, &quot;Live… ## $ taxonID &lt;fct&gt; PSMEM, PSMEM, PSMEM, PSMEM, PSMEM, PSMEM, PSMEM, P… ## $ CrownRadius &lt;dbl&gt; 4.85, 1.60, 4.55, 4.75, 5.65, 4.30, 2.25, 2.35, 2.… what are these data? field_trees %&gt;% dplyr::select(dplyr::where(is.numeric)) %&gt;% summary() ## stemDiameter height maxCrownDiameter ninetyCrownDiameter ## Min. : 15.10 Min. : 3.10 Min. : 0.100 Min. : 0.000 ## 1st Qu.: 18.60 1st Qu.: 9.90 1st Qu.: 3.800 1st Qu.: 2.900 ## Median : 23.30 Median :13.30 Median : 6.200 Median : 4.700 ## Mean : 27.44 Mean :14.97 Mean : 6.975 Mean : 5.296 ## 3rd Qu.: 31.80 3rd Qu.:18.90 3rd Qu.: 9.200 3rd Qu.: 7.000 ## Max. :255.00 Max. :52.90 Max. :62.000 Max. :31.000 ## NA&#39;s :115 ## baseCrownHeight CrownRadius ## Min. : NA Min. : 0.050 ## 1st Qu.: NA 1st Qu.: 1.900 ## Median : NA Median : 3.100 ## Mean :NaN Mean : 3.487 ## 3rd Qu.: NA 3rd Qu.: 4.600 ## Max. : NA Max. :31.000 ## NA&#39;s :6878 status? field_trees %&gt;% dplyr::count(plantStatus) ## plantStatus n ## 1 Dead, broken bole 75 ## 2 Downed 2 ## 3 Live 5486 ## 4 Live, other damage 135 ## 5 Live, broken bole 43 ## 6 Live, disease damaged 199 ## 7 Live, insect damaged 157 ## 8 Live, physically damaged 154 ## 9 No longer qualifies 12 ## 10 Removed 1 ## 11 Standing dead 614 keep only live field_trees &lt;- field_trees %&gt;% dplyr::filter(plantStatus %&gt;% tolower() %&gt;% stringr::str_starts(&quot;live&quot;)) taxonID? field_trees %&gt;% dplyr::count(taxonID) %&gt;% dplyr::arrange(desc(n)) %&gt;% dplyr::slice_head(n = 20) ## taxonID n ## 1 PICOL 535 ## 2 PIEN 500 ## 3 ACRU 367 ## 4 ABLAL 333 ## 5 LITU 270 ## 6 QURU 267 ## 7 LIST2 238 ## 8 TSCA 211 ## 9 QUAL 197 ## 10 PIPA2 177 ## 11 ACSA3 137 ## 12 PIFL2 132 ## 13 OXYDE 117 ## 14 PSMEM 96 ## 15 PITA 95 ## 16 PSME 91 ## 17 CATO6 88 ## 18 PIMA 84 ## 19 POTR5 81 ## 20 JUNIP 80 let’s see the height versus diameter relationship field_trees %&gt;% ggplot(mapping = aes(x = height, y = stemDiameter)) + geom_point() + scale_x_continuous(limits = c(0,NA)) + scale_y_continuous(limits = c(0,NA)) + theme_light() let’s get conifer trees only??? ….sure, i found a NEON plant list with the codes: https://data.neonscience.org/taxonomic-lists?taxonTypeCode=PLANT conifer_spp &lt;- readr::read_csv( &quot;../data/OS_TAXON_PLANT-20220330T142149.csv&quot; , show_col_types = F , progress = F ) %&gt;% dplyr::filter( tolower(family) %in% c( &quot;pinaceae&quot;, &quot;podocarpaceae&quot;, &quot;araucariaceae&quot; , &quot;taxaceae&quot;, &quot;cephalotaxaceae&quot;, &quot;taxodiaceae&quot;, &quot;cupressaceae&quot; ) ) %&gt;% dplyr::mutate( taxonID = toupper(taxonID) , vernacularName = tolower(vernacularName) , genus = stringr::str_to_title(genus) ) %&gt;% dplyr::distinct(taxonID, vernacularName, genus) # huh? conifer_spp %&gt;% dplyr::slice_sample(n = 10) ## # A tibble: 10 × 3 ## taxonID vernacularName genus ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 CALLI7 cypress-pine Callitris ## 2 JUNIPSPP juniper Juniperus ## 3 PIST3 southwestern white pine Pinus ## 4 SEQUO2 giant sequoia Sequoiadendron ## 5 JUCO11 redberry juniper Juniperus ## 6 ABLAL subalpine fir Abies ## 7 TAXUSSPP yew Taxus ## 8 PODOCASPP &lt;NA&gt; &lt;NA&gt; ## 9 PLOR80 oriental arborvitae Platycladus ## 10 JUVIS southern redcedar Juniperus filter that field tree list for conifers conifer_trees &lt;- field_trees %&gt;% dplyr::inner_join(conifer_spp, by = &quot;taxonID&quot;) check those conifers height and diameter conifer_trees %&gt;% ggplot(mapping = aes(x = height, y = stemDiameter, color = genus)) + geom_point() + scale_x_continuous(limits = c(0,NA)) + scale_y_continuous(limits = c(0,NA)) + facet_wrap(facets = dplyr::vars(genus)) + scale_color_viridis_d(option = &quot;turbo&quot;) + theme_light() + theme(legend.position = &quot;none&quot;) what about this crown area data? conifer_trees %&gt;% ggplot(mapping = aes(x = CrownRadius, y = genus, fill = genus)) + geom_boxplot(width = 0.7, outliers = F) + scale_fill_viridis_d(option = &quot;turbo&quot;) + theme_light() + theme(legend.position = &quot;none&quot;) radius data # height conifer_trees$height %&gt;% quantile(probs = c(0.01,0.05,0.5,0.95,0.99)) ## 1% 5% 50% 95% 99% ## 3.500 5.600 11.500 25.210 41.753 # radius conifer_trees$CrownRadius %&gt;% quantile(probs = c(0.01,0.05,0.5,0.95,0.99)) ## 1% 5% 50% 95% 99% ## 0.8500 1.1000 2.0000 5.1000 6.6255 let’s model crown radius based on height lm(formula = CrownRadius ~ height, data = conifer_trees) %&gt;% broom::tidy() %&gt;% kableExtra::kbl(digits = 4) %&gt;% kableExtra::kable_styling() term estimate std.error statistic p.value (Intercept) 1.0900 0.0464 23.5090 0 height 0.1014 0.0032 31.7895 0 plot this conifer_trees %&gt;% ggplot(mapping = aes(x = height, y = CrownRadius)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + scale_x_continuous(limits = c(0,NA)) + scale_y_continuous(limits = c(0,NA)) + theme_light() + theme(legend.position = &quot;none&quot;) what about a non-linear model? crown_height_model &lt;- brms::brm( formula = brms::bf( formula = CrownRadius ~ (b1 * height) + height^b2 , b1 + b2 ~ 1 , nl = TRUE # !! specify non-linear ) , data = conifer_trees , family = brms::brmsfamily(&quot;Gamma&quot;) , iter = 6000, warmup = 3000, chains = 4 , cores = lasR::half_cores() , file = &quot;../data/crown_height_model&quot; ) # plot(crown_height_model) summary(crown_height_model) ## Family: gamma ## Links: mu = log; shape = identity ## Formula: CrownRadius ~ (b1 * height) + height^b2 ## b1 ~ 1 ## b2 ~ 1 ## Data: conifer_trees (Number of observations: 2750) ## Draws: 4 chains, each with iter = 6000; warmup = 3000; thin = 1; ## total post-warmup draws = 12000 ## ## Regression Coefficients: ## Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS ## b1_Intercept 0.04 0.00 0.04 0.05 1.00 5784 6848 ## b2_Intercept -0.55 0.03 -0.61 -0.51 1.00 5397 5756 ## ## Further Distributional Parameters: ## Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS ## shape 5.72 0.15 5.43 6.02 1.00 6131 5494 ## ## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS ## and Tail_ESS are effective sample size measures, and Rhat is the potential ## scale reduction factor on split chains (at convergence, Rhat = 1). ## write out model estimates to tabular file #### extract posterior draws to a df brms::as_draws_df( crown_height_model , variable = c(&quot;^b_&quot;, &quot;shape&quot;) , regex = TRUE ) %&gt;% # quick way to get a table of summary statistics and diagnostics posterior::summarize_draws( &quot;mean&quot;, &quot;median&quot;, &quot;sd&quot; , ~quantile(.x, probs = c( 0.05, 0.95 , 0.025, 0.975 )) , &quot;rhat&quot; ) %&gt;% dplyr::mutate( variable = stringr::str_remove_all(variable, &quot;_Intercept&quot;) , formula = summary(crown_height_model)$formula %&gt;% as.character() %&gt;% .[1] ) %&gt;% write.csv( &quot;../data/crown_height_model.csv&quot; , row.names = F ) plot this plot(brms::conditional_effects(crown_height_model), points = T) what if we try to plot it with a function using the regression coefficients? ws_fn &lt;- function(x) { y = dplyr::case_when( is.na(x) ~ 1e-3 # requires non-null , x &lt; 0 ~ 1e-3 # requires positive , x &lt; 2.5 ~ 1 # set lower bound , x &gt; 40 ~ 6.7 # set upper bound # , TRUE ~ 0.75 + (x * 0.14) , TRUE ~ exp( (0.0446*x) + (x^-0.555) ) # used gamma regression so exp the result ) return(y) } plot it ggplot2::ggplot() + ggplot2::xlim(0,60) + ggplot2::ylim(0,NA) + ggplot2::geom_point(data = conifer_trees, mapping = aes(y = CrownRadius, x = height)) + ggplot2::geom_function(fun = ws_fn, lwd = 1.5, color = &quot;blue&quot;) NeonTreeEvaluation::get_data is a set of utility functions for finding the path of benchmark data on disk NeonTreeEvaluation::get_data(plot_name = &quot;RMNP_047&quot;, type = &quot;lidar&quot;) ## [1] &quot;C:/Program Files/R/R-4.3.0/library/NeonTreeEvaluation/extdata/NeonTreeEvaluation/evaluation/LiDAR/RMNP_047.laz&quot; let’s pull out all sites with .laz data and create a data frame for tracking purposes las_df &lt;- paste0(system.file(package = &quot;NeonTreeEvaluation&quot;),&quot;/extdata/&quot;) %&gt;% list.files(recursive = T, pattern = &quot;.*\\\\.(laz|las)$&quot;, full.names = T) %&gt;% unique() %&gt;% dplyr::as_tibble() %&gt;% dplyr::rename(f_path = 1) %&gt;% # create some other variables dplyr::mutate( f_nm = f_path %&gt;% basename() %&gt;% stringr::str_remove_all(&quot;\\\\.(laz|las)$&quot;) , plot_nm = f_nm %&gt;% # this matches the file name with the plot name toupper() %&gt;% stringr::str_extract( pattern = NeonTreeEvaluation::list_field_stems() %&gt;% toupper() %&gt;% paste(collapse = &quot;|&quot;) ) , neon_site = plot_nm %&gt;% stringr::word(start = 1, sep = fixed(&quot;_&quot;)) ) %&gt;% dplyr::filter(!is.na(plot_nm)) %&gt;% # keep only las files with field stems dplyr::select(neon_site, plot_nm, f_nm, f_path) # what? las_df %&gt;% dplyr::glimpse() ## Rows: 278 ## Columns: 4 ## $ neon_site &lt;chr&gt; &quot;ABBY&quot;, &quot;ABBY&quot;, &quot;ABBY&quot;, &quot;ABBY&quot;, &quot;ABBY&quot;, &quot;BART&quot;, &quot;BART&quot;, &quot;BAR… ## $ plot_nm &lt;chr&gt; &quot;ABBY_003&quot;, &quot;ABBY_008&quot;, &quot;ABBY_010&quot;, &quot;ABBY_023&quot;, &quot;ABBY_068&quot;, … ## $ f_nm &lt;chr&gt; &quot;ABBY_003_2018&quot;, &quot;ABBY_008_2018&quot;, &quot;ABBY_010_2018&quot;, &quot;ABBY_023… ## $ f_path &lt;chr&gt; &quot;C:/Program Files/R/R-4.3.0/library/NeonTreeEvaluation/extda… 2.1.1 Explore LiDAR data from package which NEON sites have data? las_df %&gt;% dplyr::count(neon_site) %&gt;% dplyr::arrange(desc(n)) %&gt;% dplyr::mutate(neon_site = forcats::fct_reorder(neon_site, n)) %&gt;% # plot ggplot(aes(y = neon_site, x = n, fill = n)) + geom_col(width = 0.7) + labs(y = &quot;NEON site&quot;, x = &quot;lidar data plots&quot;) + harrypotter::scale_fill_hp(&quot;slytherin&quot;) + theme_light() + theme(legend.position = &quot;none&quot;) where is this data? get_site_bbox &lt;- function(site, dta = las_df) { # read the las files for a site las_ctg = dta %&gt;% dplyr::filter(neon_site == site) %&gt;% dplyr::pull(f_path) %&gt;% lidR::readLAScatalog() # bbox that site if( is.na( sf::st_crs(las_ctg@data) ) ){ return(NULL) }else{ las_ctg@data %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% sf::st_as_sf() %&gt;% dplyr::mutate(neon_site = site) %&gt;% sf::st_set_crs(sf::st_crs(las_ctg@data)) %&gt;% sf::st_transform(crs = paste0(&quot;EPSG:&quot;, 5070)) } } # take this for a spin las_df %&gt;% dplyr::pull(neon_site) %&gt;% unique() %&gt;% purrr::map(get_site_bbox) %&gt;% dplyr::bind_rows() %&gt;% dplyr::left_join( las_df %&gt;% dplyr::group_by(neon_site) %&gt;% dplyr::summarise(n = dplyr::n()) , by = &quot;neon_site&quot; ) %&gt;% st_centroid() %&gt;% mapview::mapview( zcol = &quot;n&quot; , layer.name = &quot;LiDAR plots&quot; , label = c(&quot;neon_site&quot;) , col.regions = viridis::mako(10, direction = -1) ) load one las data f_temp = las_df %&gt;% dplyr::slice_sample(n = 1) %&gt;% dplyr::pull(f_path) las_temp = lidR::readLAS(f_temp) # quick summary las_temp ## class : LAS (v1.3 format 1) ## memory : 2.1 Mb ## extent : 548886.1, 548926.1, 5067779, 5067819 (xmin, xmax, ymin, ymax) ## coord. ref. : WGS 84 / UTM zone 10N ## area : 1676 m² ## points : 37 thousand points ## density : 22.09 points/m² ## density : 10.84 pulses/m² # data str las_temp@data %&gt;% dplyr::glimpse() ## Rows: 37,024 ## Columns: 16 ## $ X &lt;dbl&gt; 548918.8, 548918.9, 548918.9, 548919.2, 548919.6, 54… ## $ Y &lt;dbl&gt; 5067779, 5067779, 5067779, 5067779, 5067779, 5067779… ## $ Z &lt;dbl&gt; 609.094, 609.858, 610.850, 610.012, 608.328, 612.242… ## $ gpstime &lt;dbl&gt; 585009.2, 585009.2, 585009.2, 585009.2, 585009.2, 58… ## $ Intensity &lt;int&gt; 65, 269, 67, 165, 42, 170, 83, 25, 206, 222, 51, 167… ## $ ReturnNumber &lt;int&gt; 5, 1, 1, 2, 3, 1, 2, 1, 2, 1, 1, 2, 1, 1, 2, 1, 2, 1… ## $ NumberOfReturns &lt;int&gt; 5, 1, 3, 3, 3, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 4… ## $ ScanDirectionFlag &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ EdgeOfFlightline &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ Classification &lt;int&gt; 5, 5, 5, 5, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5… ## $ Synthetic_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ Keypoint_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ Withheld_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ ScanAngleRank &lt;int&gt; -16, -16, -16, -16, -16, -16, -16, -16, -16, -16, -1… ## $ UserData &lt;int&gt; 24, 32, 42, 33, 17, 55, 44, 66, 53, 55, 74, 64, 69, … ## $ PointSourceID &lt;int&gt; 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8… summarize x, y, z las_temp@data %&gt;% dplyr::select(X,Y,Z) %&gt;% summary() ## X Y Z ## Min. :548886 Min. :5067779 Min. :598.6 ## 1st Qu.:548896 1st Qu.:5067789 1st Qu.:605.2 ## Median :548906 Median :5067798 Median :607.4 ## Mean :548906 Mean :5067799 Mean :607.5 ## 3rd Qu.:548916 3rd Qu.:5067809 3rd Qu.:609.8 ## Max. :548926 Max. :5067819 Max. :649.6 plot this las plot3D::scatter3D( x = las_temp@data$X , y = las_temp@data$Y , z = las_temp@data$Z , colvar = las_temp@data$Z , pch = 19, cex = 0.3 , colkey = F , phi = 0.5 ) let’s look at the classification (see table 5 here) las_temp@data %&gt;% dplyr::count(Classification) ## Classification n ## &lt;int&gt; &lt;int&gt; ## 1: 1 6577 ## 2: 2 1786 ## 3: 5 28660 ## 4: 7 1 plot color by classification plot3D::scatter3D( x = las_temp@data$X , y = las_temp@data$Y , z = las_temp@data$Z , colvar = las_temp@data$Classification , pch = 19, cex = 0.3 , colkey = F , phi = 0.5 ) 2.2 cloud2trees The cloud2trees package provides routines for processing point cloud data (.las|.laz format) to detect forest trees. let’s use it for one of the data sets from a conifer forest in the NeonTreeEvaluation benchmark # get one file (f_temp &lt;- las_df %&gt;% dplyr::filter(neon_site==&quot;RMNP&quot;) %&gt;% # rocky mtn national park dplyr::slice_sample(n = 1) %&gt;% dplyr::pull(f_path)) ## [1] &quot;C:/Program Files/R/R-4.3.0/library/NeonTreeEvaluation/extdata/NeonTreeEvaluation/evaluation/LiDAR/RMNP_003_2018.laz&quot; # read in the data las_temp &lt;- lidR::readLAS(f_temp) what is this data? las_temp@data %&gt;% dplyr::glimpse() ## Rows: 49,205 ## Columns: 16 ## $ X &lt;dbl&gt; 458837.0, 458837.2, 458837.6, 458836.8, 458837.2, 45… ## $ Y &lt;dbl&gt; 4450227, 4450227, 4450227, 4450227, 4450227, 4450227… ## $ Z &lt;dbl&gt; 2626.882, 2626.091, 2624.778, 2626.132, 2624.461, 26… ## $ gpstime &lt;dbl&gt; 425181.4, 425181.4, 425181.4, 425181.4, 425181.4, 42… ## $ Intensity &lt;int&gt; 61, 57, 35, 80, 37, 86, 9, 124, 51, 20, 39, 140, 43,… ## $ ReturnNumber &lt;int&gt; 1, 2, 3, 1, 2, 1, 2, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 2… ## $ NumberOfReturns &lt;int&gt; 3, 3, 3, 2, 2, 2, 2, 1, 3, 3, 3, 1, 2, 2, 2, 2, 2, 2… ## $ ScanDirectionFlag &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ EdgeOfFlightline &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ Classification &lt;int&gt; 5, 5, 5, 5, 5, 5, 2, 5, 5, 1, 2, 2, 5, 2, 5, 5, 5, 2… ## $ Synthetic_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ Keypoint_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ Withheld_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ ScanAngleRank &lt;int&gt; 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, … ## $ UserData &lt;int&gt; 93, 84, 70, 86, 68, 61, 0, 61, 60, 19, 0, 0, 76, 0, … ## $ PointSourceID &lt;int&gt; 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, … We can plot the point cloud with and color by the point height lidR::plot( las_temp , color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;, legend = T , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) notice the Z values are in meters above sea level 2.2.1 Get tree list and normalized cloud We’ll use the cloud2trees::cloud2trees() function to get a tree list from the lidar data with a regional estimate of the DBH because we enabled the estimate_tree_dbh parameter. Also returned is a canopy height model (CHM) raster and because we enabled the keep_intrmdt parameter we’ll get the normalized point cloud data as well. cloud2trees_ans &lt;- cloud2trees::cloud2trees( input_las_dir = f_temp , output_dir = &quot;../data&quot; , estimate_tree_dbh = T , keep_intrmdt = T ) let’s see what we got names(cloud2trees_ans) ## [1] &quot;crowns_sf&quot; &quot;treetops_sf&quot; &quot;dtm_rast&quot; &quot;chm_rast&quot; we got a CHM # could make an easy plot with... # terra::plot(cloud2trees_ans$chm_rast) # ...but we&#39;ll customize and save it as our base plot plt_chm &lt;- ggplot() + geom_tile( data = cloud2trees_ans$chm_rast %&gt;% as.data.frame(xy=T) %&gt;% dplyr::rename(f=3) , mapping = aes(x=x,y=y,fill=f) ) + harrypotter::scale_fill_hp(&quot;gryffindor&quot;, name = &quot;height (m)&quot;) + theme_light() + theme( axis.text = element_blank() ) # view plt_chm we also got tree top points plt_chm + geom_sf(data = cloud2trees_ans$treetops_sf, color = &quot;blue&quot;) and we got tree crowns plt_chm + geom_sf(data = cloud2trees_ans$treetops_sf, color = &quot;blue&quot;) + geom_sf(data = cloud2trees_ans$crowns_sf, fill = NA, color = &quot;steelblue&quot;) there is data on the individual trees in the crowns and tree tops data (which are the same data but one spaltial polygons and the other is spatial points). cloud2trees_ans$crowns_sf %&gt;% dplyr::glimpse() ## Rows: 229 ## Columns: 20 ## $ treeID &lt;chr&gt; &quot;1_458833.4_4450240.6&quot;, &quot;2_458858.1_4450240.… ## $ tree_height_m &lt;dbl&gt; 11.030, 8.124, 7.659, 8.306, 7.471, 9.758, 5… ## $ tree_x &lt;dbl&gt; 458833.4, 458858.1, 458839.6, 458854.6, 4588… ## $ tree_y &lt;dbl&gt; 4450241, 4450241, 4450240, 4450240, 4450240,… ## $ crown_area_m2 &lt;dbl&gt; 6.5000, 1.6250, 1.3125, 1.3750, 4.3750, 2.81… ## $ geometry &lt;GEOMETRY [m]&gt; POLYGON ((458832 4450241, 4..., POL… ## $ fia_est_dbh_cm &lt;dbl&gt; 16.343596, 11.664241, 11.025794, 12.016107, … ## $ fia_est_dbh_cm_lower &lt;dbl&gt; 9.274637, 6.556701, 6.186752, 6.789626, 6.06… ## $ fia_est_dbh_cm_upper &lt;dbl&gt; 25.114865, 18.022694, 16.908300, 18.607822, … ## $ dbh_cm &lt;dbl&gt; 16.343596, 11.664241, 11.025794, 12.016107, … ## $ is_training_data &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA… ## $ dbh_m &lt;dbl&gt; 0.16343596, 0.11664241, 0.11025794, 0.120161… ## $ radius_m &lt;dbl&gt; 0.08171798, 0.05832120, 0.05512897, 0.060080… ## $ basal_area_m2 &lt;dbl&gt; 0.020979016, 0.010685697, 0.009547939, 0.011… ## $ basal_area_ft2 &lt;dbl&gt; 0.22581813, 0.11502084, 0.10277402, 0.122064… ## $ ptcld_extracted_dbh_cm &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ ptcld_predicted_dbh_cm &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ comp_trees_per_ha &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ comp_relative_tree_height &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ comp_dist_to_nearest_m &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … let’s check the height to DBH relationship cloud2trees_ans$crowns_sf %&gt;% ggplot(mapping = aes(x = tree_height_m, y = dbh_cm)) + geom_point(color = &quot;navy&quot;) + labs(x = &quot;height (m)&quot;, y = &quot;DBH (cm)&quot;) + theme_light() this all looks great. let’s check the normalized point cloud. for that we’ll dig in the output directory from the cloud2trees::cloud2trees() function (see that output_dir parameter). (n_f_temp &lt;- list.files( &quot;../data/point_cloud_processing_temp/02_normalize/&quot; , pattern = &quot;.las&quot; , full.names = T )) ## [1] &quot;../data/point_cloud_processing_temp/02_normalize/RMNP_003_2018_normalize.las&quot; # read in the data nlas_temp &lt;- lidR::readLAS(n_f_temp) plot it to check that it is height normalized lidR::plot( nlas_temp , color = &quot;Z&quot;, bg = &quot;white&quot;, legend = T , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) nice! let’s remove the ground points to check out potential vegetation nlas_temp %&gt;% lidR::filter_poi(Classification!=2) %&gt;% lidR::plot( color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;, legend = T , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) that’s a great workflow, guy. i’m not your guy, buddy. 2.3 LadderFuelsR The LadderFuelsR package (Viedma et al. 2024) is described as enabling the use of “LiDAR data and the LadderFuelsR package…[to] provide an automated tool for analysing the vertical fuel structure of a forest and to calculate crown base height (CBH) at tree-level, among other parameters” (p.1). let’s check what’s in this package lsf.str(&quot;package:LadderFuelsR&quot;) ## calculate_gaps_perc : function (LAD_profiles, min_height = 1.5) ## get_cbh_metrics : function (effective_LAD, min_height = 1.5, hdepth1_height = 2.5, verbose = TRUE) ## get_cum_break : function (LAD_profiles, cbh_metrics, threshold = 75, min_height = 1.5, ## verbose = TRUE) ## get_depths : function (LAD_profiles, distance_metrics, step = 1, min_height = 1.5, verbose = TRUE) ## get_distance : function (gap_cbh_metrics, gaps_perc, step = 1, min_height = 1.5, verbose = TRUE) ## get_effective_gap : function (effective_depth, number_steps = 1, min_height = 1.5, verbose = TRUE) ## get_gaps_fbhs : function (LAD_profiles, step = 1, min_height = 1.5, perc_gap = 25, perc_base = 25, ## verbose = TRUE) ## get_layers_lad : function (LAD_profiles, effective_distances, threshold = 10, step = 1, ## min_height = 1.5, verbose = TRUE) ## get_plots_cbh_bp : function (LAD_profiles, cummulative_LAD, min_height = 1.5) ## get_plots_cbh_LAD : function (LAD_profiles, cbh_metrics, min_height = 1.5) ## get_plots_cbh_lastdist : function (LAD_profiles, cbh_metrics, min_height = 1.5) ## get_plots_cbh_maxdist : function (LAD_profiles, cbh_metrics, min_height = 1.5) ## get_plots_effective : function (LAD_profiles, effective_LAD, min_height = 1.5) ## get_plots_gap_fbh : function (LAD_profiles, gap_cbh_metrics, min_height = 1.5) ## get_real_depths : function (effective_fbh, step = 1, min_height = 1.5, verbose = TRUE) ## get_real_fbh : function (depth_metrics, step = 1, number_steps = 1, min_height = 1.5, ## verbose = TRUE) ## get_renamed_df : function (df) ## get_renamed0_df : function (df) 2.3.1 Prep for the package For this package we need to do some cleaning of our las data and our polygon crown data. We need to attach the treeID column from our spatial crowns to the las data using lidR::merge_spatial(). This function allows for only polygons so we need to get rid of the multipolygons in the crown data. We’ll keep the largest part of the multipolygon as the smaller part is usually a residual pixel from the CHM. We also generate a tree_index as a numeric id which is needed by the LadderFuelsR package since treeID is character. # the lidR::merge_spatial requires only polygons so we need to rid the multipolygons crowns_sf_poly &lt;- # start with only polygons cloud2trees_ans$crowns_sf %&gt;% dplyr::filter(sf::st_geometry_type(geometry)==&quot;POLYGON&quot;) %&gt;% # union on cleaned multipolygons dplyr::bind_rows( cloud2trees_ans$crowns_sf %&gt;% dplyr::filter(sf::st_geometry_type(geometry)==&quot;MULTIPOLYGON&quot;) %&gt;% sf::st_cast(to = &quot;POLYGON&quot;, do_split = T, warn = F) %&gt;% dplyr::mutate(axxx = sf::st_area(geometry)) %&gt;% # axxx is so we don&#39;t overwrite a column dplyr::group_by(treeID) %&gt;% dplyr::filter(axxx == max(axxx)) %&gt;% # keep the biggest crown polygon by treeID dplyr::ungroup() %&gt;% dplyr::select(-axxx) ) %&gt;% # generate a treeID index because it needs to be numeric dplyr::ungroup() %&gt;% dplyr::mutate(tree_index = dplyr::row_number()) does it look good? plt_chm + geom_sf(data = cloud2trees_ans$treetops_sf, color = &quot;blue&quot;) + geom_sf(data = crowns_sf_poly, fill = NA, color = &quot;steelblue&quot;) now we’ll attach the treeID column to the normalized las file and keep only the points that fall within a tree crown. crowns_nlas_temp &lt;- lidR::merge_spatial( las = nlas_temp , source = crowns_sf_poly , attribute = &quot;tree_index&quot; ) %&gt;% lidR::filter_poi(!is.na(tree_index)) %&gt;% lidR::filter_poi(Classification!=2) # what is this data? crowns_nlas_temp@data %&gt;% dplyr::glimpse() ## Rows: 20,961 ## Columns: 17 ## $ X &lt;dbl&gt; 458837.0, 458837.2, 458837.6, 458836.8, 458837.2, 45… ## $ Y &lt;dbl&gt; 4450227, 4450227, 4450227, 4450227, 4450227, 4450227… ## $ Z &lt;dbl&gt; 9.254, 8.415, 7.014, 8.580, 6.823, 6.078, 6.127, 5.9… ## $ gpstime &lt;dbl&gt; 425181.4, 425181.4, 425181.4, 425181.4, 425181.4, 42… ## $ Intensity &lt;int&gt; 61, 57, 35, 80, 37, 86, 124, 51, 20, 43, 119, 49, 75… ## $ ReturnNumber &lt;int&gt; 1, 2, 3, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 2, 3, 4… ## $ NumberOfReturns &lt;int&gt; 3, 3, 3, 2, 2, 2, 1, 3, 3, 2, 2, 2, 2, 1, 5, 5, 5, 5… ## $ ScanDirectionFlag &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ EdgeOfFlightline &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ Classification &lt;int&gt; 5, 5, 5, 5, 5, 5, 5, 5, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5… ## $ Synthetic_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ Keypoint_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ Withheld_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ ScanAngleRank &lt;int&gt; 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, … ## $ UserData &lt;int&gt; 93, 84, 70, 86, 68, 61, 61, 60, 19, 76, 86, 76, 75, … ## $ PointSourceID &lt;int&gt; 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, … ## $ tree_index &lt;int&gt; 56, 56, 56, 56, 56, 56, 56, 56, 56, 60, 59, 59, 59, … plot the las data colored by tree_index crowns_nlas_temp %&gt;% lidR::plot( color = &quot;tree_index&quot;, bg = &quot;white&quot;, legend = F , pal = viridis::turbo( n = crowns_nlas_temp@data$tree_index %&gt;% # this whole thing gets n unique colors unique() %&gt;% length() %&gt;% `*`(2) # with some separation between the hues ) %&gt;% sample( crowns_nlas_temp@data$tree_index %&gt;% unique() %&gt;% length() ) ) check it for one tree crowns_nlas_temp %&gt;% lidR::filter_poi( tree_index == # get the tree with the most points crowns_nlas_temp@data %&gt;% dplyr::count(tree_index) %&gt;% dplyr::filter(n == max(n)) %&gt;% dplyr::slice_head(n=1) %&gt;% dplyr::pull(tree_index) ) %&gt;% lidR::plot(color = &quot;tree_index&quot;, bg = &quot;white&quot;, legend = F) interesting, with more dense point clouds this would look more like a tree 2.3.2 Defining function for computing crown-level metrics Not sure how necessary this is, but pulling it from the package README notice, none of these functions utilize the intensity, or “i”, parameter custom_crown_metrics &lt;- function(z, i) { # user-defined function metrics &lt;- list( dz = 1, th = 1, z_max = max(z),# max height z_min = min(z),# min height z_mean = mean(z),# mean height z_sd = sd(z), # vertical variability of points z_q1=quantile(z, probs = 0.01), z_q5=quantile(z, probs = 0.05), z_q25=quantile(z, probs = 0.25), z_q50=quantile(z, probs = 0.50), z_q75=quantile(z, probs = 0.75), z_q95=quantile(z, probs = 0.95), crr=(mean(z)-min(z))/(max(z)-min(z)) ) return(metrics) # output } # idk why they did this...just for shorthand? just define it like that from the start # ccm = ~custom_crown_metrics(z = Z, i = Intensity) 2.3.3 Computing crown level standard metrics within all trees detected let’s see how they do it from the package README first, calculate metrics from the las data by tree (with code updates by gw) # setting a minimum Z height to look at crown metrics fcrowns_nlas_temp &lt;- lidR::filter_poi(crowns_nlas_temp, Z &gt;= 1) # Metric derivation at different levels of regularization crowns_metrics_df &lt;- # gw updated this to do it all at once lidR::crown_metrics( las = fcrowns_nlas_temp , func = .stdtreemetrics # stdtreemetrics is a lidR predefined function for tree-based metrics , geom = &quot;convex&quot; # Geometry type of the output , attribute = &quot;tree_index&quot; ) %&gt;% dplyr::left_join( lidR::crown_metrics( las = fcrowns_nlas_temp , func = ~ custom_crown_metrics(z = Z) # the custom function defined above , geom = &quot;convex&quot; # Geometry type of the output , attribute = &quot;tree_index&quot; ) %&gt;% sf::st_drop_geometry() , by = &quot;tree_index&quot; ) %&gt;% # define crown diameter dplyr::mutate( crown_diam = sqrt(convhull_area/ pi) * 2 ) # a df, ok crowns_metrics_df %&gt;% dplyr::glimpse() ## Rows: 225 ## Columns: 19 ## $ tree_index &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1… ## $ Z &lt;dbl&gt; 11.655, 8.379, 9.148, 8.524, 9.758, 6.065, 3.821, 9.723,… ## $ npoints &lt;int&gt; 206, 58, 57, 31, 89, 12, 6, 78, 272, 12, 4, 236, 15, 191… ## $ convhull_area &lt;dbl&gt; 6.093, 1.682, 0.936, 0.942, 2.463, 0.311, 0.101, 2.789, … ## $ dz &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,… ## $ th &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,… ## $ z_max &lt;dbl&gt; 11.655, 8.379, 9.148, 8.524, 9.758, 6.065, 3.821, 9.723,… ## $ z_min &lt;dbl&gt; 1.023, 1.072, 1.571, 4.280, 1.433, 3.767, 3.540, 1.237, … ## $ z_mean &lt;dbl&gt; 5.690553, 5.766638, 5.693877, 6.851968, 6.887000, 5.4214… ## $ z_sd &lt;dbl&gt; 2.4930970, 1.8853461, 1.9310041, 1.1368037, 2.2181626, 0… ## $ z_q1 &lt;dbl&gt; 1.19515, 1.37524, 1.57492, 4.33160, 1.46556, 3.80165, 3.… ## $ z_q5 &lt;dbl&gt; 2.05200, 1.93175, 2.70300, 4.55900, 3.00000, 3.94025, 3.… ## $ z_q25 &lt;dbl&gt; 3.85125, 4.74875, 4.06900, 6.33800, 5.51400, 5.46575, 3.… ## $ z_q50 &lt;dbl&gt; 5.4415, 5.8730, 6.2990, 6.6910, 7.2820, 5.6935, 3.6625, … ## $ z_q75 &lt;dbl&gt; 7.10400, 7.24025, 7.02000, 7.82850, 8.72400, 5.81725, 3.… ## $ z_q95 &lt;dbl&gt; 10.46950, 8.26115, 8.72020, 8.32450, 9.62420, 5.99515, 3… ## $ crr &lt;dbl&gt; 0.4390099, 0.6424850, 0.5441306, 0.6060244, 0.6551351, 0… ## $ geometry &lt;POLYGON [m]&gt; POLYGON ((458835 4450239, 4..., POLYGON ((458858… ## $ crown_diam &lt;dbl&gt; 2.7852915, 1.4634169, 1.0916740, 1.0951674, 1.7708724, 0… what “tree-based metrics” come from the .stdtreemetrics? maybe maximum Z, number of points, and crown area…not sure how useful these are for defining CBH. we shall see. the “z_” metrics are neat. does every crown have some crown metrics? # has the same number of trees as our crown polygons? dplyr::tibble( crowns_sf_poly_trees = nrow(crowns_sf_poly) , crowns_nlas_trees = fcrowns_nlas_temp@data$tree_index %&gt;% unique() %&gt;% length() , crowns_metrics_df_trees = nrow(crowns_metrics_df) ) %&gt;% kableExtra::kbl() %&gt;% kableExtra::kable_styling() crowns_sf_poly_trees crowns_nlas_trees crowns_metrics_df_trees 229 229 225 guess not. let’s look at some of those metrics and the convex hull polygons created by the lidR::crown_metrics() plt_chm + ggnewscale::new_scale_fill() + geom_sf(data = crowns_metrics_df, mapping = aes(fill = z_mean), color = &quot;steelblue&quot;) + harrypotter::scale_fill_hp(&quot;always&quot;, alpha = 0.8) note the overlap of those polygons. what if we attach the crown metrics to the original crown polygons? plt_chm + ggnewscale::new_scale_fill() + geom_sf( data = crowns_sf_poly %&gt;% dplyr::left_join( crowns_metrics_df %&gt;% sf::st_drop_geometry() , by = &quot;tree_index&quot; ) , mapping = aes(fill = z_mean), color = &quot;steelblue&quot; ) + harrypotter::scale_fill_hp(&quot;always&quot;, alpha = 0.8, na.value = &quot;black&quot;) what is this crr=(mean(z)-min(z))/(max(z)-min(z)) variable? plt_chm + ggnewscale::new_scale_fill() + geom_sf(data = crowns_metrics_df, mapping = aes(fill = crr), color = &quot;steelblue&quot;) + harrypotter::scale_fill_hp(&quot;always&quot;, alpha = 0.8) how about crown diameter? plt_chm + ggnewscale::new_scale_fill() + geom_sf(data = crowns_metrics_df, mapping = aes(fill = crown_diam), color = &quot;steelblue&quot;) + harrypotter::scale_fill_hp(&quot;always&quot;, alpha = 0.8) 2.3.4 LAI-LAD metrics by Trees see this section of the package README after height normalization and crown segmentation, the LiDAR returns were cropped with the crown contours being voxelized to obtain VHPs from which the absolute mean LAD at each height bin was retrieved (Viedma et al. 2024, p.2). in this section, the las files cropped to individual trees (i.e. one tree at a time) are passed to the leafR package to calculate the LAI-LAD metrics. it seems very inefficient to perform this one-by-one for individual tree point clouds and not something that would work well if many, many trees. let’s go through the process for one tree point cloud # leafR::lad.voxels requires a file location :\\ fn &lt;- paste0(tempdir(), &quot;/temp.las&quot;) # let&#39;s sample the tree with the most points ti &lt;- crowns_nlas_temp@data %&gt;% dplyr::count(tree_index) %&gt;% dplyr::arrange(desc(n)) %&gt;% dplyr::slice_head(n=1) %&gt;% dplyr::pull(tree_index) f &lt;- crowns_nlas_temp %&gt;% lidR::filter_poi(tree_index == ti) %&gt;% # put this in a function and map over trees lidR::writeLAS(file = fn) 2.3.4.1 leafR::lad.voxels Creates a data frame of the 3D voxels information (xyz) with Leaf Area Density values from las file. ##### leafR::lad.voxels # Creates a data frame of the 3D voxels information (xyz) with Leaf Area Density values from las file lad_voxels &lt;- leafR::lad.voxels( # normlas.file requires a file location :\\ normlas.file = f , grain.size = 2 ) class(lad_voxels) ## [1] &quot;list&quot; str(lad_voxels) ## List of 2 ## $ LAD : num [1:12, 1:11] NA 0 0.0333 0 NA ... ## $ coordenates:&#39;data.frame&#39;: 12 obs. of 2 variables: ## ..$ X: num [1:12] 458836 458838 458840 458842 458836 ... ## ..$ Y: num [1:12] 4450232 4450232 4450232 4450232 4450230 ... 2.3.4.2 leafR::lad.profile This function calculate the lad profile from the input lad.voxels. By “profile” I think they mean “vertical height profile” ##### leafR::lad.profile # This function calculate the lad profile from the input lad.voxels lad_profile &lt;- leafR::lad.profile(lad_voxels, relative = F) class(lad_profile) ## [1] &quot;data.frame&quot; str(lad_profile) ## &#39;data.frame&#39;: 11 obs. of 2 variables: ## $ height: num 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 10.5 ... ## $ lad : num 0.693 0.732 0.91 0.789 0.622 ... 2.3.4.3 leafR::lai calculates the lead area index (LAI) lai_tot &lt;- leafR::lai(lad_profile) lai_understory &lt;- leafR::lai(lad_profile, min = 0.3, max = 2.5) class(lai_tot) ## [1] &quot;numeric&quot; str(lai_tot) ## num 4.73 str(lai_understory) ## num 1.43 2.3.4.4 leafR::LAHV Calculates the leaf area height volume (LAHV) metric as described in Almeida et al. (2019) lahv_metric &lt;- leafR::LAHV(lad_profile, LAI.weighting = FALSE, height.weighting = FALSE) class(lahv_metric) ## [1] &quot;numeric&quot; str(lahv_metric) ## num 20.6 2.3.4.5 Bring together and clean they call this “Depurating Tree LAD profiles” replace missing LAD values with 0.01 (no explanation of “why”) keep only trees where there are at least 6 profile (vertical height profile) records (&gt;5) leafr_df &lt;- dplyr::tibble( tree_index = ti # put this in a function and map over trees ) %&gt;% dplyr::bind_cols(lad_profile) %&gt;% dplyr::mutate( lad = dplyr::coalesce(lad, 0.01) # not sure why they put in 0.01 here , lai_tot = lai_tot[1] , lai_understory = lai_understory[1] , lahv = lahv_metric[1] , vhp_n = dplyr::n() # they keep trees where there are at least 6 (&gt;5) ) %&gt;% dplyr::arrange(tree_index, height) what is this? leafr_df %&gt;% dplyr::glimpse() ## Rows: 11 ## Columns: 7 ## $ tree_index &lt;int&gt; 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203 ## $ height &lt;dbl&gt; 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5 ## $ lad &lt;dbl&gt; 0.693147181, 0.732408192, 0.910126467, 0.789234597, 0.6… ## $ lai_tot &lt;dbl&gt; 4.725788, 4.725788, 4.725788, 4.725788, 4.725788, 4.725… ## $ lai_understory &lt;dbl&gt; 1.425555, 1.425555, 1.425555, 1.425555, 1.425555, 1.425… ## $ lahv &lt;dbl&gt; 20.58276, 20.58276, 20.58276, 20.58276, 20.58276, 20.58… ## $ vhp_n &lt;int&gt; 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11 seems like the data used to create Figure 1 (b) leafr_df %&gt;% ggplot(mapping = aes(x = lad, y = height)) + geom_path() + geom_point() + theme_light() what about the point cloud in voxels? # calculate voxel metrics voxel_metrics( crowns_nlas_temp %&gt;% lidR::filter_poi(tree_index == ti) , ~list(N = length(Z)) , 2 ) %&gt;% lidR::plot( color=&quot;N&quot;, pal = viridis::mako(n = 11, direction = -1) , size = 2, bg = &quot;white&quot;, voxel = TRUE, legend = T ) 2.3.5 I quit I quit following the package README because it’s unnecessarily complex 2.4 LadderFuelsR - simplified the package README is so convoluted and difficult to follow. let’s just cut the superfluity (i’ll see your “depurating” and raise you “superfluity”). someone had to identify the minimum steps needed to get CBH and cut out the superfluous clutter (bonus points if you see what i did there ;). 2.4.1 Setup the las files cropped to individual trees (i.e. one tree at a time) are passed to the leafR package to calculate the LAI-LAD metrics. it seems very inefficient to perform this one-by-one for individual tree point clouds and not something that would work well if many, many trees. let’s go through the process for one tree point cloud # leafR::lad.voxels requires a file location :\\ fn &lt;- paste0(tempdir(), &quot;/temp.las&quot;) # let&#39;s sample the tree with the most points ti &lt;- crowns_nlas_temp@data %&gt;% dplyr::count(tree_index) %&gt;% dplyr::arrange(desc(n)) %&gt;% dplyr::slice_head(n=1) %&gt;% dplyr::pull(tree_index) ( f &lt;- crowns_nlas_temp %&gt;% lidR::filter_poi(tree_index == ti) %&gt;% # put this in a function and map over trees lidR::writeLAS(file = fn) ) ## [1] &quot;C:\\\\Users\\\\georg\\\\AppData\\\\Local\\\\Temp\\\\RtmpYPey78/temp.las&quot; 2.4.2 Step 0 - leafR steps leafR::lad.voxels() - use normalized las file to create a data frame of the 3D voxels information (xyz) with Leaf Area Density values leafR::lad.profile() - calculate the lad profile from the input lad.voxels (step 1) ensure that the data frame returned from leafR::lad.profile() has a column named treeID which uniquely identifies individual trees. also, that column has to be the first column (bad practice by the authors) ## leafR::lad.voxels lad_voxels &lt;- leafR::lad.voxels(normlas.file = f, grain.size = 2) lad_voxels %&gt;% dplyr::glimpse() ## List of 2 ## $ LAD : num [1:12, 1:11] NA 0 0.0333 0 NA ... ## $ coordenates:&#39;data.frame&#39;: 12 obs. of 2 variables: ## ..$ X: num [1:12] 458836 458838 458840 458842 458836 ... ## ..$ Y: num [1:12] 4450232 4450232 4450232 4450232 4450230 ... ## leafR::lad.profile lad_profile &lt;- leafR::lad.profile(lad_voxels, relative = F) ## add treeID column that is required by the package, though it&#39;s never stated lad_profile &lt;- lad_profile %&gt;% dplyr::mutate(tree_index = ti, treeID = factor(tree_index)) %&gt;% ## !!!!! not only does the treeID column have to exist...it has to be the first column dplyr::relocate(treeID) lad_profile %&gt;% dplyr::glimpse() ## Rows: 11 ## Columns: 4 ## $ treeID &lt;fct&gt; 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203 ## $ height &lt;dbl&gt; 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5 ## $ lad &lt;dbl&gt; 0.693147181, 0.732408192, 0.910126467, 0.789234597, 0.62200… ## $ tree_index &lt;int&gt; 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203 2.4.3 Step 1 - LadderFuelsR::get_gaps_fbhs calculates gaps and fuel layers base height (FBH) as the difference in percentiles between consecutive LAD values along the vertical tree profile (VTP). Negative differences are linked to gaps and positive differences to fuel base height. notice that this function is broken in the package…see this issue Viedma et al. 2024 note: Function get_gaps_fbhs() identifies height bins with negative differences in LAD percentile for identifying gaps. When among consecutive height bins differences are negative, it selects the height bin with the lowest LAD (&lt;= perc_gap [P25th]). Additionally, the function looks for height bins with LAD &lt;= P25th, and when they are consecutive, it takes only the first and last values of the set being considered. For obtaining fuel layer base heights (FBHs), it identifies height bins with positive differences in LAD percentile. When such positive differences are consecutive, it selects the height bin with minimum LAD (&gt; perc_base [P25th]). Moreover, it filters height bins with LAD &gt; P25th, and when these are consecutive it takes only the first and last values of each set. Finally, to avoid any duplicated height bins in gaps and FBHs, it selects only the height bins identified as gaps that were not present in the FBH file, giving preference to the FBH height bins (p.3-5) ### this function is broken!!!!!!!!!!!!!!!!!!!!!!!!!! source(&quot;_broken_gap_fbh_from_LadderFuelsR.R&quot;) # gw fix here ## LadderFuelsR::get_gaps_fbhs gaps_fbhs &lt;- gw_get_gaps_fbhs( # LadderFuelsR::get_gaps_fbhs( LAD_profiles = lad_profile , step=1 , min_height=1.5 , perc_gap= 25, perc_base= 25 , verbose=TRUE ) gaps_fbhs %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 19 ## $ treeID &lt;fct&gt; 203 ## $ cbh1 &lt;chr&gt; &quot;1.5&quot; ## $ cbh2 &lt;chr&gt; &quot;2.5&quot; ## $ cbh3 &lt;chr&gt; &quot;7.5&quot; ## $ cbh4 &lt;chr&gt; &quot;8.5&quot; ## $ gap1 &lt;chr&gt; &quot;9.5&quot; ## $ gap2 &lt;chr&gt; &quot;11.5&quot; ## $ gap_lad1 &lt;dbl&gt; 0 ## $ gap_lad2 &lt;dbl&gt; 0 ## $ cbh_perc1 &lt;dbl&gt; 70 ## $ cbh_perc2 &lt;dbl&gt; 80 ## $ cbh_perc3 &lt;dbl&gt; 50 ## $ cbh_perc4 &lt;dbl&gt; 30 ## $ cbh_lad1 &lt;dbl&gt; 1 ## $ cbh_lad2 &lt;dbl&gt; 2 ## $ cbh_lad3 &lt;dbl&gt; 7 ## $ cbh_lad4 &lt;dbl&gt; 8 ## $ max_height &lt;dbl&gt; 11.5 ## $ treeID1 &lt;dbl&gt; 203 # fix the columns that should be numeric gaps_fbhs &lt;- gaps_fbhs %&gt;% dplyr::mutate(dplyr::across( !tidyselect::starts_with(&quot;treeID&quot;) , as.numeric )) let’s take LadderFuelsR::get_plots_gap_fbh() for a spin which creates the plot in Figure 3 (plots of leaf area density profiles with fuel base heights in green and gaps &gt;= step: Distance between bins in red). This function plots gaps and fuel layers base height (fbh) in the vertical tree profile (VTP). LadderFuelsR::get_plots_gap_fbh( LAD_profiles = lad_profile , gap_cbh_metrics = gaps_fbhs , min_height = 1.5 ) ## $`203` in RED are the GAPS and in GREEN the FBHs can we re-create this? ggplot() + geom_path(data = lad_profile, mapping = aes(x = lad, y = height)) + geom_point(data = lad_profile, mapping = aes(x = lad, y = height)) + # gaps data geom_hline( data = gaps_fbhs %&gt;% dplyr::select( tidyselect::starts_with(&quot;gap&quot;) &amp; !tidyselect::starts_with(&quot;gap_&quot;) ) %&gt;% tidyr::pivot_longer(dplyr::everything()) , aes(yintercept = value, color = &quot;gaps&quot;) , linetype = &quot;dotted&quot; , lwd = 1.2 ) + # fbh data geom_hline( data = gaps_fbhs %&gt;% dplyr::select( tidyselect::starts_with(&quot;cbh&quot;) &amp; !tidyselect::starts_with(&quot;cbh_&quot;) ) %&gt;% tidyr::pivot_longer(dplyr::everything()) , aes(yintercept = value, color = &quot;FBHs&quot;) , linetype = &quot;dotdash&quot; , lwd = 1.2 ) + scale_color_manual(values = c(&quot;green4&quot;, &quot;red&quot;), name = &quot;&quot;) + scale_y_continuous(breaks = scales::extended_breaks(10)) + theme_light() + theme(legend.position = &quot;top&quot;) yes. the gap and cbh columns contain the data ( but not the gap_ and cbh_ columns ;/ ). but what are these columns? cbh - Height of the fuel layer base height (m) gap - Height of gap between fuel layers (m) 2.4.4 Step 2 - LadderFuelsR::calculate_gaps_perc this function calculates the percentile value of each height ## LadderFuelsR::calculate_gaps_perc #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ERROR if treeID is not the first column gaps_perc &lt;- LadderFuelsR::calculate_gaps_perc( LAD_profiles = lad_profile %&gt;% dplyr::select(-tree_index) , min_height=1.5 ) ## [1] &quot;treeID: 203&quot; gaps_perc %&gt;% dplyr::glimpse() ## Rows: 11 ## Columns: 5 ## $ treeID &lt;fct&gt; 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203 ## $ height &lt;dbl&gt; 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5 ## $ lad &lt;dbl&gt; 0.693147181, 0.732408192, 0.910126467, 0.789234597, 0.… ## $ critical_points &lt;dbl&gt; 0.0000119390, -0.0284850400, -0.1019781452, -0.0840132… ## $ percentil &lt;dbl&gt; 70, 80, 100, 90, 60, 40, 50, 30, 20, 10, 5 2.4.5 Step 3 - LadderFuelsR::get_distance calculates distances (and their heights) between fuel layers as the difference between consecutive gaps and fuel bases (the gap height always must be lower than the fuel base height). Viedma et al. 2024 note: Function get_distance() calculates the distance between fuel layers as the height difference between each pair of consecutive gaps and FBHs (Figure 4a). In addition, when there are consecutive gaps, the distance is calculated as the difference between the minimum gap and the next FBH encountered (Figure 4b). Similarly, when there were consecutive FBHs, the distance was calculated as the difference between the minimum FBH and the previous gap encountered. When there are gaps above the last FBH, these values were removed for further analysis. (p.5) ## LadderFuelsR::get_distance metrics_distance &lt;- LadderFuelsR::get_distance( gap_cbh_metrics = gaps_fbhs , gaps_perc = gaps_perc , step=1, min_height=1.5 ) metrics_distance %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 17 ## $ treeID &lt;fct&gt; 203 ## $ treeID1 &lt;fct&gt; 203 ## $ cbh1 &lt;dbl&gt; 1.5 ## $ cbh2 &lt;dbl&gt; 2.5 ## $ cbh3 &lt;dbl&gt; 7.5 ## $ cbh4 &lt;dbl&gt; 8.5 ## $ gap1 &lt;dbl&gt; 9.5 ## $ gap2 &lt;dbl&gt; 11.5 ## $ Hdist1 &lt;dbl&gt; 1.5 ## $ dist1 &lt;dbl&gt; 0 ## $ Hdist2 &lt;dbl&gt; 0 ## $ dist2 &lt;dbl&gt; 0 ## $ Hdist3 &lt;dbl&gt; 0 ## $ dist3 &lt;dbl&gt; 0 ## $ Hdist4 &lt;dbl&gt; 0 ## $ dist4 &lt;dbl&gt; 0 ## $ max_height &lt;dbl&gt; 11.5 2.4.6 Step 4 - LadderFuelsR::get_depths calculates fuels depth as the difference between gaps interleaved between fuel layers minus one step if the fuel depths are greater than one step. Viedma et al. 2024 note: Function get_depths() calculates the depth of each fuel layer as the difference between the gaps comprising the FBHs. Finally, to get the real layer depth, and only when layer depth is greater than the step, it subtracts the step value from the depth (Figure 5). There are special cases when there are no gaps between FBHs: (i) if the gap height is less than the minimum height of the FBHs, depth is calculated as the difference between the maximum height of the FBHs set and the height of that gap minus the step (Figure 6a); (ii) if the gap height is greater than the maximum height of FBHs, depth is the difference between the maximum gap height and the minimum height of the FBHs set minus the step (Figure 6b). (p.5) ## LadderFuelsR::get_depths metrics_depth &lt;- LadderFuelsR::get_depths( LAD_profiles = lad_profile , distance_metrics = metrics_distance , step= 1, min_height= 1.5 ) metrics_depth %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 8 ## $ treeID &lt;fct&gt; 203 ## $ treeID1 &lt;fct&gt; 203 ## $ Hdepth1 &lt;dbl&gt; 8.5 ## $ dist1 &lt;dbl&gt; 1.5 ## $ Hdist1 &lt;dbl&gt; 1.5 ## $ depth1 &lt;dbl&gt; 7 ## $ cbh1 &lt;dbl&gt; 1.5 ## $ max_height &lt;dbl&gt; 11.5 2.4.7 Step 5 - LadderFuelsR::get_real_fbh reshapes fuel layers after removing distances equal to any number of height bin steps, keeping the first “base height” from those consecutive ones separated by such distance. Viedma et al. 2024 note: Function get_real_fbh() identifies the first FBH from consecutive FBHs or the first FBH from those separated by a distance equal to number of steps that can be skipped to reshape the fuel layers. For each distance value, it locates the next FBH value. If distance = num_step, the height of that FBH is propagated upwards. If distance &gt; num_step, the height of that FBH is kept (Figure 7a,b). (p.5-6) ## LadderFuelsR::get_real_fbh real_fbh &lt;- LadderFuelsR::get_real_fbh( depth_metrics = metrics_depth , step= 1, number_steps = 1, min_height=1.5 ) real_fbh %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 8 ## $ treeID1 &lt;dbl&gt; 203 ## $ Hdepth1 &lt;dbl&gt; 8.5 ## $ dist1 &lt;dbl&gt; 1.5 ## $ Hdist1 &lt;dbl&gt; 1.5 ## $ depth1 &lt;dbl&gt; 7 ## $ Hcbh1 &lt;dbl&gt; 1.5 ## $ treeID &lt;fct&gt; 203 ## $ max_height &lt;dbl&gt; 11.5 2.4.8 Step 6 - LadderFuelsR::get_real_depths recalculates fuel layers depth after considering distances greater than the actual height bin step. Viedma et al. 2024 note: Function get_real_depths() calculates the cumulative heights of depth values when distance = num_step. It iterates over each distance value and if dist[i] &gt; num_step, it keeps the corresponding depth value. However, if dist[i] = num_step, it sums all consecutive distances and corresponding depth values (Figure 7a,b). (p.6) ## LadderFuelsR::get_real_depths real_depth &lt;- LadderFuelsR::get_real_depths(effective_fbh = real_fbh, step=1, min_height=1.5) real_depth %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 8 ## $ treeID &lt;fct&gt; 203 ## $ treeID1 &lt;dbl&gt; 203 ## $ Hdptf1 &lt;dbl&gt; 8.5 ## $ dist1 &lt;dbl&gt; 0 ## $ dptf1 &lt;dbl&gt; 7 ## $ Hcbh1 &lt;dbl&gt; 1.5 ## $ Hdist1 &lt;dbl&gt; 1.5 ## $ max_height &lt;dbl&gt; 11.5 2.4.9 Step 7 - LadderFuelsR::get_effective_gap recalculates the distance between fuel layers after considering distances greater than any number of height bin steps. Viedma et al. 2024 note: Function get_effective_gap() calculates the effective distance between fuel layers based on the previously identified FBHs. It loops over all the FBHs and, at each iteration, it checks if the current value and the next value in FBHs are not equal. If they are not equal, it keeps the corresponding distance value, otherwise it removes it (Figure 8). (p.6) ## LadderFuelsR::get_effective_gap eff_gap &lt;- LadderFuelsR::get_effective_gap( effective_depth = real_depth , number_steps = 1, min_height= 1.5 ) eff_gap %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 9 ## $ treeID &lt;fct&gt; 203 ## $ treeID1 &lt;dbl&gt; 203 ## $ dist1 &lt;dbl&gt; 0 ## $ dptf1 &lt;dbl&gt; 7 ## $ effdist1 &lt;dbl&gt; 0 ## $ Hcbh1 &lt;dbl&gt; 1.5 ## $ Hdist1 &lt;dbl&gt; 1.5 ## $ Hdptf1 &lt;dbl&gt; 8.5 ## $ max_height &lt;dbl&gt; 11.5 2.4.10 Step 8 - LadderFuelsR::get_layers_lad calculates the percentage of Leaf Area Density (LAD) within each fuel layer (first output) and removes those fuel layers with LAD percentage less than a specified threshold (default 10 the depth of the remaining ones (second output). Viedma et al. 2024 note: Function get_layers_lad() calculates LAD (%) within each fuel layer, which is defined by the height range between the FBH and its depth. First, it calculates the total LAD from the original profile. Next, it retrieves the beginning and end height bin of each fuel layer and calculates the percentage of total LAD that falls within that height range. Later, the fuel layers that had a LAD (%) less than a specified threshold (default 10%) were removed, recalculating the distances (Figure 9). (p.7) ## LadderFuelsR::get_layers_lad layers_lad_df &lt;- LadderFuelsR::get_layers_lad( LAD_profiles = lad_profile , effective_distances = eff_gap , threshold=10,step = 1,min_height= 1.5 ) layers_lad_df %&gt;% str() ## List of 2 ## $ df1:&#39;data.frame&#39;: 1 obs. of 12 variables: ## ..$ treeID1 : num 203 ## ..$ treeID : Factor w/ 1 level &quot;203&quot;: 1 ## ..$ dist1 : num 0 ## ..$ dptf1 : num 7 ## ..$ effdist1 : num 0 ## ..$ Hcbh1 : num 1.5 ## ..$ Hdist1 : num 1.5 ## ..$ Hdptf1 : num 8.5 ## ..$ max1 : num 11.5 ## ..$ Hcbh1_Hdptf1: num 98.8 ## ..$ max_height : num 11.5 ## ..$ nlayers : int 1 ## $ df2:&#39;data.frame&#39;: 1 obs. of 11 variables: ## ..$ treeID1 : num 203 ## ..$ treeID : Factor w/ 1 level &quot;203&quot;: 1 ## ..$ dptf1 : num 7 ## ..$ effdist1 : num 0 ## ..$ Hcbh1 : num 1.5 ## ..$ Hdist1 : num 1.5 ## ..$ Hdptf1 : num 8.5 ## ..$ max1 : num 11.5 ## ..$ max_height : num 11.5 ## ..$ Hcbh1_Hdptf1: num 98.8 ## ..$ nlayers : int 1 idk why it is a list of 2 with the same data just the order of the max_height and Hcbh1_Hdptf1 columns are switched. do you spot another difference?? looking through the befuddling README it looks like the authors only keep the second data frame in the list (layers_lad_df &lt;- layers_lad_df[[2]]) ## treeID1 treeID dptf1 effdist1 Hcbh1 Hdist1 Hdptf1 max1 max_height ## 1 203 203 7 0 1.5 1.5 8.5 11.5 11.5 ## Hcbh1_Hdptf1 nlayers ## 1 98.77835 1 is CBH in here? did we do it? treeID: tree ID with strings and numeric values treeID1: tree ID with only numeric values dptf: Depth of fuel layers (m) after considering distances greater than the actual height bin step effdist: Effective distance between consecutive fuel layers (m) after considering distances greater than any number of steps Hcbh: Base height of each fuel separated by a distance greater than the certain number of steps Hdptf: Height of the depth of fuel layers (m) after considering distances greater than the actual step Hdist: Height of the distance (&gt; any number of steps) between consecutive fuel layers (m) Hcbh_Hdptf - Percentage of LAD values comprised in each effective fuel layer max_height - Maximum height of the tree profile nlayers - Number of effective fuel layers is it possible to have multiple Hcbh values for one tree? is step 9 below even necessary at this point? let’s take the LadderFuelsR::get_plots_effective() function for a spin LadderFuelsR::get_plots_effective( LAD_profiles = lad_profile , effective_LAD = layers_lad_df , min_height = 1.5 ) ## $`203` maybe we’ll try to recreate this plot at some point # wanna recreate this? 2.4.11 Step 9 - LadderFuelsR::get_cbh_dist LadderFuelsR::get_cbh_metrics LadderFuelsR::get_cbh_dist is described in the research article but does not exist in the package or README. Looks like LadderFuelsR::get_cbh_metrics is there though. determines the CBH of a segmented tree using three criteria: maximum LAD percentage, maximum distance and the last distance. Viedma et al. 2024 note: Function get_cbh_dist() applies three criteria to define the CBH in a segmented tree: the fuel layer containing the maximum LAD (%) (Figure 10a), the fuel layer located at the highest distance (Figure 10b), and the fuel layer separated by the last effective distance (Figure 10c). In the case of maximum LAD (%), the output also gives the CBH from the second fuel layer when the first one has the maximum LAD (%) but its depth is smaller than the value indicated in the parameter ‘hdepth1_height’ (default 2m). (p.8) ## LadderFuelsR::get_cbh_metrics cbh_metrics &lt;- LadderFuelsR::get_cbh_metrics(effective_LAD = layers_lad_df, min_height= 1.5) cbh_metrics %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 29 ## $ treeID1 &lt;dbl&gt; 203 ## $ dptf1 &lt;dbl&gt; 7 ## $ effdist1 &lt;dbl&gt; 0 ## $ Hcbh1 &lt;dbl&gt; 1.5 ## $ Hdist1 &lt;dbl&gt; 1.5 ## $ Hdptf1 &lt;dbl&gt; 8.5 ## $ max1 &lt;dbl&gt; 11.5 ## $ Hcbh1_Hdptf1 &lt;dbl&gt; 98.77835 ## $ treeID &lt;fct&gt; 203 ## $ max_height &lt;dbl&gt; 11.5 ## $ nlayers &lt;int&gt; 1 ## $ maxlad_Hcbh &lt;dbl&gt; 1.5 ## $ maxlad_Hdist &lt;dbl&gt; 1.5 ## $ maxlad_Hdptf &lt;dbl&gt; 8.5 ## $ maxlad_dptf &lt;dbl&gt; 7 ## $ maxlad_effdist &lt;dbl&gt; 0 ## $ maxlad_lad &lt;dbl&gt; 98.77835 ## $ max_Hcbh &lt;dbl&gt; 1.5 ## $ max_Hdist &lt;dbl&gt; 1.5 ## $ max_Hdptf &lt;dbl&gt; 8.5 ## $ max_dptf &lt;dbl&gt; 7 ## $ max_effdist &lt;dbl&gt; 0 ## $ max_lad &lt;dbl&gt; 98.77835 ## $ last_Hcbh &lt;dbl&gt; 1.5 ## $ last_Hdist &lt;dbl&gt; 1.5 ## $ last_Hdptf &lt;dbl&gt; 8.5 ## $ last_dptf &lt;dbl&gt; 7 ## $ last_effdist &lt;dbl&gt; 0 ## $ last_lad &lt;dbl&gt; 98.77835 what are these? treeID: tree ID with strings and numeric values treeID1: tree ID with only numeric values dptf: Depth of fuel layers (m) after considering distances greater than the actual height bin step effdist: Effective distance between consecutive fuel layers (m) after considering distances greater than any number of steps Hcbh: Base height of each fuel separated by a distance greater than the certain number of steps Hdptf: Height of the depth of fuel layers (m) after considering distances greater than the actual step Hdist: Height of the distance (&gt; any number of steps) between consecutive fuel layers (m) Hcbh_Hdptf - Percentage of LAD values comprised in each effective fuel layer maxlad_Hcbh - Height of the CBH of the segmented tree based on the maximum LAD percentage maxlad1_Hcbh - Height of the CBH from the second fuel layer when the maximum LAD occurred in the first fuel layer but its depth &lt;= “hdepth1_height” max_Hcbh - Height of the CBH of the segmented tree based on the maximum distance found in its profile last_Hcbh - Height of the CBH of the segmented tree based on the last distance found in its profile maxlad_ - Values of distance and fuel depth and their corresponding heights at the maximum LAD percentage maxlad1_ - Values of distance and fuel depth and their corresponding heights for the second fuel layer when the maximum LAD occurred in the first fuel layer but its depth &lt;= “hdepth1_height” max_ - Values of distance and fuel depth and their corresponding heights at the maximum distance last_ - Values of distance and fuel depth and their corresponding heights at the last distance nlayers - Number of effective fuel layers max_height - Maximum height of the tree profile there are also some plotting functions # Generate plots for fuels LAD metrics plots_cbh_maxlad &lt;- LadderFuelsR::get_plots_cbh_LAD( LAD_profiles = lad_profile , cbh_metrics = cbh_metrics , min_height=1.5 ) plots_cbh_maxdist &lt;- LadderFuelsR::get_plots_cbh_maxdist( LAD_profiles = lad_profile , cbh_metrics = cbh_metrics , min_height=1.5 ) plots_cbh_lastdist &lt;- LadderFuelsR::get_plots_cbh_lastdist( LAD_profiles = lad_profile , cbh_metrics = cbh_metrics , min_height=1.5 ) # patchwork them (plots_cbh_maxlad[[1]] + labs(title = &quot;get_plots_cbh_LAD&quot;)) + (plots_cbh_maxdist[[1]] + labs(title = &quot;get_plots_cbh_maxdist&quot;)) + (plots_cbh_lastdist[[1]] + labs(title = &quot;get_plots_cbh_lastdist&quot;)) + patchwork::plot_layout(ncol = 2) these plots represent the three criteria to define the CBH in a segmented tree: get_plots_cbh_LAD = the fuel layer containing the maximum LAD percentage (column named maxlad_Hcbh) get_plots_cbh_maxdist = the fuel layer located at the highest distance (column named max_Hcbh) get_plots_cbh_lastdist = the fuel layer separated by the last effective distance (column named last_Hcbh) "],["s02.html", "Section 3 Process 3.1 Get some lidar data 3.2 Define LadderFuelsR Processing Function 3.3 Function to CBH a tree list", " Section 3 Process In this prior section we reviewed the methodologies to process lidar data, extract a tree list, and estimate CBH. Presently, we will outline the end-to-end process for accomplishing this task given some example lidar data. 3.1 Get some lidar data The USGS has a lidar data explorer. This data is non-standardized so it may be challenging to build any portable processes. I found an example area of interest and navigated to the file storage directory We’ll use the rvest package to download the las files programmatically. # url url &lt;- &quot;https://rockyweb.usgs.gov/vdelivery/Datasets/Staged/Elevation/LPC/Projects/CO_Southwest_NRCS_2018_D18/CO_Southwest_NRCS_B3_2018/LAZ/&quot; # rvest read html html &lt;- rvest::read_html(x = url) # get parent element chrs &lt;- html %&gt;% rvest::html_elements(&quot;pre&quot;) # unnest children elements # chrs %&gt;% rvest::html_elements(&quot;a&quot;) las_files &lt;- chrs[1] %&gt;% rvest::html_elements(&quot;a&quot;) %&gt;% rvest::html_text2() %&gt;% stringr::str_subset(&quot;.*\\\\.(laz|las)$&quot;) download files # increase the download timeout options(timeout = max(3600, getOption(&quot;timeout&quot;))) # function to download dl_fn &lt;- function(x, my_url = url, dest = &quot;E:/SJNF_lidar&quot;){ # create delivery dir if needed if(!file.exists(file.path(dest))){ dir.create(file.path(dest), showWarnings = FALSE) } # parameters to download u &lt;- paste0(my_url, x) d &lt;- paste0(file.path(dest),&quot;/&quot;, x) # download it...if needed if(!file.exists(d)){ # print message(&quot;downloading file: &quot;, x, &quot;at &quot;, Sys.time()) # download it download.file( url = u, destfile = d , quiet = F , mode = &quot;wb&quot; ) } return(d) } # map over the las files to read dl_fn_ans &lt;- las_files %&gt;% .[1:20] %&gt;% purrr::map(\\(x) dl_fn(x)) %&gt;% unlist() # dl_fn_ans where in the world is this data? las_ctg &lt;- lidR::readLAScatalog(dl_fn_ans) mapview::mapview(las_ctg@data) let’s read one file las &lt;- lidR::readLAS(dl_fn_ans[13]) las ## class : LAS (v1.4 format 6) ## memory : 981.9 Mb ## extent : -923000, -922000, 1600000, 1601000 (xmin, xmax, ymin, ymax) ## coord. ref. : NAD83(2011) / Conus Albers + NAVD88 height - Geoid12B (meters) ## area : 1 km² ## points : 13.55 million points ## density : 13.55 points/m² ## density : 7.01 pulses/m² plot a sample las %&gt;% lidR::clip_roi( las %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% sf::st_buffer(-400) ) %&gt;% lidR::plot( color = &quot;Z&quot;, breaks = &quot;quantile&quot;, bg = &quot;white&quot;, legend = T , pal = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) ) 3.1.1 cloud2trees that lidar data extract trees from the lidar data using cloud2trees to create some example tree-level point cloud data to test the LadderFuelsR function we define below with if(F){ cloud2trees_ans &lt;- cloud2trees::cloud2trees( input_las_dir = dl_fn_ans[13] , output_dir = &quot;../data&quot; , estimate_tree_dbh = T , keep_intrmdt = T ) }else{ cloud2trees_ans &lt;- list( crowns_sf = sf::st_read(&quot;../data/point_cloud_processing_delivery/final_detected_crowns.gpkg&quot;, quiet=T) , treetops_sf = sf::st_read(&quot;../data/point_cloud_processing_delivery/final_detected_tree_tops.gpkg&quot;, quiet=T) ) } clean it for LadderFuelsR to attach treeID to the point cloud # the lidR::merge_spatial requires only polygons so we need to rid the multipolygons crowns_sf_poly &lt;- # start with only polygons cloud2trees_ans$crowns_sf %&gt;% dplyr::filter(sf::st_geometry_type(.)==&quot;POLYGON&quot;) %&gt;% # union on cleaned multipolygons dplyr::bind_rows( cloud2trees_ans$crowns_sf %&gt;% dplyr::filter(sf::st_geometry_type(.)==&quot;MULTIPOLYGON&quot;) %&gt;% sf::st_cast(to = &quot;POLYGON&quot;, do_split = T, warn = F) %&gt;% dplyr::mutate(axxx = sf::st_area(.)) %&gt;% # axxx is so we don&#39;t overwrite a column dplyr::group_by(treeID) %&gt;% dplyr::filter(axxx == max(axxx)) %&gt;% # keep the biggest crown polygon by treeID dplyr::ungroup() %&gt;% dplyr::select(-axxx) ) %&gt;% # generate a treeID index because it needs to be numeric dplyr::ungroup() %&gt;% dplyr::mutate( treeID_backup = treeID , treeID = dplyr::row_number() ) read in normalized las files and filter one for testing # read in catalog crowns_nlas_ctg &lt;- lidR::readLAScatalog(&quot;../data/point_cloud_processing_temp/02_normalize/&quot;) # filter for single tree point cloud one_tree_sf &lt;- crowns_sf_poly %&gt;% # get one of the taller trees dplyr::filter(tree_height_m &gt;= quantile(crowns_sf_poly$tree_height_m, probs = 0.9)) %&gt;% dplyr::slice_sample(n=1) now we’ll attach the treeID column to the normalized las file and keep only the points that fall within a tree crown. # clip the point cloud nlas_one_tree &lt;- lidR::clip_roi( las = crowns_nlas_ctg , geometry = one_tree_sf ) %&gt;% sf::st_set_crs(sf::st_crs(crowns_sf_poly)) %&gt;% lidR::merge_spatial( source = crowns_sf_poly , attribute = &quot;treeID&quot; ) %&gt;% lidR::filter_poi(!is.na(treeID)) # what is this data? nlas_one_tree@data %&gt;% dplyr::glimpse() ## Rows: 108 ## Columns: 17 ## $ X &lt;dbl&gt; 458833.4, 458833.1, 458833.3, 458833.5, 458833.3, 45… ## $ Y &lt;dbl&gt; 4450222, 4450222, 4450222, 4450222, 4450222, 4450222… ## $ Z &lt;dbl&gt; 3.474, 3.410, 2.726, 2.075, 1.162, 12.047, 11.364, 1… ## $ gpstime &lt;dbl&gt; 425181.3, 425181.3, 425181.3, 425181.3, 425181.3, 42… ## $ Intensity &lt;int&gt; 27, 17, 14, 23, 21, 31, 33, 12, 17, 33, 45, 61, 19, … ## $ ReturnNumber &lt;int&gt; 1, 1, 2, 3, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ NumberOfReturns &lt;int&gt; 2, 4, 4, 4, 3, 3, 2, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 3… ## $ ScanDirectionFlag &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ EdgeOfFlightline &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ Classification &lt;int&gt; 5, 5, 5, 5, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5… ## $ Synthetic_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ Keypoint_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ Withheld_flag &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ ScanAngleRank &lt;int&gt; 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, … ## $ UserData &lt;int&gt; 35, 34, 27, 21, 12, 120, 113, 102, 85, 68, 64, 51, 8… ## $ PointSourceID &lt;int&gt; 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, … ## $ treeID &lt;int&gt; 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 10… 3.2 Define LadderFuelsR Processing Function In this prior section we identified the minimum steps needed to get CBH using the LadderFuelsR and leafR packages. Unfortunately, extracting CBH from the point cloud following these methods is performed one-by-one for individual trees. This does not seem like something that would work well if many, many trees. There are a few possible paths forward to get CBH from point cloud data: * Extract CBH from the point cloud for all trees using the LadderFuelsR methodology * Extract CBH from the point cloud for a sample of trees using the LadderFuelsR methodology and build a model to estimate the rest * Use the TreeMap 2016 data to model CBH using a regional model Let’s build a function to combine the LadderFuelsR steps for estimating CBH from the individual tree point cloud. Our function will take a point cloud as input and return a data frame. ladderfuelsr_cbh &lt;- function( las , treeID = NA # minimum vhp records # https://github.com/olgaviedma/LadderFuelsR?tab=readme-ov-file#8depurating-tree-lad-profiles , min_vhp_n = 6 # leafR::lad.voxels , voxel_grain_size_m = 2 # grain.size # LadderFuelsR::get_gaps_fbhs , dist_btwn_bins_m = 1 # step , min_fuel_layer_ht_m = 1.5 # min_height , lad_pct_gap = 25 # perc_gap , lad_pct_base = 25 # perc_base # LadderFuelsR::get_real_fbh , num_jump_steps = 1 # number_steps # LadderFuelsR::get_layers_lad , min_lad_pct = 10 # threshold # LadderFuelsR::get_cbh_metrics , frst_layer_min_ht_m = 2.5 # hdepth1_height ) { # check if string to las/laz file if(inherits(las, &quot;character&quot;)){ if(!stringr::str_ends(las, &quot;.*\\\\.(laz|las)$&quot;)){ stop(&quot;must pass a .las|.laz file path -OR- an object of class LAS to the `las` parameter&quot;) } # set the file path f &lt;- normalizePath(las) }else if(inherits(las, &quot;LAS&quot;)){ # have to write the las to a tempfile fn &lt;- paste0(tempdir(), &quot;/temp.las&quot;) # check if has a treeID if( (names(las@data) %&gt;% stringr::str_detect(&quot;treeID&quot;) %&gt;% max())==1 ){ n &lt;- las@data$treeID %&gt;% unique() %&gt;% length() if(n&gt;1 &amp; is.na(treeID)){ stop(&quot;the treeID column has more than one tree detected. set the `treeID` parameter&quot;) }else if(is.na(treeID)){ # set the treeID treeID &lt;- las@data$treeID %&gt;% unique() # write it f &lt;- las %&gt;% lidR::filter_poi(treeID == treeID) %&gt;% lidR::writeLAS(file = fn) }else{ # write it f &lt;- las %&gt;% lidR::filter_poi(treeID == treeID) %&gt;% lidR::writeLAS(file = fn) } }else{ # write it f &lt;- las %&gt;% lidR::writeLAS(file = fn) } }else{ stop(&quot;must pass a .las|.laz file path -OR- an object of class LAS to the `las` parameter&quot;) } # check the treeID treeID &lt;- dplyr::coalesce(as.character(treeID), as.character(1)) # if the treeID parameter is not set, fake 1 ####################################### ### Step 0 - `leafR` steps ####################################### # 1) `leafR::lad.voxels()` - use normalized las file to create # a data frame of the 3D voxels information (xyz) with Leaf Area Density values # 2) `leafR::lad.profile()` - calculate the lad profile from # the input lad.voxels (step 1) # 3) ensure that the data frame returned from `leafR::lad.profile()` # has a column named `treeID` which uniquely identifies individual trees. # also, that column has to be the first column (bad practice by the authors) ## leafR::lad.voxels lad_voxels &lt;- leafR::lad.voxels(normlas.file = f, grain.size = voxel_grain_size_m) ## leafR::lad.profile lad_profile &lt;- leafR::lad.profile(lad_voxels, relative = F) ## add treeID column that is required by the package, though it&#39;s never stated lad_profile &lt;- lad_profile %&gt;% dplyr::mutate( treeID = treeID %&gt;% factor() ) %&gt;% ## !!!!! not only does the treeID column have to exist...it has to be the first column dplyr::relocate(treeID) %&gt;% dplyr::filter(treeID == treeID) ### check if all NA or all 0, whereby no fuel gaps can be determined prof_na &lt;- lad_profile %&gt;% dplyr::filter(dplyr::coalesce(lad,0) == 0) %&gt;% nrow() if( nrow(lad_profile)-prof_na &lt;= 1 ){ message( paste0( &quot;no fuel gaps found. unable to quantify CBH (treeID=&quot; , treeID, &quot;).&quot; ) ) return(NULL) }else if(nrow(lad_profile) &lt; min_vhp_n){ message( paste0( nrow(lad_profile) , &quot; fuel vertical height profiles found. unable to quantify CBH (treeID=&quot; , treeID, &quot;). try decreasing the `min_vhp_n` parameter?&quot; ) ) return(NULL) } else{ ## &quot;depurating tree lad profiles&quot; ## see: https://github.com/olgaviedma/LadderFuelsR#8depurating-tree-lad-profiles lad_profile &lt;- lad_profile %&gt;% dplyr::mutate(lad = dplyr::coalesce(as.numeric(lad), 0.01)) %&gt;% dplyr::arrange(treeID, height) ####################################### ### Step 1 - `LadderFuelsR::get_gaps_fbhs` ####################################### ### this function is fixed: https://github.com/olgaviedma/LadderFuelsR/pull/3 ### LadderFuelsR::get_gaps_fbhs ### This function calculates gaps and fuel layers base height (FBH) as ### the difference in percentiles between consecutive LAD values along the vertical tree profile (VTP) # quiet this function quiet_get_gaps_fbhs &lt;- purrr::quietly(LadderFuelsR::get_gaps_fbhs) gaps_fbhs &lt;- # gw_get_gaps_fbhs( # LadderFuelsR::get_gaps_fbhs( quiet_get_gaps_fbhs( LAD_profiles = lad_profile , step = dist_btwn_bins_m , min_height = min_fuel_layer_ht_m , perc_gap = lad_pct_gap , perc_base = lad_pct_base , verbose = F ) # just get the result gaps_fbhs &lt;- gaps_fbhs$result # fix the columns that should be numeric gaps_fbhs &lt;- gaps_fbhs %&gt;% dplyr::mutate(dplyr::across( !tidyselect::starts_with(&quot;treeID&quot;) , as.numeric )) ### check for all NA or 0 gaps_na &lt;- gaps_fbhs %&gt;% dplyr::filter( dplyr::if_all( .cols = -tidyselect::starts_with(&quot;treeID&quot;) , .fns = ~ dplyr::coalesce(.x, 0) == 0 ) ) %&gt;% nrow() if(gaps_na&gt;0){ message( paste0( &quot;no fuel gaps found. unable to quantify CBH (treeID=&quot; , treeID, &quot;).&quot; ) ) return(NULL) }else{ ######`################################# ### Step 2 - `LadderFuelsR::calculate_gaps_perc` ####################################### ### this function calculates the percentile value of each height ## LadderFuelsR::calculate_gaps_perc #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ERROR if treeID is not the first column # quiet this function quiet_calculate_gaps_perc &lt;- purrr::quietly(LadderFuelsR::calculate_gaps_perc) # run it quietly gaps_perc &lt;- quiet_calculate_gaps_perc( # LadderFuelsR::calculate_gaps_perc( LAD_profiles = lad_profile , min_height = min_fuel_layer_ht_m ) # just get the result gaps_perc &lt;- gaps_perc$result ####################################### ### Step 3 - `LadderFuelsR::get_distance` ####################################### ### calculates distances (and their heights) between fuel layers as ### the difference between consecutive gaps and fuel bases ### (the gap height always must be lower than the fuel base height). ## LadderFuelsR::get_distance metrics_distance &lt;- LadderFuelsR::get_distance( gap_cbh_metrics = gaps_fbhs , gaps_perc = gaps_perc , step = dist_btwn_bins_m , min_height = min_fuel_layer_ht_m , verbose = F ) ####################################### ### Step 4 - `LadderFuelsR::get_depths` ####################################### ### calculates fuels depth as the difference between gaps ### interleaved between fuel layers minus one step if ### the fuel depths are greater than one step. ## LadderFuelsR::get_depths metrics_depth &lt;- LadderFuelsR::get_depths( LAD_profiles = lad_profile , distance_metrics = metrics_distance , step = dist_btwn_bins_m , min_height= min_fuel_layer_ht_m , verbose = F ) ####################################### ### Step 5 - `LadderFuelsR::get_real_fbh` ####################################### ### reshapes fuel layers after removing distances equal ### to any number of height bin steps, keeping the first ### &quot;base height&quot; from those consecutive ones separated by such distance. ## LadderFuelsR::get_real_fbh real_fbh &lt;- LadderFuelsR::get_real_fbh( depth_metrics = metrics_depth , step = dist_btwn_bins_m , number_steps = num_jump_steps , min_height = min_fuel_layer_ht_m , verbose = F ) ####################################### ### Step 6 - `LadderFuelsR::get_real_depths` ####################################### ### recalculates fuel layers depth after considering ### distances greater than the actual height bin step. ## LadderFuelsR::get_real_depths real_depth &lt;- LadderFuelsR::get_real_depths( effective_fbh = real_fbh , step = dist_btwn_bins_m , min_height = min_fuel_layer_ht_m , verbose = F ) ####################################### ### Step 7 - `LadderFuelsR::get_effective_gap` ####################################### ### recalculates the distance between fuel layers after considering ### distances greater than any number of height bin steps. ## LadderFuelsR::get_effective_gap eff_gap &lt;- LadderFuelsR::get_effective_gap( effective_depth = real_depth , number_steps = num_jump_steps , min_height = min_fuel_layer_ht_m , verbose = F ) ####################################### ### Step 8 - `LadderFuelsR::get_layers_lad` ####################################### ### calculates the percentage of Leaf Area Density (LAD) within ### each fuel layer (first output) and removes those fuel layers ### with LAD percentage less than a specified threshold ### (default 10 the depth of the remaining ones (second output). ## LadderFuelsR::get_layers_lad layers_lad_df &lt;- LadderFuelsR::get_layers_lad( LAD_profiles = lad_profile , effective_distances = eff_gap , threshold = min_lad_pct , step = dist_btwn_bins_m , min_height = min_fuel_layer_ht_m , verbose = F ) ### idk why it is a list of 2 with the same data just the order ### of the `max_height` and `Hcbh1_Hdptf1` columns are switched. do you spot another difference?? ### looking through the befuddling README it looks like the authors only keep ### the second data frame in the list if(length(layers_lad_df)&gt;1){ layers_lad_df &lt;- layers_lad_df[[2]] } ####################################### ### Step 9 - `LadderFuelsR::get_cbh_metrics` ####################################### ### `LadderFuelsR::get_cbh_dist` is described in the research article but does not ### exist in the package or README. Looks like `LadderFuelsR::get_cbh_metrics` is there though. ### determines the CBH of a segmented tree using three criteria: ### maximum LAD percentage, maximum distance and the last distance. ## LadderFuelsR::get_cbh_metrics cbh_metrics &lt;- LadderFuelsR::get_cbh_metrics( effective_LAD = layers_lad_df , min_height = min_fuel_layer_ht_m , hdepth1_height = frst_layer_min_ht_m , verbose = F ) # return return(list( gaps_fbhs = gaps_fbhs , lad_profile = lad_profile , gaps_perc = gaps_perc , metrics_distance = metrics_distance , metrics_depth = metrics_depth , real_fbh = real_fbh , real_depth = real_depth , eff_gap = eff_gap , layers_lad_df = layers_lad_df , cbh_metrics = cbh_metrics )) } # if all NA or all 0, whereby no fuel gaps can be determined } # if all NA or all 0, whereby no fuel gaps can be determined } # CALL IT ladderfuelsr_cbh_ans &lt;- ladderfuelsr_cbh( las = nlas_one_tree # %&gt;% lidR::decimate_points(random(0.5)) ) ladderfuelsr_cbh_ans %&gt;% names() ## [1] &quot;gaps_fbhs&quot; &quot;lad_profile&quot; &quot;gaps_perc&quot; &quot;metrics_distance&quot; ## [5] &quot;metrics_depth&quot; &quot;real_fbh&quot; &quot;real_depth&quot; &quot;eff_gap&quot; ## [9] &quot;layers_lad_df&quot; &quot;cbh_metrics&quot; ladderfuelsr_cbh_ans$lad_profile %&gt;% dplyr::glimpse() ## Rows: 12 ## Columns: 3 ## $ treeID &lt;fct&gt; 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104 ## $ height &lt;dbl&gt; 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5 ## $ lad &lt;dbl&gt; 0.374693449, 0.247836164, 0.237671652, 0.282862786, 0.069958589… Create our own plot of the gaps and fuel layers base height in the vertical tree profile ggplot() + geom_path(data = ladderfuelsr_cbh_ans$lad_profile, mapping = aes(x = lad, y = height)) + geom_point(data = ladderfuelsr_cbh_ans$lad_profile, mapping = aes(x = lad, y = height)) + # gaps data geom_hline( data = ladderfuelsr_cbh_ans$gaps_fbhs %&gt;% dplyr::select( tidyselect::starts_with(&quot;gap&quot;) &amp; !tidyselect::starts_with(&quot;gap_&quot;) ) %&gt;% tidyr::pivot_longer(dplyr::everything()) , aes(yintercept = value, color = &quot;gaps&quot;) , linetype = &quot;dotted&quot; , lwd = 1.2 ) + # fbh data geom_hline( data = ladderfuelsr_cbh_ans$gaps_fbhs %&gt;% dplyr::select( tidyselect::starts_with(&quot;cbh&quot;) &amp; !tidyselect::starts_with(&quot;cbh_&quot;) ) %&gt;% tidyr::pivot_longer(dplyr::everything()) , aes(yintercept = value, color = &quot;FBHs&quot;) , linetype = &quot;dotdash&quot; , lwd = 1.2 ) + scale_color_manual(values = c(&quot;green4&quot;, &quot;red&quot;), name = &quot;&quot;) + scale_y_continuous(breaks = scales::extended_breaks(10)) + theme_light() + theme(legend.position = &quot;top&quot;) note, the gap and cbh columns in ladderfuelsr_cbh_ans$gaps_fbhs contain the data needed for the plot ( but not the gap_ and cbh_ columns ;/ ). but what are these columns? cbh - Height of the fuel layer base height (m) gap - Height of gap between fuel layers (m) 3.2.1 Return CBH Metrics ladderfuelsr_cbh_ans$cbh_metrics %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 29 ## $ treeID1 &lt;dbl&gt; 104 ## $ dptf1 &lt;dbl&gt; 10 ## $ effdist1 &lt;dbl&gt; 0 ## $ Hcbh1 &lt;dbl&gt; 1.5 ## $ Hdist1 &lt;dbl&gt; 1.5 ## $ Hdptf1 &lt;dbl&gt; 11.5 ## $ max1 &lt;dbl&gt; 12.5 ## $ Hcbh1_Hdptf1 &lt;dbl&gt; 100 ## $ treeID &lt;fct&gt; 104 ## $ max_height &lt;dbl&gt; 12.5 ## $ nlayers &lt;int&gt; 1 ## $ maxlad_Hcbh &lt;dbl&gt; 1.5 ## $ maxlad_Hdist &lt;dbl&gt; 1.5 ## $ maxlad_Hdptf &lt;dbl&gt; 11.5 ## $ maxlad_dptf &lt;dbl&gt; 10 ## $ maxlad_effdist &lt;dbl&gt; 0 ## $ maxlad_lad &lt;dbl&gt; 100 ## $ max_Hcbh &lt;dbl&gt; 1.5 ## $ max_Hdist &lt;dbl&gt; 1.5 ## $ max_Hdptf &lt;dbl&gt; 11.5 ## $ max_dptf &lt;dbl&gt; 10 ## $ max_effdist &lt;dbl&gt; 0 ## $ max_lad &lt;dbl&gt; 100 ## $ last_Hcbh &lt;dbl&gt; 1.5 ## $ last_Hdist &lt;dbl&gt; 1.5 ## $ last_Hdptf &lt;dbl&gt; 11.5 ## $ last_dptf &lt;dbl&gt; 10 ## $ last_effdist &lt;dbl&gt; 0 ## $ last_lad &lt;dbl&gt; 100 what are these? treeID: tree ID with strings and numeric values treeID1: tree ID with only numeric values dptf: Depth of fuel layers (m) after considering distances greater than the actual height bin step effdist: Effective distance between consecutive fuel layers (m) after considering distances greater than any number of steps Hcbh: Base height of each fuel separated by a distance greater than the certain number of steps Hdptf: Height of the depth of fuel layers (m) after considering distances greater than the actual step Hdist: Height of the distance (&gt; any number of steps) between consecutive fuel layers (m) Hcbh_Hdptf - Percentage of LAD values comprised in each effective fuel layer maxlad_Hcbh - Height of the CBH of the segmented tree based on the maximum LAD percentage maxlad1_Hcbh - Height of the CBH from the second fuel layer when the maximum LAD occurred in the first fuel layer but its depth &lt;= “hdepth1_height” max_Hcbh - Height of the CBH of the segmented tree based on the maximum distance found in its profile last_Hcbh - Height of the CBH of the segmented tree based on the last distance found in its profile maxlad_ - Values of distance and fuel depth and their corresponding heights at the maximum LAD percentage maxlad1_ - Values of distance and fuel depth and their corresponding heights for the second fuel layer when the maximum LAD occurred in the first fuel layer but its depth &lt;= “hdepth1_height” max_ - Values of distance and fuel depth and their corresponding heights at the maximum distance last_ - Values of distance and fuel depth and their corresponding heights at the last distance nlayers - Number of effective fuel layers max_height - Maximum height of the tree profile there are also some plotting functions # Generate plots for fuels LAD metrics plots_cbh_maxlad &lt;- LadderFuelsR::get_plots_cbh_LAD( LAD_profiles = ladderfuelsr_cbh_ans$lad_profile , cbh_metrics = ladderfuelsr_cbh_ans$cbh_metrics , min_height = 0.5 ) plots_cbh_maxdist &lt;- LadderFuelsR::get_plots_cbh_maxdist( LAD_profiles = ladderfuelsr_cbh_ans$lad_profile , cbh_metrics = ladderfuelsr_cbh_ans$cbh_metrics , min_height = 0.5 ) plots_cbh_lastdist &lt;- LadderFuelsR::get_plots_cbh_lastdist( LAD_profiles = ladderfuelsr_cbh_ans$lad_profile , cbh_metrics = ladderfuelsr_cbh_ans$cbh_metrics , min_height = 0.5 ) # patchwork them (plots_cbh_maxlad[[1]] + labs(title = &quot;get_plots_cbh_LAD&quot;)) + (plots_cbh_maxdist[[1]] + labs(title = &quot;get_plots_cbh_maxdist&quot;)) + (plots_cbh_lastdist[[1]] + labs(title = &quot;get_plots_cbh_lastdist&quot;)) + patchwork::plot_layout(ncol = 2) these plots represent the three criteria to define the CBH in a segmented tree: get_plots_cbh_LAD = the fuel layer containing the maximum LAD percentage (column named maxlad_Hcbh) get_plots_cbh_maxdist = the fuel layer located at the highest distance (column named max_Hcbh) get_plots_cbh_lastdist = the fuel layer separated by the last effective distance (column named last_Hcbh) 3.2.2 CBH on the point cloud can we make a view of the CBH on the point cloud? # make a matrix to represent the cbh x_temp &lt;- seq( min(nlas_one_tree@data$X) , max(nlas_one_tree@data$X) , length.out = 2 ) y_temp &lt;- seq( min(nlas_one_tree@data$Y) , max(nlas_one_tree@data$Y) , length.out = 2 ) xy_temp &lt;- expand.grid(x = x_temp, y = y_temp) z_temp &lt;- matrix( rep( ladderfuelsr_cbh_ans$cbh_metrics$last_Hcbh , nrow(xy_temp) ) , nrow = length(x_temp), ncol = length(y_temp) ) # plot it plot3D::scatter3D( x = nlas_one_tree@data$X , y = nlas_one_tree@data$Y , z = nlas_one_tree@data$Z , colvar = nlas_one_tree@data$Z , cex = 0.3, pch = 19 , colkey = T , phi = -6 , col = harrypotter::hp(n=50, house = &quot;gryffindor&quot;) , main =&quot;CBH shown in black&quot; , surf = list( x = x_temp , y = y_temp , z = z_temp , facets = NA , border = &quot;black&quot; , lwd = 2 ) ) 3.3 Function to CBH a tree list first, an intermediate function to clip the point cloud to a polygon and run it through the ladderfuelsr_cbh() function wew defined above call_ladderfuelsr_cbh &lt;- function( id , poly_df , nlas , my_min_vhp_n , my_voxel_grain_size_m , my_dist_btwn_bins_m , my_min_fuel_layer_ht_m , my_lad_pct_gap , my_lad_pct_base , my_num_jump_steps , my_min_lad_pct , my_frst_layer_min_ht_m ){ ################################## # filter sf ################################## one_tree_sf &lt;- poly_df %&gt;% dplyr::filter(treeID==id) ################################## # clip the point cloud ################################## nlas_one_tree &lt;- lidR::clip_roi(las = nlas, geometry = one_tree_sf) %&gt;% lidR::filter_poi(!Classification %in% c(2,9,18)) %&gt;% ## class 2 = ground; 9 = water; 18 = noise lidR::add_attribute(x = id, name = &quot;treeID&quot;) ################################## # check for points ################################## if(nrow(nlas_one_tree@data)&gt;10){ # CALL ladderfuelsr_cbh ladderfuelsr_cbh_ans &lt;- ladderfuelsr_cbh( las = nlas_one_tree , treeID = id , min_vhp_n = my_min_vhp_n , voxel_grain_size_m = my_voxel_grain_size_m , dist_btwn_bins_m = my_dist_btwn_bins_m , min_fuel_layer_ht_m = my_min_fuel_layer_ht_m , lad_pct_gap = my_lad_pct_gap , lad_pct_base = my_lad_pct_base , num_jump_steps = my_num_jump_steps , min_lad_pct = my_min_lad_pct , frst_layer_min_ht_m = my_frst_layer_min_ht_m ) }else{ ladderfuelsr_cbh_ans &lt;- NULL } # build return data if(is.null(ladderfuelsr_cbh_ans$cbh_metrics)){ # blank the cbh columns df &lt;- one_tree_sf %&gt;% dplyr::mutate( cbh_maxlad_height_m = as.numeric(NA) , cbh_max_height_m = as.numeric(NA) , cbh_last_height_m = as.numeric(NA) ) }else{ df &lt;- one_tree_sf %&gt;% dplyr::mutate( cbh_maxlad_height_m = ladderfuelsr_cbh_ans$cbh_metrics$maxlad_Hcbh[1] , cbh_max_height_m = ladderfuelsr_cbh_ans$cbh_metrics$max_Hcbh[1] , cbh_last_height_m = ladderfuelsr_cbh_ans$cbh_metrics$last_Hcbh[1] ) } return(df) } let’s define a function for performing the CBH estimation over multiple trees and combining all of the data trees_cbh &lt;- function( trees_poly , norm_las = NA , tree_sample_prop = 1 , which_cbh = &quot;lowest&quot; # maxlad_Hcbh = max_lad # max_Hcbh = highest # last_Hcbh = lowest , estimate_missing_cbh = FALSE ##### LadderFuelsR # minimum vhp records # https://github.com/olgaviedma/LadderFuelsR?tab=readme-ov-file#8depurating-tree-lad-profiles , min_vhp_n = 6 # leafR::lad.voxels , voxel_grain_size_m = 2 # LadderFuelsR::get_gaps_fbhs , dist_btwn_bins_m = 1 # step , min_fuel_layer_ht_m = 1.5 # min_height , lad_pct_gap = 25 # perc_gap , lad_pct_base = 25 # perc_base # LadderFuelsR::get_real_fbh , num_jump_steps = 1 # number_steps # LadderFuelsR::get_layers_lad , min_lad_pct = 10 # threshold # LadderFuelsR::get_cbh_metrics , frst_layer_min_ht_m = 2.5 # hdepth1_height ){ ################################## # check which cbh ################################## # clean it which_cbh &lt;- dplyr::coalesce(which_cbh, &quot;lowest&quot;) which_cbh &lt;- ifelse( stringr::str_remove_all(which_cbh,&quot;\\\\s&quot;) == &quot;&quot; , &quot;lowest&quot; , which_cbh ) which_cbh &lt;- tolower(which_cbh[1]) # check it cbh_l &lt;- c(&quot;max_lad&quot;, &quot;highest&quot;, &quot;lowest&quot;) if(!which_cbh %in% cbh_l){ stop(paste0( &quot;`which_cbh` must be one of:&quot; , &quot;\\n&quot; , paste(cbh_l, collapse = &quot;, &quot;) )) } ################################## # ensure that norm las data exists ################################## nlas_msg &lt;- paste0( &quot;`norm_las` must contain a directory with nomalized las files, the path of a .laz|.las file&quot; , &quot;\\n, -or- an object of class `LAS`. Please update the `norm_las` parameter.&quot; ) if(is.na(norm_las)){stop(nlas_msg)} if(inherits(norm_las, &quot;character&quot;)){ if(!stringr::str_ends(norm_las, &quot;.*\\\\.(laz|las)$&quot;)){ # try to read directory for las files fls &lt;- list.files(normalizePath(norm_las), pattern = &quot;.*\\\\.(laz|las)$&quot;, full.names = TRUE) # stop it if no files if(length(fls)&lt;1){stop(nlas_msg)} # read it nlas_ctg &lt;- lidR::readLAScatalog(fls) # turn of lidR progress lidR::opt_progress(nlas_ctg) &lt;- F }else if(stringr::str_ends(norm_las, &quot;.*\\\\.(laz|las)$&quot;)){ # read it nlas_ctg &lt;- lidR::readLAScatalog(norm_las) # turn of lidR progress lidR::opt_progress(nlas_ctg) &lt;- F }else{ stop(nlas_msg) } }else if(inherits(norm_las, &quot;LAS&quot;)){ nlas_ctg &lt;- norm_las }else{ stop(nlas_msg) } ################################## # ensure that treeID data exists ################################## f &lt;- trees_poly %&gt;% names() if(length(f)==0){f &lt;- &quot;&quot;} if( max(grepl(&quot;treeID&quot;, f))==0 ){ stop(paste0( &quot;`trees_poly` data must contain `treeID` column to estimate missing CBH values.&quot; , &quot;\\nProvide the `treeID` as a unique identifier of individual trees.&quot; )) }else{ # check for duplicate treeID if( nrow(trees_poly) != length(unique(trees_poly$treeID)) ){ stop(&quot;Duplicates found in the treeID column. Please remove duplicates and try again.&quot;) } # ensure that treeID is numeric # generate a treeID index because it needs to be numeric for LadderFuelsR trees_poly &lt;- trees_poly %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( treeID_backup = treeID , treeID = dplyr::row_number() ) %&gt;% dplyr::relocate(treeID) } ################################## # ensure spatial polygon data ################################## sf_msg &lt;- paste0( &quot;`trees_poly` data must be an object of class `sf` with only POLYGON type.&quot; , &quot;\\nProvide an `sf` object and see `sf::st_geometry_type()`.&quot; ) if(!inherits(trees_poly, &quot;sf&quot;)){stop(sf_msg)} if( min(sf::st_is(trees_poly, type = c(&quot;POLYGON&quot;, &quot;MULTIPOLYGON&quot;))) == 0 ){stop(sf_msg)} ################################## # ensure the las and sf are same projection ################################## # get crs crs_las &lt;- sf::st_crs(nlas_ctg) crs_poly &lt;- sf::st_crs(trees_poly) # test equal epsg if( is.na(crs_las$epsg) | is.na(crs_poly$epsg) | crs_las$epsg != crs_poly$epsg ){ stop(&quot;The `trees_poly` and `norm_las` data have differing CRS projections. Please see `sf::st_crs()` and ensure compatibility.&quot;) } #################################################################### # map over ladderfuelsr_cbh function #################################################################### cbh_df &lt;- trees_poly %&gt;% dplyr::slice_sample(prop = min(as.numeric(tree_sample_prop), 1, na.rm = T)) %&gt;% dplyr::pull(treeID) %&gt;% purrr::map(\\(x) call_ladderfuelsr_cbh( id = x , poly_df = trees_poly , nlas = nlas_ctg , my_min_vhp_n = min_vhp_n , my_voxel_grain_size_m = voxel_grain_size_m , my_dist_btwn_bins_m = dist_btwn_bins_m , my_min_fuel_layer_ht_m = min_fuel_layer_ht_m , my_lad_pct_gap = lad_pct_gap , my_lad_pct_base = lad_pct_base , my_num_jump_steps = num_jump_steps , my_min_lad_pct = min_lad_pct , my_frst_layer_min_ht_m = frst_layer_min_ht_m )) %&gt;% dplyr::bind_rows() %&gt;% # get rid of treeID dplyr::mutate( treeID = treeID_backup ) %&gt;% dplyr::select(-treeID_backup) %&gt;% dplyr::relocate(treeID) %&gt;% sf::st_drop_geometry() # pick a cbh if(which_cbh == &quot;max_lad&quot;){ cbh_df &lt;- cbh_df %&gt;% dplyr::mutate( tree_cbh_m = cbh_maxlad_height_m , is_training_cbh = !is.na(cbh_maxlad_height_m) ) }else if(which_cbh == &quot;highest&quot;){ cbh_df &lt;- cbh_df %&gt;% dplyr::mutate( tree_cbh_m = cbh_max_height_m , is_training_cbh = !is.na(cbh_max_height_m) ) }else{ cbh_df &lt;- cbh_df %&gt;% dplyr::mutate( tree_cbh_m = cbh_last_height_m , is_training_cbh = !is.na(cbh_last_height_m) ) } # get rid of treeID trees_poly &lt;- trees_poly %&gt;% dplyr::mutate(treeID = treeID_backup) %&gt;% dplyr::select(-treeID_backup) %&gt;% dplyr::relocate(treeID) # ensure that there are enough data to estimate n_cbh &lt;- cbh_df %&gt;% dplyr::filter(is_training_cbh==T) %&gt;% nrow() # ensure that tree height data exists f &lt;- trees_poly %&gt;% names() if(length(f)==0){f &lt;- &quot;&quot;} ############################################# # check for estimate missing ############################################# if( estimate_missing_cbh==T &amp; n_cbh &gt; 10 &amp; max(grepl(&quot;tree_height_m&quot;, f))==1 ){ # add x,y to data mod_df &lt;- trees_poly %&gt;% dplyr::left_join( cbh_df %&gt;% dplyr::select(treeID, tree_cbh_m, is_training_cbh) , by = &quot;treeID&quot; ) %&gt;% dplyr::mutate(is_training_cbh = dplyr::coalesce(is_training_cbh, F)) %&gt;% dplyr::select(treeID, tree_height_m, tree_cbh_m, is_training_cbh) %&gt;% sf::st_centroid() %&gt;% dplyr::mutate( tree_xxx = sf::st_coordinates(.)[,1] , tree_yyy = sf::st_coordinates(.)[,2] , crown_area_zzz = sf::st_area(.) , tree_height_m = as.numeric(tree_height_m) , tree_cbh_m = as.numeric(tree_cbh_m) ) %&gt;% sf::st_drop_geometry() # training versus predict data training_df &lt;- mod_df %&gt;% dplyr::filter(is_training_cbh==T) %&gt;% dplyr::select(-is_training_cbh) predict_df &lt;- mod_df %&gt;% dplyr::filter(is_training_cbh==F) %&gt;% dplyr::select(-is_training_cbh) ### tuning RF model # If we are interested with just starting out and tuning the mtry parameter # we can use randomForest::tuneRF for a quick and easy tuning assessment. # tuneRf will start at a value of mtry that you supply and increase by a # certain step factor until the OOB error stops improving be a specified amount. # quiet this quiet_tuneRF &lt;- purrr::quietly(randomForest::tuneRF) # run it rf_tune_temp &lt;- quiet_tuneRF( # randomForest::tuneRF( y = training_df$tree_cbh_m , x = training_df %&gt;% dplyr::select(-c(treeID,tree_cbh_m)) , stepFactor = 0.5 , ntreeTry = 200 , mtryStart = 0.5 , improve = 0.01 , plot = F , trace = F ) # just get the result rf_tune_temp &lt;- rf_tune_temp$result # Extract the optimal mtry value optimal_mtry &lt;- rf_tune_temp %&gt;% dplyr::as_tibble() %&gt;% dplyr::filter(OOBError==min(OOBError)) %&gt;% dplyr::filter(dplyr::row_number() == 1) %&gt;% dplyr::pull(mtry) # ensure that the mtry value is not greater than the number of predictors optimal_mtry &lt;- min( optimal_mtry , ncol( training_df %&gt;% dplyr::select(-c(treeID,tree_cbh_m)) ) ) ### Run a randomForest model to predict DBH using various crown predictors cbh_mod &lt;- randomForest::randomForest( y = training_df$tree_cbh_m , x = training_df %&gt;% dplyr::select(-c(treeID,tree_cbh_m)) , mtry = optimal_mtry , na.action = na.omit ) # # model # cbh_mod &lt;- stats::lm( # formula = tree_cbh_m ~ tree_xxx + tree_yyy + tree_xxx:tree_yyy + tree_height_m + crown_area_zzz # , data = training_df # ) # predict missing predicted_cbh_temp &lt;- predict( cbh_mod , predict_df %&gt;% dplyr::select(-c(treeID,tree_cbh_m)) ) %&gt;% dplyr::as_tibble() %&gt;% dplyr::pull(1) ## combine predicted data with training data for full data set trees_poly &lt;- trees_poly %&gt;% # join with training data estimates dplyr::left_join( cbh_df %&gt;% dplyr::filter(is_training_cbh==T) %&gt;% dplyr::select(treeID, tree_cbh_m, is_training_cbh) , by = &quot;treeID&quot; ) %&gt;% dplyr::mutate(is_training_cbh = dplyr::coalesce(is_training_cbh, F)) %&gt;% # join with predicted data estimates dplyr::left_join( predict_df %&gt;% dplyr::mutate( predicted_cbh = predicted_cbh_temp ) %&gt;% dplyr::select(treeID, predicted_cbh) , by = dplyr::join_by(&quot;treeID&quot;) ) %&gt;% # clean up data dplyr::mutate( tree_cbh_m = dplyr::coalesce(tree_cbh_m, predicted_cbh) ) %&gt;% dplyr::select(-predicted_cbh) ## prevent the CBH from being &gt; the tree height # find the 95th percentile of height-cbh ratio max_ratio &lt;- cbh_df %&gt;% dplyr::filter( is_training_cbh==T &amp; tree_cbh_m &lt; tree_height_m ) %&gt;% dplyr::mutate(ratio = tree_cbh_m/tree_height_m) %&gt;% dplyr::pull(ratio) %&gt;% stats::quantile(probs = 0.95) # update values trees_poly &lt;- trees_poly %&gt;% dplyr::mutate( # update training data where tree_cbh_m &gt; tree_height_m is_training_cbh = dplyr::case_when( is_training_cbh==T &amp; tree_cbh_m &gt;= tree_height_m ~ FALSE , T ~ is_training_cbh ) # update tree_cbh_m , tree_cbh_m = dplyr::case_when( is_training_cbh==F &amp; tree_cbh_m/tree_height_m &gt; max_ratio ~ max_ratio*tree_height_m , T ~ tree_cbh_m ) ) }else if(estimate_missing_cbh==T){ if(max(grepl(&quot;tree_height_m&quot;, f))==0){ message(paste0( &quot;`trees_poly` data must contain `tree_height_m` column to estimate CBH.&quot; , &quot;\\nSetting `estimate_missing_cbh=TRUE` requires this data.&quot; , &quot;\\nReturning CBH values extracted from cloud only.&quot; )) }else{ message(paste0( &quot;Insufficient data available to estimate missing CBH values.&quot; , &quot;\\nReturning CBH values extracted from cloud only.&quot; )) } ## combine predicted data with training data for full data set trees_poly &lt;- trees_poly %&gt;% # join with training data estimates dplyr::left_join( cbh_df %&gt;% dplyr::filter(is_training_cbh==T) %&gt;% dplyr::select(treeID, tree_cbh_m, is_training_cbh) , by = &quot;treeID&quot; ) %&gt;% dplyr::mutate(is_training_cbh = dplyr::coalesce(is_training_cbh, F)) }else{ ## combine predicted data with training data for full data set trees_poly &lt;- trees_poly %&gt;% # join with training data estimates dplyr::left_join( cbh_df %&gt;% dplyr::filter(is_training_cbh==T) %&gt;% dplyr::select(treeID, tree_cbh_m, is_training_cbh) , by = &quot;treeID&quot; ) %&gt;% dplyr::mutate(is_training_cbh = dplyr::coalesce(is_training_cbh, F)) } # return return(trees_poly) # return(list( # trees_poly = trees_poly # , cbh_mod = cbh_mod # )) } Test it and set the parameters based on recommendations from the literature (alternatively, we could keep the default parameter settings) With respect to the the voxel_grain_size_m parameter (see grain.size in leafR::lad.voxels()): In general, the LAD and LAI estimates tended to stabilize with an increasing grain size and increasing ALS pulse density. At small grain sizes of 1 m, 2 m, and 5 m, absolute LAD profiles became stable at respective pulse densities of 15, 15, and 10 pulses per m2…the lower accuracy particularly of the LAD profile estimation at a coarse grain size or at low pulse densities may be unacceptable for some applications, particularly in models and methods that rely on the fine scale vertical and horizontal heterogeneity of the canopy structure to make ecological inferences. Examples include the estimation of timber stock or demographic structure or light interception and absorption…For these applications our results suggest that pulse densities of 20 pulses per m2 or greater and grain sizes between 2 and 5 m, which maximize accuracy and stability, should be utilized. (de Almeida et al., 2019, p. 9-10) …however the documentation of leafR::lad.voxels() recommends “1 meter for lad profiles” Regarding the min_fuel_layer_ht_m parameter (see min_height in LadderFuelsR::get_gaps_fbhs()): The LAD strata estimated from both ALS and ground lidar were limited to pulse returns above one meter from the ground. This avoids ground-return interference in the ALS data and is also imposed by the ground lidar sensor height. (de Almeida et al., 2019, p. 6) Finally, for the frst_layer_min_ht_m parameter (see hdepth1_height in LadderFuelsR::get_cbh_metrics()): In the case of maximum LAD (%), the output also gives the CBH from the second fuel layer when the first one has the maximum LAD (%) but its depth is smaller than the value indicated in the parameter “hdepth1_height” (default 2 m). (Viedma et al. 2024, p. 8) and from the package: If the first fuel layer has the maximum LAD and its depth is greater than the indicated value, then this fuel layer is considered as the CBH of the tree. On the contrary, if its depth is &lt;= the value, the CBH with maximum LAD will be the second fuel layer, although it has not the maximum LAD. We’ll leave all of the other values at their default trees_cbh_ans &lt;- trees_cbh( trees_poly = cloud2trees_ans$crowns_sf , norm_las = &quot;../data/point_cloud_processing_temp/02_normalize/&quot; # pull this from create_project_structure.R , tree_sample_prop = .4 , estimate_missing_cbh = T , which_cbh = &quot;lowest&quot; , min_vhp_n = 4 # = 2.5m with min_fuel_layer_ht_m=1 and dist_btwn_bins_m = 0.5 , min_fuel_layer_ht_m = 1 # default = 1.5 , dist_btwn_bins_m = 0.5 # default = 1 , num_jump_steps = 0.5 # default = 1 , frst_layer_min_ht_m = 0.5 # default = 2.5 ) what? trees_cbh_ans %&gt;% dplyr::glimpse() ## Rows: 229 ## Columns: 22 ## $ treeID &lt;chr&gt; &quot;1_458833.4_4450240.6&quot;, &quot;2_458858.1_4450240.… ## $ tree_height_m &lt;dbl&gt; 11.030, 8.124, 7.659, 8.306, 7.471, 9.758, 5… ## $ tree_x &lt;dbl&gt; 458833.4, 458858.1, 458839.6, 458854.6, 4588… ## $ tree_y &lt;dbl&gt; 4450241, 4450241, 4450240, 4450240, 4450240,… ## $ crown_area_m2 &lt;dbl&gt; 6.5000, 1.6250, 1.3125, 1.3750, 4.3750, 2.81… ## $ fia_est_dbh_cm &lt;dbl&gt; 16.343596, 11.664241, 11.025794, 12.016107, … ## $ fia_est_dbh_cm_lower &lt;dbl&gt; 9.274637, 6.556701, 6.186752, 6.789626, 6.06… ## $ fia_est_dbh_cm_upper &lt;dbl&gt; 25.114865, 18.022694, 16.908300, 18.607822, … ## $ dbh_cm &lt;dbl&gt; 16.343596, 11.664241, 11.025794, 12.016107, … ## $ is_training_data &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA… ## $ dbh_m &lt;dbl&gt; 0.16343596, 0.11664241, 0.11025794, 0.120161… ## $ radius_m &lt;dbl&gt; 0.08171798, 0.05832120, 0.05512897, 0.060080… ## $ basal_area_m2 &lt;dbl&gt; 0.020979016, 0.010685697, 0.009547939, 0.011… ## $ basal_area_ft2 &lt;dbl&gt; 0.22581813, 0.11502084, 0.10277402, 0.122064… ## $ ptcld_extracted_dbh_cm &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ ptcld_predicted_dbh_cm &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ comp_trees_per_ha &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ comp_relative_tree_height &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ comp_dist_to_nearest_m &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ tree_cbh_m &lt;dbl&gt; 3.201873, 3.508099, 3.675167, 5.500000, 3.69… ## $ is_training_cbh &lt;lgl&gt; FALSE, FALSE, FALSE, TRUE, FALSE, TRUE, FALS… ## $ geom &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((458832 4450...,… let’s view the height versus CBH relationship by training data trees_cbh_ans %&gt;% ggplot(aes(x = tree_height_m, y = tree_cbh_m, color = is_training_cbh)) + geom_point(size = 3, alpha = 0.8) + harrypotter::scale_color_hp_d(&quot;ronweasley&quot;, direction = -1) + scale_y_continuous(breaks = scales::breaks_extended(12)) + scale_x_continuous(breaks = scales::breaks_extended(12)) + labs(y = &quot;CBH (m)&quot;, x = &quot;Height (m)&quot;, color = &quot;is training data&quot;) + theme_light() + theme(legend.position = &quot;top&quot;) check out the CBH spatially trees_cbh_ans %&gt;% ggplot(aes(color = is_training_cbh, fill = tree_cbh_m)) + geom_sf(lwd = 0.8) + harrypotter::scale_color_hp_d(&quot;ronweasley&quot;, direction = -1) + harrypotter::scale_fill_hp(&quot;always&quot;) + labs(fill = &quot;CBH (m)&quot;, color = &quot;is training data&quot;) + theme_light() + theme(legend.position = &quot;top&quot;, axis.text = element_blank()) + guides( color = guide_legend(order = 1, override.aes = list(lwd = 3, fill = NA)) ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
