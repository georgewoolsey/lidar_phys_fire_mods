# Species Process{#s03}

In this section we'll use the benchmark data made available in the [`NeonTreeEvaluation`](https://github.com/weecology/NeonTreeEvaluation_package) data set ([Weinstein et al. 2021](https://scholar.google.com/scholar?cluster=4986448711981898434&hl=en&as_sdt=0,6)) to test a simple process for classifying the species of the trees extracted using lidar-based tree detection methods. 

The majority of research on classifying individual trees into different species categories using point cloud data from lidar or structure from motion data follows a similar process. This process generally involves segmenting individual trees and extracting key features from each tree using the point cloud, selecting the most relevant features, and training a machine learning model on a training dataset of trees with known species identities to classify tree species ([Seidel et al. 2021](https://doi.org/10.3389/fpls.2021.635440); [Meng et al. 2024](https://doi.org/10.3390/f15122110)). Such a process would require training data that may not be available in an easily accessible format over a broad extent (excepting FIA data, maybe?) which would be required for a general purpose process which we aim to define in the present research study. Instead, we will use a more simplistic process which uses the USFS Forest Type Groups of the Continental United States dataset Wilson (2023) available online [here](https://di-usfsdata.img.arcgis.com/arcgis/rest/services/CONUS_forest_type_group_2018_masked_202105122120120/ImageServer) with a data overview [here](https://www.arcgis.com/home/item.html?id=10760c83b9e44923bd3c18efdaa7319d) to attach the tree species group to individual trees detected from the point cloud data based on spatial location. At the time of this analysis the Wilson (2023) dataset was last updated on Oct 18, 2023 and depicts forest type groups for the Continental United States created from USFS Forest Inventory & Analysis plot data collected from 2014-2018. This forest type groups dataset provides a broad classification of forest types at a 30-meter resolution and is preferable for our objective to the older, coarser ([Ruefenacht et al. 2008](https://doi.org/10.14358/PERS.74.11.1379)) dataset available at [https://data.fs.usda.gov/geodata/rastergateway/forest_type/](https://data.fs.usda.gov/geodata/rastergateway/forest_type/).

Here, we'll outline the process to attach forest type group to the tree list based on the Forest Type Groups dataset. As a second option, we could utilize the TreeMap FIA data from [Riley et al. (2021)](https://doi.org/10.2737/RDS-2021-0074) to build a [softmax regression (i.e. multinomial logistic regression)](https://bookdown.org/content/3686/nominal-predicted-variable.html) to predict the nominal variable tree species using the predictors tree height and location extracted from the point cloud data. This option roughly follows the process most represented in the existing literature as detailed above. Note that to predict the nominal variable tree species we could also use a random forest classifier as in [Meng et al. (2024)](https://doi.org/10.3390/f15122110). The ultimate goal is to incorporate this process in the [`cloud2trees`](https://github.com/georgewoolsey/cloud2trees) package (Woolsey and Tinkham, 2024).

First, load the standard libraries

```{r, warning=FALSE, message=FALSE}
# bread-and-butter
library(tidyverse) # the tidyverse
library(viridis) # viridis colors
library(harrypotter) # hp colors
library(RColorBrewer) # brewer colors
library(scales) # work with number and plot scales
library(latex2exp)

# visualization
library(mapview) # interactive html maps
library(kableExtra) # tables
library(patchwork) # combine plots
library(ggnewscale) # ggnewscale
library(rgl) # rgl plotting

# spatial analysis
library(terra) # raster
library(sf) # simple features
library(lidR) # lidar data
library(cloud2trees) # tha cloud2trees
library(NeonTreeEvaluation) # benchmark data

# models
library(brms) # bayesian modelling

# utilities
library(rvest) # web scraping
```

```{r, include=F, warning=F, message=F}
# knit options
knitr::opts_chunk$set(
  echo = TRUE
  , warning = FALSE
  , message = FALSE
  # , results = 'hide'
  , fig.width = 10.5
  , fig.height = 7
)
# option to put satellite imagery as base layer of mapview maps
  mapview::mapviewOptions(
    homebutton = FALSE
    # , basemaps = c("Esri.WorldImagery","OpenStreetMap")
    , basemaps = c("Esri.WorldImagery", "OpenStreetMap")
  )
# clean session
remove(list = ls())
gc()
```

## Example Lidar Data{#rmnp_ex}

Let's load an example lidar dataset from Weinstein et al. ([2021](https://scholar.google.com/scholar?cluster=4986448711981898434&hl=en&as_sdt=0,6)) in their `NeonTreeEvaluation` package.

We'll use data from a NEON site that we know has conifers: RMNP (Rocky Mountain National Park)

```{r}
# let's see some field trees data
NeonTreeEvaluation::field %>% 
  dplyr::filter(siteID == "RMNP") %>% 
  dplyr::count(taxonID) %>% 
  dplyr::arrange(desc(n))
```

let's pick a site with the lowest proportion of POTR5

```{r}
plots_temp <- NeonTreeEvaluation::field %>% 
  dplyr::filter(siteID == "RMNP") %>% 
  dplyr::group_by(plotID) %>% 
  dplyr::summarise(
    trees = dplyr::n()
    , conifers = sum(ifelse(taxonID=="POTR5", 0, 1))
  ) %>% 
  dplyr::mutate(pct_conifer = conifers/trees) %>% 
  dplyr::filter(trees>20) %>% 
  dplyr::arrange(desc(pct_conifer), desc(trees))
plots_temp
```

look at the tree data for this plot

```{r}
NeonTreeEvaluation::field %>% 
  dplyr::filter(plotID == plots_temp[1,]$plotID) %>% 
  dplyr::count(taxonID, scientificName)
```

get the lidar data

```{r}
# get the laz file path
las_f_path_temp <- paste0(system.file(package = "NeonTreeEvaluation"),"/extdata/") %>% 
    list.files(recursive = T, pattern = ".*\\.(laz|las)$", full.names = T) %>% 
    unique() %>% 
    dplyr::as_tibble() %>%
    dplyr::rename(f_path = 1) %>% 
    dplyr::filter(
      stringr::str_detect(f_path,  as.character(plots_temp[1,]$plotID))
    ) %>% 
    .[1] %>% 
    dplyr::pull(f_path)
# check the data
lidR::readLAS(las_f_path_temp)
```

### `cloud2trees` that lidar data

extract trees from the lidar data using `cloud2trees`

we do not need to get DBH or CBH for this testing

```{r, message=FALSE, results=FALSE}
cloud2trees_ans <- cloud2trees::cloud2trees(
  input_las_dir = las_f_path_temp
  , output_dir = tempdir()
  , estimate_tree_dbh = F
  , estimate_tree_cbh = F
)
```

```{r, include=F, eval=T}
cloud2trees_ans$treetops_sf <- cloud2trees_ans$treetops_sf %>% 
  dplyr::select( -dplyr::any_of(c(
        "hey_xxxxxxxxxx"
        , "forest_type_group_code"
        , "forest_type_group"
        , "hardwood_softwood"
      )))
cloud2trees_ans$crowns_sf <- cloud2trees_ans$crowns_sf %>% 
  dplyr::select( -dplyr::any_of(c(
        "hey_xxxxxxxxxx"
        , "forest_type_group_code"
        , "forest_type_group"
        , "hardwood_softwood"
      )))
```


let's see what we got

```{r}
cloud2trees_ans$treetops_sf %>% dplyr::glimpse()
```

where is this?

```{r}
# where?
cloud2trees_ans$treetops_sf %>% 
  mapview::mapview(layer.name = "trees")
```

*zoom out if you can't see anything*

## USFS National Forest Type Group dataset

Download the USFS National Forest Type Group dataset (Wilson 2023) available online [here](https://di-usfsdata.img.arcgis.com/arcgis/rest/services/CONUS_forest_type_group_2018_masked_202105122120120/ImageServer) with a data overview [here](https://www.arcgis.com/home/item.html?id=10760c83b9e44923bd3c18efdaa7319d) to attach the tree species group to individual trees detected from the point cloud data based on spatial location. At the time of this analysis the Wilson (2023) dataset was last updated on Oct 18, 2023 and depicts forest type groups for the Continental United States created from USFS Forest Inventory & Analysis plot data collected from 2014-2018. This forest type groups dataset provides a broad classification of forest types at a 30-meter resolution to attach the tree species group to individual trees detected from the point cloud data based on spatial location.

Here, we'll outline the process to attach forest type group to the tree list based on the Forest Type Groups dataset.

### Get the data

define a function to download the data

*!!!The download function `get_foresttype_raw()` below works great...however, there is a hard limitation on the image api service with respect to maximum download limits. Attempting to get the entire extent of the data results in a downscaling from 30x30 m resolution to 808x808m resolution. Attempting to download the extent in chunks gets us closer to the native resolution (~50-100 m) but requires that the service returns the data without error for ~300-900 chunks; this process is ripe for error. As such, I resorted to utilizing the image service within ArcGIS Pro and used the following steps:*

* connect to the image service via the "Open in ArcGIS Desktop" at the [data source](https://www.arcgis.com/home/item.html?id=10760c83b9e44923bd3c18efdaa7319d)
* to get around the image service data limits, aggregate the raster to 90x90 m resolution in chunks
    + open the Aggregate tool (Spatial Analyst tools)
    + in the "Environments" tab change the extent to process in chunks
    + chunk 1 in the "Environments" tab change the Extent "X and Y Extent" (t,l,r,b): 6868893.686445,-14469331.213417,-10383464.5467503,2480613.686445
    + in the "Parameters" tab set the "Cell factor" to 3 with "Aggregation technique" to maximum (to prefer any data to no data which is coded as 0), everything else is default
    + run the tool (this took 71 mins across 6 parallel instances for 1 chunk)
    + export the raster layer as a .tif
    + repeat for chunk 2 in the "Environments" tab change the Extent "X and Y Extent" (t,l,r,b): 6868893.686445,-10383464.5467503,-7114771.213417,2480613.686445
    + Use the "Mosaic to New Raster" tool to combine the chunks using the maximum "Mosaic Operator" with a "Pixel Type" of 16-bit unsigned and 1 for "Number of Bands"
    + export the raster layer as a .tif
    + upload to [Zenodo](https://doi.org/10.5281/zenodo.14338873)
* we'll then define a download process to get our aggregated (90x90 m) forest type raster from [Zenodo](https://doi.org/10.5281/zenodo.14338873)

Even though this process is inefficient and manual (i.e. painful), it is preferable to using the the USFS Forest Type Groups of the Continental United States dataset ([Ruefenacht et al. 2008](https://doi.org/10.14358/PERS.74.11.1379)) which is older, coarser in resolution (250x250 m), and uses a custom projection system that does not have a well-known EPSG available in the `terra` and `sf` packages. Endure the pain once, the grass may be greener on the other side.

#### Get raw data

Not used but works (see discussion above). This function pulls the data directly from the image server.

```{r, include=TRUE, eval=FALSE}
# this is for: 
#   Wilson, B. T. (2021). 
#   Available online at: https://di-usfsdata.img.arcgis.com/arcgis/rest/services/CONUS_forest_type_group_2018_masked_202105122120120/ImageServer 
#   with a data overview at: https://www.arcgis.com/home/item.html?id=10760c83b9e44923bd3c18efdaa7319d

get_foresttype_raw <- function(savedir=NULL,force=F){
  #Store users timeout options
  timeout_option_backup <- getOption("timeout")
  options(timeout = max(3600, getOption("timeout")))

  if(is.null(savedir)){
    # create dir
    dir.create(paste0(system.file(package = "cloud2trees"),"/extdata"), showWarnings = FALSE)
    # names
    dirname <- paste0(system.file(package = "cloud2trees"),"/extdata/foresttype")
    destination <- file.path(dirname,"foresttype.tif")
  }else{
    dirname <- file.path(savedir,"foresttype")
    destination <- file.path(dirname,"foresttype.tif")
  }
  # create dir
  dir.create(dirname, showWarnings = FALSE)

  #check if already exists.
  f <- tolower(list.files(dirname))
  if(length(f)==0){f <- ""}
  if(
    max(grepl("foresttype.tif", f))==1
  ){
    if(!force){
      warning(paste("Data has already been downloaded to",dirname,", use force=T to overwrite"))
      return(NULL)
    }
  }

  # url
  # # math to set the size parameter
  # map_ext <- c(-1.4469E7,2480613,-7114771,6868893)
  # (w <- map_ext[3]-map_ext[1])
  # (h <- map_ext[4]-map_ext[2])
  # c(w,h) %>% `*`(.001137) %>% round() # this returns the w,h to enter for size
  
  # exporting the entire image at a resolution better than 808x808 is not possible with the image server data limits
  # let's try chunking up the area, downloading tiles, then mosaicing to get a better resolution
  # math to set the size parameter
  map_ext <- c(-1.4469E7,2480613,-7114771,6868893)
  (w <- map_ext[3]-map_ext[1])
  (h <- map_ext[4]-map_ext[2])
  
  # this returns the w,h to enter for size parameter
  # c(w,h) %>% `*`(.001137) %>% round() %>% paste(collapse = ",") # this returns the w,h to enter for size..best
  size_temp <- c(w,h) %>% 
    `*`(.0007) %>% 
    round() %>% 
    paste(collapse = "%2C") # paste(collapse = ",") 
  
  # chunk this
  # x combinations
    x_l <- dplyr::tibble(
        xmin = seq(from = map_ext[1], to = map_ext[3], length.out = 15)
      ) %>%
      dplyr::mutate(xmax = dplyr::lead(xmin, n = 1)) %>%
      dplyr::filter(!is.na(xmax))
  # y combinations
    y_l <- dplyr::tibble(
        ymin = seq(from = map_ext[2], to = map_ext[4], length.out = 15)
      ) %>%
      dplyr::mutate(ymax = dplyr::lead(ymin, n = 1)) %>%
      dplyr::filter(!is.na(ymax))
  # combine
  chunk_df <- tidyr::crossing(x_l,y_l) %>%
    dplyr::mutate(
      w = xmax - xmin
      , h = ymax - ymin
    )
  
  # chunk_df %>% dplyr::glimpse()
  # chunk_df %>%
  #   dplyr::mutate(n = dplyr::row_number()) %>%
  #   ggplot() +
  #   geom_rect(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = as.factor(n)), color = "black") +
  #   theme(legend.position = "none")
  
  # function to build the api string and download
  dl_ans <- 1:nrow(chunk_df) %>% 
    purrr::map(function(x){
      # get the bounding box string
      bb_temp <- chunk_df %>%
        dplyr::select(xmin,ymin,xmax,ymax) %>%
        dplyr::filter(dplyr::row_number() == x) %>%
        c() %>% 
        unlist() %>% 
        paste(collapse = "%2C") # paste(collapse = ",")    
      # buld url
      eval_url <- paste0(
        "https://di-usfsdata.img.arcgis.com/arcgis/rest/services/CONUS_forest_type_group_2018_masked_202105122120120/ImageServer/exportImage?bbox="
        , bb_temp # "-1.4469E7%2C2480613%2C-7114771%2C6868893"
        , "&bboxSR=&size="
        , size_temp # "8362%2C4989"
        , "&imageSR=&time=&format=tiff&pixelType=U16&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=RSP_BilinearInterpolation&compression=None&compressionQuality=&bandIds=&sliceId=&mosaicRule=&renderingRule=&adjustAspectRatio=true&validateExtent=false&lercVersion=1&compressionTolerance=&f=html" 
      )
      # now we have to parse the url return because this server creates a unique token for each request
      html <- rvest::read_html(x = eval_url)
      # get parent element
      chrs <- html %>% rvest::html_elements("a")
      # unnest children elements
      iii <- chrs %>% rvest::html_text2() %>% purrr::detect_index(function(x) tolower(x) == "download image")
      # download url
      dl_url <- chrs[iii] %>% html_attr("href")
      
      # get it
      chunk_dest <- file.path(dirname, paste0("chunk_",x,".tif"))
      message(paste("Downloading file to",chunk_dest))
      download.file(dl_url, chunk_dest, mode = "wb")
    })

  options(timeout = timeout_option_backup)
  
  return(dl_ans)
}
```

#### Get cleaned data

This function downloads the cleaned data from the [Zenodo](https://doi.org/10.5281/zenodo.14338873) archive

```{r, include=T, eval=F}
# this is for: [Wilson 2023](https://www.arcgis.com/home/item.html?id=10760c83b9e44923bd3c18efdaa7319d))
# The Forest Type Groups dataset provides a broad classification of forest types at a 30-meter resolution 

get_foresttype <- function(savedir=NULL,force=F){
  #Store users timeout options
  timeout_option_backup <- getOption("timeout")
  options(timeout = max(3600, getOption("timeout")))
  
  ## directory names
  if(is.null(savedir)){
    # create dir
    dir.create(paste0(system.file(package = "cloud2trees"),"/extdata"), showWarnings = FALSE)
    # names
    dirname <- paste0(system.file(package = "cloud2trees"),"/extdata/foresttype")
    destination <- file.path(dirname,"foresttype.zip")
  }else{
    dirname <- file.path(savedir,"foresttype")
    destination <- file.path(dirname,"foresttype.zip")
  }
  # create dir
  dir.create(dirname, showWarnings = FALSE)
  #check if already exists.
  f_dir <- file.path(dirname(destination))
  # f_dir <- paste0(system.file("extdata", "foresttype/", package = "cloud2trees"))
  f <- tolower(list.files(f_dir))
  if(length(f)==0){f <- ""}
  if(
    max(grepl("foresttype_lookup.csv", f))==1 && max(grepl("foresttype.tif", f))==1
  ){
    if(!force){
      warning(paste("Data has already been downloaded to",dirname,", use force=T to overwrite"))
      return(NULL)
    }
  }

  # get data
    # published to zenodo here:
      # https://doi.org/10.5281/zenodo.14338873
      
    # download link
      # https://zenodo.org/records/14338874/files/foresttype.zip?download=1
      # https://zenodo.org/records/14343811/files/foresttype.zip?download=1
  eval_url <- "https://zenodo.org/records/14343811/files/foresttype.zip?download=1"
  message(paste("Downloading file to",destination))
  download.file(eval_url, destination, mode = "wb")
  
  # unzip
  unzip_download(destination)

  options(timeout = timeout_option_backup)
}
## unzip function
unzip_download <- function(destination){
  #location of unzip
  base_dir <- dirname(destination)
  
  #get file names
  unzip(destination, exdir=base_dir)

  #Force delete of any previous folder
  unlink(destination,recursive = T)
}
```

call the function to download the data

```{r}
# define dl dir
savedir_temp <- "../data/"
```

```{r}
# what dirs do we have already?
list.dirs(savedir_temp, recursive = F)

# get the data
cloud2trees::get_foresttype(savedir = savedir_temp)
## get_foresttype_raw(savedir = savedir_temp) # if want to test the raw image extraction

# now what dirs?
list.dirs(savedir_temp, recursive = F)

# are there files in the foresttype dir?
list.files(file.path(savedir_temp, "foresttype"))
```

```{r, include=FALSE, eval=FALSE}
##### if used the get_foresttype_raw() 
##### saving to chronicle the struggle

# now we have to stitch this data together in a mosaic
  ## read list of rasters
  rast_list_temp <- list.files(
      file.path(savedir_temp, "foresttype")
      , pattern = "chunk_.*\\.(tif|tiff)$", full.names = T
    )[] %>% 
    purrr::map(function(x){terra::rast(x)})
  
  ## mosaic the raster list 
    Sys.time()
    quiet_mosaic <- purrr::quietly(terra::mosaic)
    rast_temp <- quiet_mosaic(
      terra::sprc(rast_list_temp)
      , fun = "max" # takes the highest forest type 
        # selecting max to prefer any forest type (numbered 100:999) to none (0)
    )
    rast_temp
    
  ## write the mosaic
    ### !!!!! this takes forevvveerrrrr
    
    terra::writeRaster(
      rast_temp
      , filename = file.path(savedir_temp, "foresttype", "foresttype.tif")
      , overwrite = T
    )
    Sys.time()
```

### Check the raster

let's check this data

```{r}
foresttype <- terra::rast(
  file.path(savedir_temp, "foresttype", "foresttype.tif")
)
# what?
foresttype
# layers?
terra::names(foresttype)
# resolution
terra::res(foresttype)
# crs?
terra::crs(foresttype)
```

what does this cover?

```{r}
# the projection is not carried over when going from spatextent to vector
crs_temp <- terra::crs(foresttype, describe = T)
epsg_temp <- paste(crs_temp$authority[1], crs_temp$code[1], sep = ":")
# where is this?
terra::ext(foresttype) %>% 
  terra::vect() %>% 
  sf::st_as_sf() %>%
  sf::st_set_crs(epsg_temp) %>%
  mapview::mapview()
```

quick map

```{r}
terra::plot(foresttype)
```

let's check the values

```{r}
terra::freq(foresttype) %>% 
  dplyr::arrange(desc(count)) %>% 
  dplyr::slice_head(n = 12)
```

### Forest type group data

let's create a lookup table of these forest type groups using the data table from [Woudenberg et al. (2010; Appendix D)](https://scholar.google.com/scholar?cluster=15231222224736651671&hl=en&as_sdt=0,6) 

```{r}
foresttype_lookup <- 
  c(
    100, "White / red / jack pine group",
    101, "Jack pine",
    102, "Red pine",
    103, "Eastern white pine",
    104, "Eastern white pine / eastern hemlock",
    105, "Eastern hemlock",
    120, "Spruce / fir group",
    121, "Balsam fir",
    122, "White spruce",
    123, "Red spruce",
    124, "Red spruce / balsam fir",
    125, "Black spruce",
    126, "Tamarack",
    127, "Northern white-cedar",
    128, "Fraser fir",
    129, "Red spruce / Fraser fir",
    140, "Longleaf / slash pine group",
    141, "Longleaf pine",
    142, "Slash pine",
    150, "Tropical pine group",
    151, "Tropical pines",
    160, "Loblolly / shortleaf pine group",
    161, "Loblolly pine",
    162, "Shortleaf pine",
    163, "Virginia pine",
    164, "Sand pine",
    165, "Table mountain pine",
    166, "Pond pine",
    167, "Pitch pine",
    168, "Spruce pine",
    170, "Other eastern softwoods group",
    171, "Eastern redcedar",
    172, "Florida softwoods",
    180, "Pinyon / juniper group",
    182, "Rocky Mountain juniper",
    184, "Juniper woodland",
    185, "Pinyon / juniper woodland",
    200, "Douglas-fir group",
    201, "Douglas-fir",
    202, "Port-Orford-cedar",
    203, "Bigcone Douglas-fir ",
    220, "Ponderosa pine group",
    221, "Ponderosa pine",
    222, "Incense-cedar",
    224, "Sugar pine",
    225, "Jeffrey pine",
    226, "Coulter pine",
    240, "Western white pine group",
    241, "Western white pine",
    260, "Fir / spruce / mountain hemlock group",
    261, "White fir",
    262, "Red fir",
    263, "Noble fir",
    264, "Pacific silver fir",
    265, "Engelmann spruce",
    266, "Engelmann spruce / subalpine fir",
    267, "Grand fir",
    268, "Subalpine fir",
    269, "Blue spruce",
    270, "Mountain hemlock",
    271, "Alaska-yellow-cedar",
    280, "Lodgepole pine group",
    281, "Lodgepole pine",
    300, "Hemlock / Sitka spruce group",
    301, "Western hemlock",
    304, "Western redcedar",
    305, "Sitka spruce",
    320, "Western larch group",
    321, "Western larch",
    340, "Redwood group",
    341, "Redwood",
    342, "Giant sequoia",
    360, "Other western softwoods group",
    361, "Knobcone pine",
    362, "Southwestern white pine",
    363, "Bishop pine",
    364, "Monterey pine",
    365, "Foxtail pine / bristlecone pine",
    366, "Limber pine",
    367, "Whitebark pine",
    368, "Miscellaneous western softwoods",
    369, "Western juniper",
    370, "California mixed conifer group",
    371, "California mixed conifer",
    380, "Exotic softwoods group",
    381, "Scotch pine",
    383, "Other exotic softwoods",
    384, "Norway spruce",
    385, "Introduced larch",
    390, "Other softwoods group",
    391, "Other softwoods",
    400, "Oak / pine group",
    401, "Eastern white pine / northern red oak / white ash",
    402, "Eastern redcedar / hardwood",
    403, "Longleaf pine / oak",
    404, "Shortleaf pine / oak",
    405, "Virginia pine / southern red oak",
    406, "Loblolly pine / hardwood",
    407, "Slash pine / hardwood",
    409, "Other pine / hardwood",
    500, "Oak / hickory group",
    501, "Post oak / blackjack oak",
    502, "Chestnut oak",
    503, "White oak / red oak / hickory",
    504, "White oak",
    505, "Northern red oak",
    506, "Yellow-poplar / white oak / northern red oak",
    507, "Sassafras / persimmon",
    508, "Sweetgum / yellow-poplar",
    509, "Bur oak",
    510, "Scarlet oak",
    511, "Yellow-poplar",
    512, "Black walnut",
    513, "Black locust",
    514, "Southern scrub oak",
    515, "Chestnut oak / black oak / scarlet oak",
    516, "Cherry / white ash / yellow-poplar",
    517, "Elm / ash / black locust",
    519, "Red maple / oak",
    520, "Mixed upland hardwoods",
    600, "Oak / gum / cypress group",
    601, "Swamp chestnut oak / cherrybark oak",
    602, "Sweetgum / Nuttall oak / willow oak",
    605, "Overcup oak / water hickory",
    606, "Atlantic white-cedar",
    607, "Baldcypress / water tupelo",
    608, "Sweetbay / swamp tupelo / red maple",
    609, "Baldcypress / pondcypress",
    700, "Elm / ash / cottonwood group",
    701, "Black ash / American elm / red maple",
    702, "River birch / sycamore",
    703, "Cottonwood",
    704, "Willow",
    705, "Sycamore / pecan / American elm",
    706, "Sugarberry / hackberry / elm / green ash",
    707, "Silver maple / American elm",
    708, "Red maple / lowland",
    709, "Cottonwood / willow",
    722, "Oregon ash",
    800, "Maple / beech / birch group",
    801, "Sugar maple / beech / yellow birch",
    802, "Black cherry",
    805, "Hard maple / basswood",
    809, "Red maple / upland",
    900, "Aspen / birch group",
    901, "Aspen",
    902, "Paper birch",
    903, "Gray birch",
    904, "Balsam poplar",
    905, "Pin cherry",
    910, "Alder / maple group",
    911, "Red alder",
    912, "Bigleaf maple",
    920, "Western oak group",
    921, "Gray pine",
    922, "California black oak",
    923, "Oregon white oak",
    924, "Blue oak",
    931, "Coast live oak",
    933, "Canyon live oak",
    934, "Interior live oak",
    935, "California white oak (valley oak)",
    940, "Tanoak / laurel group",
    941, "Tanoak",
    942, "California laurel",
    943, "Giant chinkapin",
    960, "Other hardwoods group",
    961, "Pacific madrone",
    962, "Other hardwoods",
    970, "Woodland hardwoods group",
    971, "Deciduous oak woodland",
    972, "Evergreen oak woodland",
    973, "Mesquite woodland",
    974, "Cercocarpus (mountain brush) woodland",
    975, "Intermountain maple woodland",
    976, "Miscellaneous woodland hardwoods",
    980, "Tropical hardwoods group",
    982, "Mangrove",
    983, "Palms",
    988, "Cloud forest",
    989, "Other tropical hardwoods",
    990, "Exotic hardwoods group",
    991, "Paulownia",
    992, "Melaleuca",
    993, "Eucalyptus",
    995, "Other exotic hardwoods",
    999, "Nonstocked",
    ## this list below is from:
    101, "Jack pine",
    102, "Red pine",
    103, "Eastern white pine",
    104, "Eastern White pine / Eastern hemlock",
    105, "Eastern hemlock",
    121, "Balsam fir",
    122, "White spruce",
    123, "Red spruce",
    124, "Red spruce / balsam fir",
    125, "Black spruce",
    126, "Tamarack",
    127, "Northern white-cedar",
    141, "Longleaf pine",
    142, "Slash pine",
    161, "Loblolly pine",
    162, "Shortleaf pine",
    163, "Virginia pine",
    164, "Sand pine",
    165, "Table-mountain pine",
    166, "Pond pine",
    167, "Pitch pine",
    168, "Spruce pine",
    181, "Eastern redcedar",
    182, "Rocky Mountain juniper",
    183, "Western juniper",
    184, "Juniper woodland",
    185, "Pinyon juniper woodland",
    201, "Douglas-fir",
    202, "Port-Orford-cedar",
    221, "Ponderosa pine",
    222, "Incense cedar",
    223, "Jeffrey pine / Coulter pine / bigcone Douglas-fir",
    224, "Sugar pine",
    241, "Western white pine",
    261, "White fir",
    262, "Red fir",
    263, "Noble fir",
    264, "Pacific silver fir",
    265, "Engelmann spruce",
    266, "Engelmann spruce / subalpine fir",
    267, "Grand fir",
    268, "Subalpine fir",
    269, "Blue spruce",
    270, "Mountain hemlock",
    271, "Alaska-yellow-cedar",
    281, "Lodgepole pine",
    301, "Western hemlock",
    304, "Western redcedar",
    305, "Sitka spruce",
    321, "Western larch",
    341, "Redwood",
    342, "Giant sequoia",
    361, "Knobcone pine",
    362, "Southwest white pine",
    363, "Bishop pine",
    364, "Monterey pine",
    365, "Foxtail pine / bristlecone pine",
    366, "Limber pine",
    367, "Whitebark pine",
    368, "Misc. western softwoods",
    371, "California mixed conifer",
    381, "Scotch pine",
    382, "Australian pine",
    383, "Other exotic softwoods",
    384, "Norway Spruce",
    385, "Introduced larch",
    401, "Eastern white pine / N. red oak / white ash",
    402, "Eastern redcedar / hardwood",
    403, "Longleaf pine / oak",
    404, "Shortleaf pine / oak",
    405, "Virginia pine / southern red oak",
    406, "Loblolly pine / hardwood",
    407, "Slash pine / hardwood",
    409, "Other pine / hardwood",
    501, "Post oak / blackjack oak",
    502, "Chestnut oak",
    503, "White oak / red oak / hickory",
    504, "White oak",
    505, "Northern red oak",
    506, "Yellow-poplar / white oak / N. red oak",
    507, "Sassafras / persimmon",
    508, "Sweetgum / yellow-poplar",
    509, "Bur oak",
    510, "Scarlet oak",
    511, "Yellow-poplar",
    512, "Black walnut",
    513, "Black locust",
    514, "Southern scrub oak",
    515, "Chestnut oak / black oak / scarlet oak",
    519, "Red maple / oak",
    520, "Mixed upland hardwoods",
    601, "Swamp chestnut oak / cherrybark oak",
    602, "Sweetgum / Nuttall oak / willow oak",
    605, "Overcup oak / water hickory",
    606, "Atlantic white-cedar",
    607, "Baldcypress / water tupelo",
    608, "Sweetbay / swamp tupelo / red maple",
    701, "Black ash / American elm / red maple",
    702, "River birch / sycamore",
    703, "Cottonwood",
    704, "Willow",
    705, "Sycamore / pecan / American elm",
    706, "Sugarberry / hackberry / elm / green ash",
    707, "Silver maple / American elm",
    708, "Red maple / lowland",
    709, "Cottonwood / willow",
    722, "Oregon ash",
    801, "Sugar maple / beech / yellow birch",
    802, "Black cherry",
    803, "Cherry / ash / yellow-poplar",
    805, "Hard maple / basswood",
    807, "Elm / ash / locust",
    809, "Red maple / upland",
    901, "Aspen",
    902, "Paper birch",
    904, "Balsam poplar",
    911, "Red alder",
    912, "Bigleaf maple",
    921, "Gray pine",
    922, "California black oak",
    923, "Oregon white oak",
    924, "Blue oak",
    925, "Deciduous oak woodland",
    926, "Evergreen oak woodland",
    931, "Coast live oak",
    932, "Canyon live oak / interior live oak",
    941, "Tanoak",
    942, "Califonia laurel",
    943, "Giant chinkapin",
    951, "Pacific madrone",
    952, "Mesquite Woodland",
    953, "Cercocarpus woodland",
    954, "Intermountain maple woodland",
    955, "Misc. western hardwood woodlands",
    981, "Sabal palm",
    982, "Mangrove",
    989, "Other tropical",
    991, "Paulownia",
    992, "Melaluca",
    993, "Eucalyptus",
    995, "Other exotic hardwoods"
  ) %>% 
  matrix(ncol = 2, byrow = T) %>% 
  dplyr::as_tibble() %>% 
  dplyr::rename(forest_type_code = 1, forest_type = 2) %>% 
  dplyr::mutate(forest_type = stringr::str_squish(forest_type)) %>% 
  dplyr::group_by(forest_type_code) %>% 
  dplyr::filter(dplyr::row_number()==1) %>% 
  dplyr::ungroup()
# huh?
foresttype_lookup %>% dplyr::glimpse()
```

let's create a column for the "forest type group" which is included in this data as any type code that is a multiple of 10 starting at 100...but remember we need to exclude the "999" which is "Nonstocked"

```{r}
foresttype_lookup <- 
  foresttype_lookup %>%
  # define forest_type_group_code as the 10's value
  dplyr::mutate(
    forest_type_group_code = forest_type_code %>% 
      stringr::str_sub(end = -2) %>% # cuts off the last digit from a number as a string
      paste0("0")
    , forest_type_group = dplyr::case_when(
      forest_type_group_code == forest_type_code ~ forest_type
      , T ~ NA
    )
  ) %>% 
  dplyr::arrange(as.numeric(forest_type_code)) %>% 
  dplyr::group_by(forest_type_group_code) %>% 
  dplyr::mutate(
    forest_type_group = dplyr::first(forest_type_group, na_rm = T)
    , hardwood_softwood = dplyr::case_when(
      as.numeric(forest_type_group_code) > 399 ~ "Hardwood"
      , as.numeric(forest_type_group_code) <= 399 ~ "Softwood"
      , T ~ "Error"
    )
  ) %>% 
  dplyr::ungroup() %>% 
  # some type groups are missing...lump them into other
  dplyr::mutate(
    forest_type_group_code = dplyr::case_when(
      is.na(forest_type_group) & as.numeric(forest_type_code) > 399 ~ "960"
      , is.na(forest_type_group) & as.numeric(forest_type_code) <= 399 ~ "390"
      , T ~ forest_type_group_code
    )
    , forest_type_group = dplyr::case_when(
      is.na(forest_type_group) & as.numeric(forest_type_code) > 399 ~ "Other hardwoods group"
      , is.na(forest_type_group) & as.numeric(forest_type_code) <= 399 ~ "Other softwoods group"
      , T ~ forest_type_group
    )
  ) %>% 
  # just drop the non-stocked
  dplyr::filter(forest_type_code != "999" & tolower(forest_type) != "nonstocked")
# huh?
foresttype_lookup %>% dplyr::glimpse()
```

let's get some examples

```{r}
foresttype_lookup %>% 
  dplyr::count(forest_type_group_code, forest_type_group) %>% 
  dplyr::arrange(desc(n)) %>% 
  dplyr::slice_head(n = 12)
```

export this for upload to [Zenodo](https://zenodo.org/uploads/new)

```{r}
foresttype_lookup %>% 
  write.csv( 
    file = file.path(savedir_temp, "foresttype_lookup.csv")
    , append = F
    , row.names = F
  )
```

aggregate the forest type group coverage by different geographic delineations

```{r}
agg_foresttype_table <- function(sf, rast=foresttype, lu=foresttype_lookup) {
  rast %>% 
    terra::crop(
      sf %>% sf::st_make_valid() %>% 
        dplyr::filter(sf::st_is_valid(.)) %>% 
        sf::st_union() %>% 
        terra::vect() %>% 
        terra::project(terra::crs(rast))
    ) %>% 
    terra::mask(
      sf %>% sf::st_make_valid() %>% 
        dplyr::filter(sf::st_is_valid(.)) %>% 
        sf::st_union() %>% 
        terra::vect() %>% 
        terra::project(terra::crs(rast))
    ) %>%
    terra::freq() %>% 
    dplyr::as_tibble() %>% 
    dplyr::rename(forest_type_code=value) %>% 
    dplyr::mutate(forest_type_code = as.character(forest_type_code)) %>% 
    dplyr::left_join(lu, by = "forest_type_code") %>% 
    dplyr::mutate(forest_type_group = dplyr::coalesce(forest_type_group, "non-forest")) %>% 
    dplyr::group_by(forest_type_group) %>% 
    dplyr::summarise(count = sum(count, na.rm = T)) %>% 
    dplyr::ungroup() %>% 
    dplyr::mutate(pct_area = count/sum(count)) %>% 
    dplyr::arrange(desc(count))
}
```

the state of Colorado

```{r}
library(USAboundaries)
USAboundaries::us_states(states = c("CO")) %>% 
  agg_foresttype_table() %>%  
  kableExtra::kbl(caption = paste("FIA Forest Type Groups in", "the entire state of Colorado") ) %>% 
  kableExtra::kable_styling()
```

National forests in USFS Region 2

```{r}
# !!! must be downloaded first
reg_dsn_temp <- "c:/data/usfs/bhef_rxfire_plan/data/S_USA.NFSLandUnit.gdb/S_USA.NFSLandUnit.gdb"
usfs_nf <- sf::st_read(dsn = reg_dsn_temp) %>% 
  dplyr::rename_with(tolower) %>% 
  dplyr::filter(region == "02" & tolower(nfslandunittype) == "national forest")
# forest type summary
usfs_nf %>% 
  agg_foresttype_table() %>%  
  kableExtra::kbl(caption = paste("FIA Forest Type Groups in", "USFS R2 National Forests") ) %>% 
  kableExtra::kable_styling()
```

the ARNF

```{r}
usfs_nf %>%
  dplyr::filter(
    stringr::str_detect(tolower(nfslandunitname), "arapaho")
    | stringr::str_detect(tolower(nfslandunitname), "roosevelt")
  ) %>% 
  agg_foresttype_table() %>%  
  kableExtra::kbl(caption = paste("FIA Forest Type Groups in", "the Arapaho and Roosevelt National Forest") ) %>% 
  kableExtra::kable_styling()
```


### Forest type group example

let's look at the Forest Type Groups raster for our [example area](#rmnp_ex) and use our fancy lookup data to make use of the forest type group codes in the raster

```{r}
# aoi
box_temp <- cloud2trees_ans$crowns_sf %>% 
  sf::st_bbox() %>% 
  sf::st_as_sfc() %>% 
  sf::st_buffer(200) %>% 
  terra::vect() %>% 
  terra::project(terra::crs(foresttype))
# crop it and merge with the forest type group data
aoi_temp <- foresttype %>% 
  terra::crop(box_temp) %>% 
  terra::mask(box_temp) %>% 
  as.data.frame(xy = T) %>% 
  dplyr::rename(forest_type_code=3) %>% 
  dplyr::mutate(forest_type_code = as.character(forest_type_code)) %>% 
  dplyr::left_join(foresttype_lookup, by = "forest_type_code")
# huh
aoi_temp %>% dplyr::glimpse()
```

let's plot the Forest Type Groups raster for our example area 

```{r}
# plot it
  ggplot() +
    geom_tile(
      data = aoi_temp
      , mapping = aes(x=x, y=y, fill=forest_type_group)
      , color = NA
      , alpha = 0.7
    ) +
    geom_sf(
      data = cloud2trees_ans$crowns_sf %>% 
        sf::st_bbox() %>% 
        sf::st_as_sfc() %>% 
        terra::vect() %>% 
        terra::project(terra::crs(foresttype)) %>% 
        sf::st_as_sf()
      , fill = NA
      , color = "red"
      , lwd = 1
    ) +
    labs(fill = "forest\ntype group", subtitle = "extent of lidar detected trees shown in blue") +
    harrypotter::scale_fill_hp_d("lunalovegood", na.value = "black") +
    theme_void()
```

this looks like the forest type we expected based on [RMNP example data](#rmnp_ex)

also, note that there are raster cells that do not have a forest type. if a lidar-detected tree falls within one of these "no forest type" cells, we'll have to figure out how to fill in the forest type. perhaps we can use the majority based on the other trees that overlap cells with a forest type? but what if none of our trees overlap with an actual forest type? we'll have to figure out how to find the nearest cell with a forest type.

## Forest Type to Tree List

Now that we have all the data, let's define a process to attach the forest type group data to a lidar-derived tree list. Remember, there are raster cells that do not have a forest type. If a lidar-detected tree falls within one of these "no forest type" cells, we'll have to figure out how to fill in the forest type. Perhaps we can use the majority based on the other trees that overlap cells with a forest type? But what if none of our trees overlap with an actual forest type? We'll have to figure out how to find the nearest cell with a forest type.

### Example with original forest type

our input data is a tree list with location data

```{r}
cloud2trees_ans$treetops_sf %>% dplyr::glimpse()
```

we want to attach the forest type group data to the tree list

```{r}
foresttype
```

this is easy with `terra::extract()`

```{r}
tree_ftype_temp <- 
  terra::extract(
    x = foresttype
    , y = cloud2trees_ans$treetops_sf %>%
      terra::vect() %>% 
      terra::project(terra::crs(foresttype)) # don't forget to reproject
  ) 
# huh?
tree_ftype_temp %>% dplyr::glimpse()
```

now let's join it back with our data and check it

```{r}
treetops_sf_new <- cloud2trees_ans$treetops_sf %>% 
  dplyr::mutate(
    forest_type_code = tree_ftype_temp$foresttype %>% as.character()
  ) %>% 
  dplyr::left_join(foresttype_lookup, by = "forest_type_code")
# huh?
treetops_sf_new %>% dplyr::glimpse()
```

check it on the map

```{r}
# plot it
  ggplot() +
    geom_tile(
      data = aoi_temp
      , mapping = aes(x=x, y=y, fill=forest_type_group)
      , color = NA
      , alpha = 0.7
    ) +
    geom_sf(
      data = treetops_sf_new %>% 
        terra::vect() %>% 
        terra::project(terra::crs(foresttype)) %>% # don't forget to reproject
        sf::st_as_sf()
      , mapping = aes(color = forest_type_group)
      , show.legend = F
    ) +
    labs(fill = "forest\ntype group", subtitle = "lidar-detected tree points with forest type group") +
    harrypotter::scale_fill_hp_d("lunalovegood", na.value = "black") +
    harrypotter::scale_color_hp_d("lunalovegood", na.value = "black") +
    theme_void()
```

looks good!

### Fill missing forest type example

now we need to figure out what to do if the tree data overlaps with raster cells with no forest type group

I originally tried to create a raster dataset with full coverage of forest type groups and just fill non-forest cells with the value from the nearest forest type. this "full coverage" data set could then be the master data we upload/download from Zenodo (since we're already using custom data) and apply the `terra::extract()` function. This option is not going to work because 1) there are too many blank cells to fill (~80% of the original raster); 2) we want to give a feasible answer and if there is a great distance between the tree data and the nearest forest type then the answer could be misleading (we'll just return no answer, but what is a "great distance"?)

The process we'll use to fill NA cell values is:

* create a bounding box around the tree point data
* expand the extent by the greater of double the bounding box or 1 km
  + outside of this would be a "great distance" to interpolate forest type
* crop the forest type raster to the bounding box extent
* fill in NA raster cell values using nearest neighbor interpolation
* return the forest type group attached to the tree using `terra::extract()`

first, get the bounding box of the tree data and double the extent

```{r}
# get extent of data
bbox_temp <- cloud2trees_ans$treetops_sf %>% sf::st_bbox()
# find largest side
buffer_temp <- max(
    bbox_temp["xmax"]-bbox_temp["xmin"]
    , bbox_temp["ymax"]-bbox_temp["ymin"]
  ) %>% 
  max(1000)
# apply the buffer
ext_temp <- bbox_temp %>% 
  sf::st_as_sfc() %>% 
  sf::st_buffer(buffer_temp, endCapStyle = "SQUARE") %>% 
  terra::vect() %>% 
  terra::project(terra::crs(foresttype))
```

mask the raster to this extent

```{r, results = F, echo = F}
foresttype_temp <- foresttype %>% 
  terra::crop(ext_temp) %>% # crop it first to make if faster
  terra::mask(ext_temp)
```

mark all non-forest cells as "NA" in the cropped raster

```{r, results = F, echo = F}
# rcl = two column matrix ("is", "becomes") can be useful for classifying integer
 # values. In that case, the arguments right and include.lowest are ignored.
# unique type codes
type_code_temp <- foresttype_lookup %>% 
  dplyr::pull(forest_type_code) %>% 
  as.numeric() %>% 
  unique()
# matrix
rcl_temp <- c(type_code_temp, type_code_temp) %>%
  matrix(ncol=2, byrow=F)
# update raster to mark all non-forest cells as NA
foresttype_temp <- foresttype_temp %>%
  terra::classify(
    rcl = rcl_temp
    , others = NA
  ) 
```

do we have NA cells?

```{r}
# na cells
terra::global(foresttype_temp, fun = "isNA")
```

here's what that looks like

```{r}
p1_temp <- 
# plot it
  ggplot() +
    geom_tile(
      data = foresttype_temp %>% 
        as.data.frame(xy = T) %>% 
        dplyr::rename(forest_type_code=3) %>% 
        dplyr::mutate(forest_type_code = as.character(forest_type_code)) %>% 
        dplyr::left_join(foresttype_lookup, by = "forest_type_code")
      , mapping = aes(x=x, y=y, fill=forest_type_group)
      , color = NA
      , alpha = 0.7
    ) +
    geom_sf(
      data = bbox_temp %>% 
        sf::st_as_sfc() %>% 
        terra::vect() %>% 
        terra::project(terra::crs(foresttype)) %>% 
        sf::st_as_sf()
      , mapping = aes(color = "trees extent")
      , fill = NA
    ) +
    geom_sf(
      data = ext_temp %>% 
        sf::st_as_sf()
      , mapping = aes(color = "buffered extent")
      , fill = NA
    ) +
    labs(fill = "forest\ntype group", color = "", subtitle = "original") +
    harrypotter::scale_fill_hp_d("lunalovegood", na.value = "white") +
    scale_color_manual(values = c("black", "red")) +
    theme_void()
p1_temp
```

in this example we don't happen to have an NA cells that overlap with our tree data, but that's ok as we are just demonstrating the process

lets's make a quick function to fill the NA raster cells using nearest neighbor interpolation implemented via `terra::voronoi()`

```{r}
fill_rast_na <- function(rast){
  # make sure there are filled cells
  if(
    terra::global(rast, fun = "isNA") == terra::ncell(rast)
  ){
    stop("All raster values are NA. Cannot fill entirely empty raster.")
  }

  # blank raster
  r_temp <- rast
  r_temp[] <- NA
  
  # get points with data
  p_temp <- terra::as.points(rast)
  
  # get nearest neighbor "prediction" as the values of the closest location with data using 
  # terra::voronoi which creates a Voronoi diagram (also known as Delaunay triangles or Thiessen diagram)
  #   The Voronoi diagram is created when a region with n points is partitioned into convex polygons 
  #   such that each polygon contains exactly one generating point, and every point in a given polygon
  #   is closer to its generating point than to any other.
  v_temp <- terra::voronoi(
    x = p_temp
    # set the boundary to the extent of the original raster
    , bnd = terra::ext(rast) %>% terra::vect()
  )
  
  # fill in our blank raster with these predictions
  r_temp <- terra::rasterize(x = v_temp, y = r_temp, field = names(v_temp)[1])
  
  # nearest neighbor interpolate applied via terra::cover
    # Replace NA or other values in SpatRaster x with the values of SpatRaster y
  rast_fill <- terra::cover(
    x = rast
    , y = r_temp
    , values = NA
  )
  
  # return
  return(rast_fill)
}
```

```{r, include=FALSE, eval=FALSE}
## !!!!!!!!!!!!!!!!!!!! the terra::interpNear works great for smaller areas but is terrible for large areas
fill_rast_na <- function(rast, interp = F){
  # get points with data
  p_temp <- terra::as.points(rast)
  # sets the search radius to the max
  r_temp <- max(
    terra::nrow(rast)*terra::res(rast)[1]
    , terra::ncol(rast)*terra::res(rast)[2]
  )
  # nearest neighbor interpolate
  rast_fill <- terra::interpNear(
    x = rast
    , y = p_temp
    , field = names(p_temp)[1]
    , radius = r_temp
    , interpolate = interp # if F, keeps the estimate as "categorical" 
      # (e.g. doesn't interpolate between ftype 700 and 900 to get 800, just picks 700 or 900)
  )
  return(rast_fill)
}
# fill_rast_na(r_temp) %>% terra::plot()
```

let's take the `fill_rast_na()` for a spin with our forest type raster...it might take a while with so many empty cells

```{r}
foresttype_temp <- fill_rast_na(foresttype_temp)
```

![](https://i.kym-cdn.com/photos/images/small/000/401/464/3e8.jpg)

...just kidding, but if we were to use the entire extent of the US that might be true

with the updated data plot

```{r}
p2_temp <- 
# plot it
  ggplot() +
    geom_tile(
      data = foresttype_temp %>% 
        as.data.frame(xy = T) %>% 
        dplyr::rename(forest_type_code=3) %>% 
        dplyr::mutate(forest_type_code = as.character(forest_type_code)) %>% 
        dplyr::left_join(foresttype_lookup, by = "forest_type_code")
      , mapping = aes(x=x, y=y, fill=forest_type_group)
      , color = NA
      , alpha = 0.7
    ) +
    geom_sf(
      data = bbox_temp %>% 
        sf::st_as_sfc() %>% 
        terra::vect() %>% 
        terra::project(terra::crs(foresttype)) %>% 
        sf::st_as_sf()
      , mapping = aes(color = "trees extent")
      , fill = NA
    ) +
    geom_sf(
      data = ext_temp %>% 
        sf::st_as_sf()
      , mapping = aes(color = "buffered extent")
      , fill = NA
    ) +
    labs(fill = "forest\ntype group", color = "", subtitle = "NA's filled") +
    harrypotter::scale_fill_hp_d("lunalovegood", na.value = "white") +
    scale_color_manual(values = c("black", "red")) +
    theme_void()
p2_temp
```

compare old vs new

```{r}
(p1_temp + theme(legend.position = "none")) + 
  p2_temp
```

that we filled raster cells outside of the buffered extent doesn't matter since those cells won't be used for anything

now we apply the `terra::extract()` function to attach forest type to our original tree list

```{r}
tree_ftype_temp <- 
  terra::extract(
    x = foresttype_temp
    , y = cloud2trees_ans$treetops_sf %>%
      terra::vect() %>% 
      terra::project(terra::crs(foresttype)) # don't forget to reproject
  ) 
# now let's join it back with our data and check it
cloud2trees_ans$treetops_sf %>% 
  dplyr::mutate(
    forest_type_code = tree_ftype_temp$foresttype %>% as.character()
  ) %>% 
  dplyr::left_join(foresttype_lookup, by = "forest_type_code") %>% 
  sf::st_drop_geometry() %>% 
  dplyr::count(forest_type_group)
```

### Fill missing forest type resilience

let's try to break the `fill_rast_na()` function by passing it a large raster

we'll do this by using a fake tree list with tree points at the corners of the state of Colorado

```{r}
tl_co_temp <-
  dplyr::tibble(x = c(-109.06006, -102.04188)) %>% 
  tidyr::crossing(
    dplyr::tibble(y = c(36.99243, 41.00307))
  ) %>% 
  sf::st_as_sf(
    coords = c("x", "y")
    , crs = sf::st_crs(4326)
    , remove = F
  ) %>% 
  # reproject to get horizontal units in meters
    # "NAD83 / Conus Albers"
  sf::st_transform(sf::st_crs(5070)) %>% 
  dplyr::mutate(treeID = dplyr::row_number())
# map it
tl_co_temp %>% 
  mapview::mapview(basemaps = c("OpenStreetMap"))
```

```{r, include=F, eval=FALSE}
bbox_co_temp <- sf::st_bbox(c(
    xmin = -109.06006, ymin = 36.99243, xmax = -102.04188, ymax = 41.00307
  )
  , crs = sf::st_crs(4326)
)
```

do we have forest type group raster data at these points before we test filling NA values?

```{r}
tree_ftype_temp <- 
  terra::extract(
    x = foresttype
    , y = tl_co_temp %>%
      terra::vect() %>% 
      terra::project(terra::crs(foresttype)) # don't forget to reproject
  )
# let's check with the lookup table
tree_ftype_temp %>% 
  dplyr::mutate(
    forest_type_code = foresttype %>% as.character()
  ) %>% 
  dplyr::left_join(foresttype_lookup, by = "forest_type_code") %>% 
  dplyr::count(forest_type_group)
```

nope, no forest type group at these points so it will be a good test of our NA fill process

we'll follow the same process above.

get the extent of the tree point data, buffer it by the greater of twice the area or 1 km, crop the forest type group raster, attempt to fill the na values, apply the NA filled forest type group.

```{r}
# get extent of data
bbox_temp <- tl_co_temp %>% sf::st_bbox()
# find largest side
buffer_temp <- max(
    bbox_temp["xmax"]-bbox_temp["xmin"]
    , bbox_temp["ymax"]-bbox_temp["ymin"]
  ) %>% 
  max(1000)
# apply the buffer
ext_temp <- bbox_temp %>% 
  sf::st_as_sfc() %>% 
  sf::st_buffer(buffer_temp, endCapStyle = "SQUARE") %>% 
  terra::vect() %>% 
  terra::project(terra::crs(foresttype))
```

mask the raster to this extent

```{r, results = F, echo = F}
foresttype_temp <- foresttype %>% 
  terra::crop(ext_temp)  # crop it first to make if faster
  # terra::mask(ext_temp)
```

mark all non-forest cells as "NA" in the cropped raster

```{r, results = F, echo = F}
# rcl = two column matrix ("is", "becomes") can be useful for classifying integer
 # values. In that case, the arguments right and include.lowest are ignored.
# unique type codes
type_code_temp <- foresttype_lookup %>% 
  dplyr::pull(forest_type_code) %>% 
  as.numeric() %>% 
  unique()
# matrix
rcl_temp <- c(type_code_temp, type_code_temp) %>%
  matrix(ncol=2, byrow=F)
# update raster to mark all non-forest cells as NA
foresttype_temp <- foresttype_temp %>%
  terra::classify(
    rcl = rcl_temp
    , others = NA
  ) 
```

what percent of cells are NA?

```{r}
( terra::global(foresttype_temp, fun = "isNA") /
  terra::ncell(foresttype_temp) ) %>% 
  unlist() %>% 
  scales::percent()
```

take the `fill_rast_na()` for a spin with our huge Colorado buffered to double the extent raster...it might take a while with so many empty cells

```{r}
# make a safe version
safe_fill_rast_na <- purrr::safely(fill_rast_na)
st_temp <- Sys.time()
fill_rast_na_ans <- safe_fill_rast_na(foresttype_temp)
end_temp <- Sys.time()
```

```{r, include = F, eval = F}
difftime(end_temp, st_temp, units = c("mins")) %>% as.numeric() %>% round(1)
```

this took `r difftime(end_temp, st_temp, units = c("mins")) %>% as.numeric() %>% round(1)` minutes...but did it issue an error?

If the function succeeds, `result` contains the returned value and `error` is NULL. If an error occurred, `error` is an `error` object and `result` is either NULL or otherwise.

```{r}
fill_rast_na_ans$error
```

yes we got a memory error :'(

it might be tempting to think that we should just buffer each tree point, fill NA cells of a smaller raster around each tree point, and "loop" over this process for each tree point that overlaps a NA forest type cell. however, it is unlikely that any tree list would have such dispersed points as our corners of Colorado tree list. if we were to implement the loop approach, we would likely fill the same raster area many times which would be highly inefficient and suggest that we should just fill the whole area raster one time (and we are back to where we started).

#### Find another way with huge rasters

let's try a different approach whereby we:

* check if the raster is huge (let's say >70% of the area of CO)
* if huge, reduce the resolution of the forest type raster by 3x (270x270 m) taking the most common forest type value
* fill NA cells of our reduced resolution raster using the same `fill_rast_na()` process
* update only the original resolution NA cells using the cell value of the NA-filled lower resolution raster

```{r, results = F, echo = F}
#  check if huge
area_m2_temp <- bbox_temp %>% 
    sf::st_as_sfc() %>% 
    terra::vect() %>% 
    terra::project(terra::crs(foresttype)) %>% # this way we work with the same units no matter the input
    sf::st_as_sf() %>% 
    sf::st_area() %>% 
    as.numeric()
# max area
max_area_m2_temp <- 542e+9
# check it
is_huge_temp <- area_m2_temp > (max_area_m2_temp * 0.7)
# determine factor to fill
get_fact_fn_temp <- function(a) {
  dplyr::case_when(
    # 150M = 3; 200M = 3;...;500M = 6; 550M = 7;...; 900M = 10
    a>150e+9 ~ round(a*1e-11)+1
    , T ~ 1
  )
}

if(is_huge_temp==T){
  
  st_temp <- Sys.time()
  # if huge, aggregate the cropped raster 
  agg_foresttype_temp <- foresttype_temp %>% 
    terra::aggregate(
      fact = get_fact_fn_temp(max_area_m2_temp)
      , fun = "modal", na.rm = T
      , cores = lasR::half_cores()
    )
  # terra::res(agg_foresttype_temp)
  # terra::plot(agg_foresttype_temp)
  # terra::plot(foresttype_temp)
  
  # `fill_rast_na()` process
  # safe it first
  safe_fill_rast_na <- purrr::safely(fill_rast_na)
  fill_rast_na_ans <- safe_fill_rast_na(agg_foresttype_temp)
  end_temp <- Sys.time()
  
  # if no error keep going
  if(is.null(fill_rast_na_ans$error)){
    # get the filled result
    agg_foresttype_temp <- fill_rast_na_ans$result
    # resample
    filler_rast_temp <- terra::resample(
      x = agg_foresttype_temp
      , y = foresttype_temp
      , method = "near"
    )
    # update the NA cells in the original raster
    foresttype2_temp <- terra::cover(
      x = foresttype_temp
      , y = filler_rast_temp
      , values = NA
    )
  }
  
}
```

this took `r difftime(end_temp, st_temp, units = c("mins")) %>% as.numeric() %>% round(1)` minutes (almost *[over 9000](https://i.kym-cdn.com/entries/icons/facebook/000/000/056/itsover1000.jpg)*)...but did it issue an error?

If the function succeeds, `result` contains the returned value and `error` is NULL. If an error occurred, `error` is an `error` object and `result` is either NULL or otherwise.

```{r}
fill_rast_na_ans$error
```

nice, we did it

here's the before raster

```{r}
terra::plot(foresttype_temp)
```

here's the after raster

```{r}
terra::plot(foresttype2_temp)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(
  foresttype, foresttype_lookup, fill_rast_na_ans, safe_fill_rast_na
)
gc()
```

### Get forest type function

let's define a function to put all of those steps together so that we can add it to `cloud2trees`

```{r, include = T, eval = F}
trees_type <- function(
  tree_list
  , crs = NA
  , study_boundary = NA
  , input_foresttype_dir = paste0(system.file(package = "cloud2trees"),"/extdata/foresttype")
  , max_search_dist_m = 1000
){
  ##################################
  # ensure that tree data exists
  ##################################
  f <- tree_list %>% names()
  if(length(f)==0){f <- ""}
  if(
    max(grepl("treeID", f))==0
  ){
    stop(paste0(
      "`tree_list` data must contain `treeID` column."
      , "\nProvide the `treeID` as a unique identifier of individual trees."
    ))
  }

  ##################################
  # convert to spatial points data
  ##################################
  if(inherits(tree_list, "sf")){
    # if points, just use it
    if( min(sf::st_is(tree_list, type = c("POINT", "MULTIPOINT"))) == 1 ){
      tree_tops <- tree_list %>%
        dplyr::mutate(
          tree_x = sf::st_coordinates(.)[,1]
          , tree_y = sf::st_coordinates(.)[,2]
        )
    }else{ # if spatial but not points, drop geom and set to points
      if(
        max(grepl("tree_x", names(tree_list)))==0
        | max(grepl("tree_y", names(tree_list)))==0
      ){ # doesn't contain x,y
        tree_tops <- tree_list %>%
          sf::st_centroid() %>%
          dplyr::mutate(
            tree_x = sf::st_coordinates(.)[,1]
            , tree_y = sf::st_coordinates(.)[,2]
          )
      }
      tree_tops <- tree_list %>%
        sf::st_drop_geometry() %>%
        sf::st_as_sf(
          coords = c("tree_x", "tree_y"), crs = sf::st_crs(tree_list)
          , remove = F
        ) %>%
        dplyr::mutate(treeID = as.character(treeID))
    }
  }else{ # not spatial data
    # convert from data.frame to spatial points
    if(!inherits(tree_list, "data.frame")){
      stop("must pass a data.frame or sf object to the `tree_list` parameter")
    }
    if(is.na(crs) | is.na(readr::parse_number(as.character(crs)))){
      stop("must provide the EPSG code in `crs` parameter for the projection of x,y data")
    }
    tree_tops <- tree_list %>%
      sf::st_as_sf(
        coords = c("tree_x", "tree_y")
        , crs = paste0( "EPSG:", readr::parse_number(as.character(crs)) )
        , remove = F
      ) %>%
      dplyr::mutate(treeID = as.character(treeID))
  }

  # check for duplicate treeID
  if(
    nrow(tree_tops) != length(unique(tree_tops$treeID))
  ){
    stop("Duplicates found in the treeID column. Please remove duplicates and try again.")
  }
  # get rid of columns we'll create
    tree_tops <- tree_tops %>%
      # throw in hey_xxxxxxxxxx to test it works if we include non-existant columns
      dplyr::select( -dplyr::any_of(c(
        "hey_xxxxxxxxxx"
        , "forest_type_group_code"
        , "forest_type_group"
        , "hardwood_softwood"
      )))
  
  ##################################
  # check/load foresttype data. see get_foresttype()
  ##################################
  f <- tolower(list.files(normalizePath(input_foresttype_dir)))
  if(length(f)==0){f <- ""}
  if(
    max(grepl("foresttype.tif", f))==0 || max(grepl("foresttype_lookup.csv", f))==0
  ){
    stop("Forest Type data has not been downloaded to package contents. Use `get_foresttype()` first.")
  }else{
    # get the foresttypdata
    foresttype <- terra::rast(
        file.path(normalizePath(input_foresttype_dir), "foresttype.tif")
      )
    # get the lookup
    foresttype_lookup <- readr::read_csv(
        file.path(normalizePath(input_foresttype_dir), "foresttype_lookup.csv")
        , progress = F
        , show_col_types = F
      ) %>% 
      dplyr::mutate(dplyr::across(
        dplyr::everything()
        , as.character
      ))
  }
    
  ##################################
  # define extent to crop forest type raster
  ##################################
    # get extent of trees data
    bbox_temp <- tree_tops %>% sf::st_bbox()
    # find largest side
    buffer_temp <- max(
        bbox_temp["xmax"]-bbox_temp["xmin"]
        , bbox_temp["ymax"]-bbox_temp["ymin"]
      ) %>% 
      max(max_search_dist_m)
    
    # check against the study boundary
    if(inherits(study_boundary, "sf") | inherits(study_boundary, "sfc")){
      bbox_b_temp <- study_boundary %>%
        sf::st_union() %>%
        sf::st_as_sf() %>%
        sf::st_transform(sf::st_crs(tree_tops)) %>%
        sf::st_bbox()
      # find largest side and compare to current setting from trees
      buffer_b_temp <- max(
          bbox_b_temp["xmax"]-bbox_b_temp["xmin"]
          , bbox_b_temp["ymax"]-bbox_b_temp["ymin"]
        )
      # reset bbox and buffer if larger
      if(buffer_b_temp>buffer_temp){
        buffer_temp <- buffer_b_temp
        bbox_temp <- bbox_b_temp
      }
    }
    
    # apply the buffer to get the extent
    ext_temp <- bbox_temp %>% 
      sf::st_as_sfc() %>% 
      sf::st_buffer(buffer_temp, endCapStyle = "SQUARE") %>% 
      terra::vect() %>% 
      terra::project(terra::crs(foresttype))

  ##################################
  # mask the raster to this extent
  ##################################
    foresttype_temp <- foresttype %>% 
      terra::crop(ext_temp) %>% # crop it first to make if faster
      terra::mask(ext_temp)
  
  ##################################
  # do we even need to fill NA values for this list?
  ##################################
    # attempt to extract the forest type for the trees
    # now we apply the `terra::extract()` function to attach forest type to our original tree list 
    tree_ftype_temp <- 
      terra::extract(
        x = foresttype_temp
        , y = tree_tops %>%
          terra::vect() %>% 
          terra::project(terra::crs(foresttype)) # don't forget to reproject
      )
    # let's check with the lookup table
    na_trees <- tree_ftype_temp %>% 
      dplyr::mutate(
        forest_type_code = foresttype %>% as.character()
      ) %>% 
      dplyr::left_join(foresttype_lookup, by = "forest_type_code") %>% 
      dplyr::filter(is.na(forest_type_group_code)) %>% 
      nrow() %>% 
      dplyr::coalesce(1)
  ##################################
  # IF we even need to fill NA values
  ##################################
  if(na_trees>0){
    # mark all non-forest cells as "NA" in the cropped raster
      # rcl = two column matrix ("is", "becomes") can be useful for classifying integer
       # values. In that case, the arguments right and include.lowest are ignored.
      # unique type codes
      type_code_temp <- foresttype_lookup %>% 
        dplyr::pull(forest_type_code) %>% 
        as.numeric() %>% 
        unique()
    # matrix
      rcl_temp <- c(type_code_temp, type_code_temp) %>%
        matrix(ncol=2, byrow=F)
    # update raster to mark all non-forest cells as NA
      foresttype_temp <- foresttype_temp %>%
        terra::classify(
          rcl = rcl_temp
          , others = NA
        ) 
    
    ##################################
    # check if huge raster
    ##################################
      #  check if huge
      area_m2_temp <- bbox_temp %>% 
        sf::st_as_sfc() %>% 
        terra::vect() %>% 
        terra::project(terra::crs(foresttype)) %>% # this way we work with the same units no matter the input
        sf::st_as_sf() %>% 
        sf::st_area() %>% 
        as.numeric()
      
      # check it
      is_huge_temp <- get_fact_fn(area_m2_temp) > 1
      
      # safe fill_rast_na first
      safe_fill_rast_na <- purrr::safely(fill_rast_na)
      
      ##### this process applies the fill_rast_na()
        # if is_huge_temp==T: aggregate, fill, update original rast resolution with filled
        # if is_huge_temp==F: fill
      if(is_huge_temp==T){
        # if huge, aggregate the cropped raster 
        agg_foresttype_temp <- foresttype_temp %>% 
          terra::aggregate(
            fact = get_fact_fn(area_m2_temp)
            , fun = "modal", na.rm = T
            , cores = lasR::half_cores()
          )
        
        # `fill_rast_na()` process
        fill_rast_na_ans <- safe_fill_rast_na(agg_foresttype_temp)
        
        # if no error keep going
        if(is.null(fill_rast_na_ans$error)){
            # get the filled result
            agg_foresttype_temp <- fill_rast_na_ans$result
            # resample
            filler_rast_temp <- terra::resample(
              x = agg_foresttype_temp
              , y = foresttype_temp
              , method = "near"
            )
            # update the NA cells in the original raster
            foresttype_temp <- terra::cover(
              x = foresttype_temp
              , y = filler_rast_temp
              , values = NA
            )
        }
        
      }else{
        # `fill_rast_na()` process
        fill_rast_na_ans <- safe_fill_rast_na(foresttype_temp)
        
        # if no error keep going
        if(is.null(fill_rast_na_ans$error)){
            # get the filled result
            foresttype_temp <- fill_rast_na_ans$result
        }
      
      }
    
    ##################################
    # if we successfully updated the raster
    # attach forest type to our original tree list
    ##################################
    if(terra::global(foresttype_temp, fun = "isNA")==0){
      # now we apply the `terra::extract()` function to attach forest type to our original tree list 
      tree_ftype_temp <- 
        terra::extract(
          x = foresttype_temp
          , y = tree_tops %>%
            terra::vect() %>% 
            terra::project(terra::crs(foresttype)) # don't forget to reproject
        )
    }

  }
  #######################################################
  # prep final data
  #######################################################  
    if(length(tree_ftype_temp$foresttype)==nrow(tree_tops)){
      # now let's join it back with our data and check it
      tree_tops <- tree_tops %>% 
        dplyr::mutate(
          forest_type_code = tree_ftype_temp$foresttype %>% as.character()
        ) %>% 
        dplyr::left_join(
          foresttype_lookup %>% 
            dplyr::select(
              forest_type_code
              , forest_type_group_code
              , forest_type_group
              , hardwood_softwood
            )
          , by = "forest_type_code"
        ) %>% 
        dplyr::select(-forest_type_code)
    }else{ # if 
      tree_tops <- tree_tops %>% 
        dplyr::mutate(
          forest_type_group_code = as.character(NA)
          , forest_type_group = as.character(NA)
          , hardwood_softwood = as.character(NA)
        )
      message(paste0(
        "Unable to determine forest type for this tree list and study boundary (if provided)."
        , "\nTry expanding the study boundary area or ensure that your tree data is in the continental US."
      ))
    }
  
  # return
  return(list(
    tree_list = tree_tops
    , foresttype_rast = foresttype_temp
  ))
}
#######################################################
# intermediate function 1
#######################################################
  # fill NA values of raster using nearest neighbor interpolation
  fill_rast_na <- function(rast){
    # make sure there are filled cells
    if(
      terra::global(rast, fun = "isNA") == terra::ncell(rast)
    ){
      stop("All raster values are NA. Cannot fill entirely empty raster.")
    }
  
    # blank raster
    r_temp <- rast
    r_temp[] <- NA
    
    # get points with data
    p_temp <- terra::as.points(rast)
    
    # get nearest neighbor "prediction" as the values of the closest location with data using 
    # terra::voronoi which creates a Voronoi diagram (also known as Delaunay triangles or Thiessen diagram)
    #   The Voronoi diagram is created when a region with n points is partitioned into convex polygons 
    #   such that each polygon contains exactly one generating point, and every point in a given polygon
    #   is closer to its generating point than to any other.
    v_temp <- terra::voronoi(
      x = p_temp
      # set the boundary to the extent of the original raster
      , bnd = terra::ext(rast) %>% terra::vect()
    )
    
    # fill in our blank raster with these predictions
    r_temp <- terra::rasterize(x = v_temp, y = r_temp, field = names(v_temp)[1])
    
    # nearest neighbor interpolate applied via terra::cover
      # Replace NA or other values in SpatRaster x with the values of SpatRaster y
    rast_fill <- terra::cover(
      x = rast
      , y = r_temp
      , values = NA
    )
    
    # return
    return(rast_fill)
  }
#######################################################
# intermediate function 2
#######################################################
  # determine factor to fill
  get_fact_fn <- function(a_m2) {
    # 150M = 2; 200M = 2;...;500M = 5; 550M = 6;...; 900M = 9
      max(round(a_m2*1e-11), 1)
  }
```

let's test this function with our example data

```{r, results=F, echo = F}
trees_species_ans <- cloud2trees::trees_type(cloud2trees_ans$treetops_sf)
```

what did we get back?

```{r}
# ?what?
trees_species_ans %>% dplyr::glimpse()
```

what is our forest type distribution?

```{r}
trees_species_ans$tree_list %>% 
  sf::st_drop_geometry() %>% 
  dplyr::count(forest_type_group, hardwood_softwood)
```

let's test with an area that we know doesn't have any trees near the southeast corner of Colorado

```{r}
tl_temp <- 
  dplyr::tibble(x = "-102.0418" %>% paste0(c(1:9)) %>% as.numeric()) %>% 
  tidyr::crossing(
    dplyr::tibble(y = "36.9924" %>% paste0(c(1:9)) %>% as.numeric())
  ) %>% 
  dplyr::distinct() %>% 
  sf::st_as_sf(coords = c("x", "y"), crs = sf::st_crs(4326), remove = F) %>% 
  # reproject to get horizontal units in meters
    # "NAD83 / Conus Albers"
  sf::st_transform(sf::st_crs(5070)) %>% 
  dplyr::mutate(treeID = dplyr::row_number())
```

where is this?

```{r}
mapview::mapview(tl_temp, zcol = "treeID", legend = F, layer.name = "trees")
```
*zoom out if you can't see anything*

let's test the `trees_species()` function with these trees that aren't anywhere near a forest and expand the `max_search_dist_m` parameter to allow for species very far away to be attached to this tree list

```{r, results=F, echo=FALSE}
trees_species_ans <- cloud2trees::trees_type(
  tl_temp
  , max_search_dist_m = 1000*50
)
```

what is our forest type distribution?

```{r}
trees_species_ans$tree_list %>% 
  sf::st_drop_geometry() %>% 
  dplyr::count(forest_type_group, hardwood_softwood)
```

let's check the points with our `foresttype_rast` layer that we got back from the `trees_species()` function

```{r}
trees_species_ans$foresttype_rast %>% 
  terra::aggregate(fact = 3, fun = "modal", cores = lasR::half_cores()) %>% 
  as.data.frame(xy = T) %>% 
  dplyr::rename(f=3) %>% 
  ggplot() +
    geom_tile(mapping = aes(x=x, y=y, fill=as.factor(f)), color = NA) +
    geom_sf(
      data = trees_species_ans$tree_list %>% 
        # change projection to match 
        sf::st_transform(
          trees_species_ans$foresttype_rast %>% 
            terra::crs(describe = T) %>% 
            dplyr::pull(code) %>% 
            as.numeric() %>% 
            sf::st_crs()
        )
      , mapping = aes(color = forest_type_group)
      , size = 4
    ) +
    scale_fill_viridis_d(begin = 0.2, alpha = 0.7) +
    scale_color_viridis_d(begin = 0.2) +
    labs(fill = "raster\nforest type code", color = "trees\nforest type") +
    theme_void()
```

what does this raster extent include on the map?

```{r}
trees_species_ans$foresttype_rast %>% 
  terra::ext() %>% 
  terra::vect() %>% 
  terra::set.crs(terra::crs(trees_species_ans$foresttype_rast)) %>% 
  sf::st_as_sf() %>% 
  mapview::mapview()
```

visual inspection of the satellite imagery indicates that there might be bands of pinyon-juniper in the central and southeast section of this search area

let's put the `trees_species()` function in to `cloud2trees`

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(list = ls())
gc()
```
