# Process{#s02}

```{r, include=F, warning=F, message=F}
# bread-and-butter
library(tidyverse) # the tidyverse
library(viridis) # viridis colors
library(harrypotter) # hp colors
library(RColorBrewer) # brewer colors
library(scales) # work with number and plot scales
library(latex2exp)

# visualization
library(mapview) # interactive html maps
library(kableExtra) # tables
library(patchwork) # combine plots
library(ggnewscale) # ggnewscale
library(plot3D) # 3d plotting
library(rgl) # rgl plotting

# spatial analysis
library(terra) # raster
library(sf) # simple features
library(lidR) # lidar data

# models
library(brms) # bayesian modelling

# utilities
library(rvest) # web scraping

library(pak)
# load them
c("NeonTreeEvaluation", "cloud2trees", "LadderFuelsR", "lasR", "leafR") %>% 
# install and load
  purrr::map(function(x){
    # locations
    df <- dplyr::tibble(
      p = c("NeonTreeEvaluation", "cloud2trees", "LadderFuelsR", "lasR", "leafR")
      , l = c(
        "weecology/NeonTreeEvaluation_package"
        , "georgewoolsey/cloud2trees"
        , "olgaviedma/LadderFuelsR"
        , "r-lidar/lasR"
        , "DRAAlmeida/leafR"
      )
    )
    # install if needed
    if(!require(x, character.only = T)){
      pak::pkg_install(
        pkg = df %>% dplyr::filter(tolower(p)==tolower(x)) %>% dplyr::pull(l)
        , upgrade = T
      )
    }
    # load
    library(x, character.only = T)
  })



# knit options
knitr::opts_chunk$set(
  echo = TRUE
  , warning = FALSE
  , message = FALSE
  # , results = 'hide'
  , fig.width = 10.5
  , fig.height = 7
)
# option to put satellite imagery as base layer of mapview maps
  mapview::mapviewOptions(
    homebutton = FALSE
    # , basemaps = c("Esri.WorldImagery","OpenStreetMap")
    , basemaps = c("OpenStreetMap", "Esri.WorldImagery")
  )
# clean session
remove(list = ls())
gc()
```

In this [prior section](#s02) we reviewed the methodologies to process lidar data, extract a tree list, and estimate CBH.

Presently, we will outline the end-to-end process for accomplishing this task given some example lidar data.

## Get some lidar data

The USGS has a [lidar data explorer](https://apps.nationalmap.gov/lidar-explorer/#/). This data is non-standardized so it may be challenging to build any portable processes.

I found an example area of interest and navigated to the [file storage directory](https://rockyweb.usgs.gov/vdelivery/Datasets/Staged/Elevation/LPC/Projects/CO_Southwest_NRCS_2018_D18/CO_Southwest_NRCS_B3_2018/LAZ/)

We'll use the `rvest` package to download the las files programmatically.

```{r}
# url
url <- "https://rockyweb.usgs.gov/vdelivery/Datasets/Staged/Elevation/LPC/Projects/CO_Southwest_NRCS_2018_D18/CO_Southwest_NRCS_B3_2018/LAZ/"
# rvest read html
html <- rvest::read_html(x = url)
# get parent element
chrs <- html %>% rvest::html_elements("pre")
# unnest children elements
# chrs %>% rvest::html_elements("a")
las_files <- chrs[1] %>% 
  rvest::html_elements("a") %>% 
  rvest::html_text2() %>% 
  stringr::str_subset(".*\\.(laz|las)$")
```

download files

```{r}
# increase the download timeout
options(timeout = max(3600, getOption("timeout")))
# function to download
dl_fn <- function(x, my_url = url, dest = "E:/SJNF_lidar"){
    # create delivery dir if needed
    if(!file.exists(file.path(dest))){
      dir.create(file.path(dest), showWarnings = FALSE)
    }
    # parameters to download
    u <- paste0(my_url, x)
    d <- paste0(file.path(dest),"/", x)
    # download it...if needed
    if(!file.exists(d)){
      # print
      message("downloading file: ", x, "at ", Sys.time())
      # download it
      download.file(
        url = u, destfile = d
        , quiet = F
        , mode = "wb"
      )
    }
    return(d)
  }
# map over the las files to read
dl_fn_ans <- las_files %>% 
  .[1:20] %>%
  purrr::map(\(x) dl_fn(x)) %>% 
  unlist()
# dl_fn_ans
```

where in the world is this data?

```{r}
las_ctg <- lidR::readLAScatalog(dl_fn_ans)
mapview::mapview(las_ctg@data)
```

let's read one file

```{r}
las <- lidR::readLAS(dl_fn_ans[13])
las
```

plot a sample
```{r,echo=FALSE,message=FALSE,warning=FALSE}
# ## if want to get current rgl parameters
# par3d()$zoom
# par3d()$FOV
# par3d()$userMatrix %>% c()
# par3d()$windowRect
## set up for printing rgl graphics
r3dDefaults <- rgl::r3dDefaults
m  <- structure(c(
  0.7963561,0.1201767,-0.5927685,0.0000000,-0.5896538,0.3724167,-0.7166689,0.0000000,0.1346301
  ,0.9202518,0.3674389,0.0000000,0.0000000,0.0000000,0.0000000,1.0000000
), .Dim = c(4L, 4L))
r3dDefaults$FOV <- 30
r3dDefaults$userMatrix <- m
r3dDefaults$zoom <- 0.55
r3dDefaults$windowRect <- c(0,23,1536,864)
rgl::setupKnitr(autoprint = TRUE)
```

```{r, rgl = TRUE}
las %>% 
  lidR::clip_roi(
    las %>% 
      sf::st_bbox() %>% 
      sf::st_as_sfc() %>% 
      sf::st_buffer(-400)
  ) %>% 
  lidR::plot(
    color = "Z", breaks = "quantile", bg = "white", legend = T
   , pal = harrypotter::hp(n=50, house = "gryffindor")
  )
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(las)
gc()
```

### `cloud2trees` that lidar data

extract trees from the lidar data using `cloud2trees` to create some example tree-level point cloud data to test the `LadderFuelsR` function we define below with

```{r}
if(F){
  cloud2trees_ans <- cloud2trees::cloud2trees(
    input_las_dir = dl_fn_ans[13]
    , output_dir = "../data"
    , estimate_tree_dbh = T
    , keep_intrmdt = T
  )
}else{
  cloud2trees_ans <- list(
    crowns_sf = sf::st_read("../data/point_cloud_processing_delivery/final_detected_crowns.gpkg", quiet=T)
    , treetops_sf = sf::st_read("../data/point_cloud_processing_delivery/final_detected_tree_tops.gpkg", quiet=T)
  )
}
```

clean it for `LadderFuelsR` to attach treeID to the point cloud

```{r}
# the lidR::merge_spatial requires only polygons so we need to rid the multipolygons
crowns_sf_poly <-
  # start with only polygons
  cloud2trees_ans$crowns_sf %>% 
  dplyr::filter(sf::st_geometry_type(.)=="POLYGON") %>%
  # union on cleaned multipolygons
  dplyr::bind_rows(
    cloud2trees_ans$crowns_sf %>% 
      dplyr::filter(sf::st_geometry_type(.)=="MULTIPOLYGON") %>%
      sf::st_cast(to = "POLYGON", do_split = T, warn = F) %>% 
      dplyr::mutate(axxx = sf::st_area(.)) %>% # axxx is so we don't overwrite a column
      dplyr::group_by(treeID) %>% 
      dplyr::filter(axxx == max(axxx)) %>% # keep the biggest crown polygon by treeID
      dplyr::ungroup() %>% 
      dplyr::select(-axxx)
  ) %>% 
  # generate a treeID index because it needs to be numeric
  dplyr::ungroup() %>% 
  dplyr::mutate(
    treeID_backup = treeID
    , treeID = dplyr::row_number()
  )
```

```{r, include=FALSE, eval=FALSE}
crowns_sf_poly %>% sf::st_geometry_type() %>% table()
cloud2trees_ans$crowns_sf %>% sf::st_geometry_type() %>% table()
```

read in normalized las files and filter one for testing

```{r}
# read in catalog
crowns_nlas_ctg <- lidR::readLAScatalog("../data/point_cloud_processing_temp/02_normalize/")
# filter for single tree point cloud
one_tree_sf <- crowns_sf_poly %>% 
  # get one of the taller trees
  dplyr::filter(tree_height_m >= quantile(crowns_sf_poly$tree_height_m, probs = 0.9)) %>% 
  dplyr::slice_sample(n=1)
```

now we'll attach the `treeID` column to the normalized las file and keep only the points that fall within a tree crown.

```{r, include=FALSE, eval=TRUE}
lidR::opt_progress(crowns_nlas_ctg) <- F
```

```{r}
# clip the point cloud
nlas_one_tree <- lidR::clip_roi(
    las = crowns_nlas_ctg
    , geometry = one_tree_sf
  ) %>% 
  sf::st_set_crs(sf::st_crs(crowns_sf_poly)) %>% 
  lidR::merge_spatial(
    source = crowns_sf_poly
    , attribute = "treeID"
  ) %>% 
  lidR::filter_poi(!is.na(treeID))
# what is this data?
nlas_one_tree@data %>% dplyr::glimpse()
```


## Define `LadderFuelsR` Processing Function

In this [prior section](#ladr_s) we identified the minimum steps needed to get CBH using the `LadderFuelsR` and `leafR` packages. Unfortunately, extracting CBH from the point cloud following these methods is performed one-by-one for individual trees. This does not seem like something that would work well if many, many trees.

There are a few possible paths forward to get CBH from point cloud data:
* Extract CBH from the point cloud for all trees using the `LadderFuelsR` [methodology](#ladr_s)
* Extract CBH from the point cloud for a sample of trees using the `LadderFuelsR` [methodology](#ladr_s) and build a model to estimate the rest
* Use the [TreeMap 2016 data](https://doi.org/10.2737/RDS-2021-0074) to model CBH using a regional model

Let's build a function to combine the `LadderFuelsR` steps for estimating CBH from the individual tree point cloud. Our function will take a point cloud as input and return a data frame.

```{r}
ladderfuelsr_cbh <- function(
  las
  , treeID = NA
  # minimum vhp records
  # https://github.com/olgaviedma/LadderFuelsR?tab=readme-ov-file#8depurating-tree-lad-profiles
  , min_vhp_n = 6
  # leafR::lad.voxels
  , voxel_grain_size_m = 2
  # LadderFuelsR::get_gaps_fbhs
  , dist_btwn_bins_m = 1 # step
  , min_fuel_layer_ht_m = 1.5 # min_height
  , lad_pct_gap = 25 # perc_gap
  , lad_pct_base = 25 # perc_base
  # LadderFuelsR::get_real_fbh
  , num_jump_steps = 1 # number_steps
  # LadderFuelsR::get_layers_lad
  , min_lad_pct = 10 # threshold
  # LadderFuelsR::get_cbh_metrics
  , frst_layer_ht_m = 2.5 # hdepth1_height
) {
  # check if string to las/laz file
  if(inherits(las, "character")){
    if(!stringr::str_ends(las, ".*\\.(laz|las)$")){
      stop("must pass a .las|.laz file path -OR- an object of class LAS to the `las` parameter")
    }
    # set the file path
    f <- normalizePath(las)
  }else if(inherits(las, "LAS")){
    # have to write the las to a tempfile
    fn <- paste0(tempdir(), "/temp.las") 
    # check if has a treeID
    if(
      (names(las@data) %>% stringr::str_detect("treeID") %>% max())==1
    ){
      n <- las@data$treeID %>% unique() %>% length()
      if(n>1 & is.na(treeID)){
        stop("the treeID column has more than one tree detected. set the `treeID` parameter")
      }else if(is.na(treeID)){
        # set the treeID
        treeID <- las@data$treeID %>% unique()
        # write it
        f <- las %>% 
          lidR::filter_poi(treeID == treeID) %>% 
          lidR::writeLAS(file = fn) 
      }else{
        # write it
        f <- las %>% 
          lidR::filter_poi(treeID == treeID) %>% 
          lidR::writeLAS(file = fn) 
      }
    }else{
      # write it
      f <- las %>% lidR::writeLAS(file = fn)
    }
  }else{
    stop("must pass a .las|.laz file path -OR- an object of class LAS to the `las` parameter")
  }
  
  # check the treeID
  treeID <- dplyr::coalesce(as.character(treeID), as.character(1)) # if the treeID parameter is not set, fake 1 
  #######################################
  ### Step 0 - `leafR` steps
  #######################################
    # 1) `leafR::lad.voxels()` - use normalized las file to create 
        # a data frame of the 3D voxels information (xyz) with Leaf Area Density values
    # 2) `leafR::lad.profile()` - calculate the lad profile from 
        # the input lad.voxels (step 1)
    # 3) ensure that the data frame returned from `leafR::lad.profile()` 
        # has a column named `treeID` which uniquely identifies individual trees. 
        # also, that column has to be the first column (bad practice by the authors)
    
    ## leafR::lad.voxels
    lad_voxels <- leafR::lad.voxels(normlas.file = f, grain.size = voxel_grain_size_m)
    ## leafR::lad.profile
    lad_profile <- leafR::lad.profile(lad_voxels, relative = F)
    ## add treeID column that is required by the package, though it's never stated
    lad_profile <- lad_profile %>% 
      dplyr::mutate(
        treeID = treeID %>% factor()
      ) %>% 
      ## !!!!! not only does the treeID column have to exist...it has to be the first column
      dplyr::relocate(treeID) %>% 
      dplyr::filter(treeID == treeID)

  ### check if all NA or all 0, whereby no fuel gaps can be determined
  prof_na <- lad_profile %>% dplyr::filter(dplyr::coalesce(lad,0) == 0) %>% nrow()
  if( nrow(lad_profile)-prof_na <= 1 ){
    message(
      paste0(
        "no fuel gaps found. unable to quantify CBH (treeID="
        , treeID, ")."
      )
    )
    return(NULL)
  }else if(nrow(lad_profile) < min_vhp_n){
    message(
      paste0(
        nrow(lad_profile)
        , " fuel vertical height profiles found. unable to quantify CBH (treeID="
        , treeID, "). try decreasing the `min_vhp_n` parameter?"
      )
    )
    return(NULL)
  }
  else{
    ## "depurating tree lad profiles"
    ## see: https://github.com/olgaviedma/LadderFuelsR#8depurating-tree-lad-profiles
    lad_profile <- lad_profile %>% 
      dplyr::mutate(lad = dplyr::coalesce(as.numeric(lad), 0.01)) %>% 
      dplyr::arrange(treeID, height)
    #######################################
    ### Step 1 - `LadderFuelsR::get_gaps_fbhs`
    #######################################
      ### this function is fixed: https://github.com/olgaviedma/LadderFuelsR/pull/3
      ### LadderFuelsR::get_gaps_fbhs
      ### This function calculates gaps and fuel layers base height (FBH) as 
      ### the difference in percentiles between consecutive LAD values along the vertical tree profile (VTP)
      gaps_fbhs <-
        # gw_get_gaps_fbhs(
        LadderFuelsR::get_gaps_fbhs(
          LAD_profiles = lad_profile
          , step = dist_btwn_bins_m
          , min_height = min_fuel_layer_ht_m
          , perc_gap = lad_pct_gap
          , perc_base = lad_pct_base
          , verbose = F
        )
      # fix the columns that should be numeric
      gaps_fbhs <- gaps_fbhs %>%
        dplyr::mutate(dplyr::across(
          !tidyselect::starts_with("treeID")
          , as.numeric
        ))
    ### check for all NA or 0
    gaps_na <- gaps_fbhs %>% 
      dplyr::filter(
        dplyr::if_all(
          .cols = -tidyselect::starts_with("treeID")
          , .fns = ~ dplyr::coalesce(.x, 0) == 0
        )
      ) %>% 
      nrow()
    if(gaps_na>0){
      message(
        paste0(
          "no fuel gaps found. unable to quantify CBH (treeID="
          , treeID, ")."
        )
      )
      return(NULL)
    }else{
      ######`#################################
      ### Step 2 - `LadderFuelsR::calculate_gaps_perc`
      #######################################
        ### this function calculates the percentile value of each height
        ## LadderFuelsR::calculate_gaps_perc
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ERROR if treeID is not the first column
        gaps_perc <- LadderFuelsR::calculate_gaps_perc(
          LAD_profiles = lad_profile
          , min_height = min_fuel_layer_ht_m
        )
  
      #######################################
      ### Step 3 - `LadderFuelsR::get_distance`
      #######################################
        ### calculates distances (and their heights) between fuel layers as
        ### the difference between consecutive gaps and fuel bases
        ### (the gap height always must be lower than the fuel base height).
        ## LadderFuelsR::get_distance
        metrics_distance <- LadderFuelsR::get_distance(
          gap_cbh_metrics = gaps_fbhs
          , gaps_perc = gaps_perc
          , step = dist_btwn_bins_m
          , min_height = min_fuel_layer_ht_m
          , verbose = F
        )
  
      #######################################
      ### Step 4 - `LadderFuelsR::get_depths`
      #######################################
        ### calculates fuels depth as the difference between gaps
        ### interleaved between fuel layers minus one step if
        ### the fuel depths are greater than one step.
        ## LadderFuelsR::get_depths
        metrics_depth <- LadderFuelsR::get_depths(
          LAD_profiles = lad_profile
          , distance_metrics = metrics_distance
          , step = dist_btwn_bins_m
          , min_height= min_fuel_layer_ht_m
          , verbose = F
        )
      
      #######################################
      ### Step 5 - `LadderFuelsR::get_real_fbh`
      #######################################      
        ### reshapes fuel layers after removing distances equal 
        ### to any number of height bin steps, keeping the first 
        ### "base height" from those consecutive ones separated by such distance.
        
        ## LadderFuelsR::get_real_fbh
        real_fbh <- LadderFuelsR::get_real_fbh(
          depth_metrics = metrics_depth
          , step = dist_btwn_bins_m
          , number_steps = num_jump_steps
          , min_height = min_fuel_layer_ht_m
          , verbose = F
        )
      
      #######################################
      ### Step 6 - `LadderFuelsR::get_real_depths`
      #######################################
        ### recalculates fuel layers depth after considering 
        ### distances greater than the actual height bin step.
        
        ## LadderFuelsR::get_real_depths
        real_depth <- LadderFuelsR::get_real_depths(
          effective_fbh = real_fbh
          , step = dist_btwn_bins_m
          , min_height = min_fuel_layer_ht_m
          , verbose = F
        )
      
      #######################################
      ### Step 7 - `LadderFuelsR::get_effective_gap`
      #######################################
        ### recalculates the distance between fuel layers after considering 
        ### distances greater than any number of height bin steps.
        
        ## LadderFuelsR::get_effective_gap
        eff_gap <- LadderFuelsR::get_effective_gap(
          effective_depth = real_depth
          , number_steps = num_jump_steps
          , min_height = min_fuel_layer_ht_m
          , verbose = F
        )
      #######################################
      ### Step 8 - `LadderFuelsR::get_layers_lad`
      #######################################
        ### calculates the percentage of Leaf Area Density (LAD) within 
        ### each fuel layer (first output) and removes those fuel layers 
        ### with LAD percentage less than a specified threshold 
        ### (default 10 the depth of the remaining ones (second output).
        
        ## LadderFuelsR::get_layers_lad
        layers_lad_df <- LadderFuelsR::get_layers_lad(
          LAD_profiles = lad_profile
          , effective_distances = eff_gap
          , threshold = min_lad_pct
          , step = dist_btwn_bins_m
          , min_height = min_fuel_layer_ht_m
          , verbose = F
        )
        ### idk why it is a list of 2 with the same data just the order 
        ### of the `max_height` and `Hcbh1_Hdptf1` columns are switched. do you spot another difference??
        ### looking through the befuddling README it looks like the authors only keep the second data frame in the list
        if(length(layers_lad_df)>1){
          layers_lad_df <- layers_lad_df[[2]]
        }
      
      #######################################
      ### Step 9 - `LadderFuelsR::get_cbh_metrics`
      #######################################
        ### `LadderFuelsR::get_cbh_dist` is described in the research article but does not 
        ### exist in the package or README. Looks like `LadderFuelsR::get_cbh_metrics` is there though.
        ### determines the CBH of a segmented tree using three criteria: 
        ### maximum LAD percentage, maximum distance and the last distance.
        
        ## LadderFuelsR::get_cbh_metrics
        cbh_metrics <- LadderFuelsR::get_cbh_metrics(
          effective_LAD = layers_lad_df
          , min_height = min_fuel_layer_ht_m
          , hdepth1_height = frst_layer_ht_m
          , verbose = F
        )
  
      # return
        return(list(
          gaps_fbhs = gaps_fbhs
          , lad_profile = lad_profile
          , gaps_perc = gaps_perc
          , metrics_distance = metrics_distance
          , metrics_depth = metrics_depth
          , real_fbh = real_fbh
          , real_depth = real_depth
          , eff_gap = eff_gap
          , layers_lad_df = layers_lad_df
          , cbh_metrics = cbh_metrics
        ))
    } # if all NA or all 0, whereby no fuel gaps can be determined
  } # if all NA or all 0, whereby no fuel gaps can be determined
}
```

```{r}
# CALL IT
ladderfuelsr_cbh_ans <- ladderfuelsr_cbh(
  las = nlas_one_tree # %>% lidR::decimate_points(random(0.5))
) 
ladderfuelsr_cbh_ans %>% names()
ladderfuelsr_cbh_ans$lad_profile %>% dplyr::glimpse()
```

Create our own plot of the gaps and fuel layers base height in the vertical tree profile

```{r}
ggplot() + 
  geom_path(data = ladderfuelsr_cbh_ans$lad_profile, mapping = aes(x = lad, y = height)) +
  geom_point(data = ladderfuelsr_cbh_ans$lad_profile, mapping = aes(x = lad, y = height)) +
  # gaps data
  geom_hline(
    data = ladderfuelsr_cbh_ans$gaps_fbhs %>% 
      dplyr::select(
        tidyselect::starts_with("gap") & !tidyselect::starts_with("gap_")
      ) %>% 
      tidyr::pivot_longer(dplyr::everything())
    , aes(yintercept = value, color = "gaps")
    , linetype = "dotted"
    , lwd = 1.2
  ) + 
  # fbh data
  geom_hline(
    data = ladderfuelsr_cbh_ans$gaps_fbhs %>% 
      dplyr::select(
        tidyselect::starts_with("cbh") & !tidyselect::starts_with("cbh_")
      ) %>% 
      tidyr::pivot_longer(dplyr::everything())
    , aes(yintercept = value, color = "FBHs")
    , linetype = "dotdash"
    , lwd = 1.2
  ) +
  scale_color_manual(values = c("green4", "red"), name = "") +
  scale_y_continuous(breaks = scales::extended_breaks(10)) +
  theme_light() +
  theme(legend.position = "top")
```

note, the `gap` and `cbh` columns in `ladderfuelsr_cbh_ans$gaps_fbhs` contain the data needed for the plot ( but not the `gap_` and `cbh_` columns ;/ ).

but what are these columns?

* `cbh` - Height of the fuel layer base height (m)
* `gap` - Height of gap between fuel layers (m)

### Return CBH Metrics

```{r}
ladderfuelsr_cbh_ans$cbh_metrics %>% dplyr::glimpse()
```

what are these?

* treeID: tree ID with strings and numeric values
* treeID1: tree ID with only numeric values
* dptf: Depth of fuel layers (m) after considering distances greater than the actual height bin step
* effdist: Effective distance between consecutive fuel layers (m) after considering distances greater than any number of steps
* Hcbh: Base height of each fuel separated by a distance greater than the certain number of steps
* Hdptf: Height of the depth of fuel layers (m) after considering distances greater than the actual step
* Hdist: Height of the distance (> any number of steps) between consecutive fuel layers (m)
* Hcbh_Hdptf - Percentage of LAD values comprised in each effective fuel layer
* maxlad_Hcbh - Height of the CBH of the segmented tree based on the maximum LAD percentage
* maxlad1_Hcbh - Height of the CBH from the second fuel layer when the maximum LAD occurred in the first fuel layer but its depth <= "hdepth1_height"
* max_Hcbh - Height of the CBH of the segmented tree based on the maximum distance found in its profile
* last_Hcbh - Height of the CBH of the segmented tree based on the last distance found in its profile
* maxlad_ - Values of distance and fuel depth and their corresponding heights at the maximum LAD percentage
* maxlad1_ - Values of distance and fuel depth and their corresponding heights for the second fuel layer when the maximum LAD occurred in the first fuel layer but its depth <= "hdepth1_height"
* max_ - Values of distance and fuel depth and their corresponding heights at the maximum distance
* last_ - Values of distance and fuel depth and their corresponding heights at the last distance
* nlayers - Number of effective fuel layers
* max_height - Maximum height of the tree profile

there are also some plotting functions

```{r}
# Generate plots for fuels LAD metrics
plots_cbh_maxlad <- LadderFuelsR::get_plots_cbh_LAD(
  LAD_profiles = ladderfuelsr_cbh_ans$lad_profile
  , cbh_metrics = ladderfuelsr_cbh_ans$cbh_metrics
  , min_height = 0.5
)
plots_cbh_maxdist <- LadderFuelsR::get_plots_cbh_maxdist(
  LAD_profiles = ladderfuelsr_cbh_ans$lad_profile
  , cbh_metrics = ladderfuelsr_cbh_ans$cbh_metrics
  , min_height = 0.5
)
plots_cbh_lastdist <- LadderFuelsR::get_plots_cbh_lastdist(
  LAD_profiles = ladderfuelsr_cbh_ans$lad_profile
  , cbh_metrics = ladderfuelsr_cbh_ans$cbh_metrics
  , min_height = 0.5
)
# patchwork them
(plots_cbh_maxlad[[1]] + labs(title = "get_plots_cbh_LAD")) +
(plots_cbh_maxdist[[1]] + labs(title = "get_plots_cbh_maxdist")) +
(plots_cbh_lastdist[[1]] + labs(title = "get_plots_cbh_lastdist")) +
  patchwork::plot_layout(ncol = 2)
```

these plots represent the three criteria to define the CBH in a segmented tree: 

* `get_plots_cbh_LAD` = the fuel layer containing the maximum LAD percentage (column named `maxlad_Hcbh`)
* `get_plots_cbh_maxdist` = the fuel layer located at the highest distance (column named `max_Hcbh`)
* `get_plots_cbh_lastdist` = the fuel layer separated by the last effective distance (column named `last_Hcbh`)

## Function to CBH tree list

let's define a function for performing the CBH estimation over multiple trees and combining all of the data

```{r}
trees_cbh <- function(
  trees_poly
  , norm_las = NA
  , tree_sample_prop = 1
  ##### LadderFuelsR
  # minimum vhp records
  # https://github.com/olgaviedma/LadderFuelsR?tab=readme-ov-file#8depurating-tree-lad-profiles
  , min_vhp_n = 6
  # leafR::lad.voxels
  , voxel_grain_size_m = 2
  # LadderFuelsR::get_gaps_fbhs
  , dist_btwn_bins_m = 1 # step
  , min_fuel_layer_ht_m = 1.5 # min_height
  , lad_pct_gap = 25 # perc_gap
  , lad_pct_base = 25 # perc_base
  # LadderFuelsR::get_real_fbh
  , num_jump_steps = 1 # number_steps
  # LadderFuelsR::get_layers_lad
  , min_lad_pct = 10 # threshold
  # LadderFuelsR::get_cbh_metrics
  , frst_layer_ht_m = 2.5 # hdepth1_height
){
  ##################################
  # ensure that norm las data exists
  ##################################
  nlas_msg <- paste0(
    "`norm_las` must contain a directory with nomalized las files, the path of a .laz|.las file"
    , "\n, -or- a file of class `LAS`. Please update the `norm_las` parameter."
  )
  if(is.na(norm_las)){stop(nlas_msg)}
  if(inherits(norm_las, "character")){
    if(!stringr::str_ends(norm_las, ".*\\.(laz|las)$")){
      # try to read directory for las files
      fls <- list.files(normalizePath(norm_las), pattern = ".*\\.(laz|las)$", full.names = TRUE)
      # stop it if no files
      if(length(fls)<1){stop(nlas_msg)}
      nlas_ctg <- lidR::readLAScatalog(fls)
    }else if(stringr::str_ends(norm_las, ".*\\.(laz|las)$")){
      nlas_ctg <- lidR::readLAScatalog(norm_las)
    }else{
      stop(nlas_msg)
    }
  }else if(inherits(norm_las, "LAS")){
    nlas_ctg <- norm_las
  }else{
    stop(nlas_msg)
  }
  ##################################
  # ensure that treeID data exists
  ##################################
  f <- trees_poly %>% names()
  if(length(f)==0){f <- ""}
  if(
    max(grepl("treeID", f))==0
  ){
    stop(paste0(
      "`trees_poly` data must contain `treeID` column to estimate CBH."
      , "\nProvide the `treeID` as a unique identifier of individual trees."
    ))
  }else{
    # check for duplicate treeID
    if(
      nrow(trees_poly) != length(unique(trees_poly$treeID))
    ){
      stop("Duplicates found in the treeID column. Please remove duplicates and try again.")
    }
    # ensure that treeID is numeric
    # generate a treeID index because it needs to be numeric for LadderFuelsR
    trees_poly <- trees_poly %>% 
      dplyr::ungroup() %>% 
      dplyr::mutate(
        treeID_backup = treeID
        , treeID = dplyr::row_number()
      ) %>% 
      dplyr::relocate(treeID)
  }
  
  ##################################
  # ensure spatial polygon data
  ##################################
  sf_msg <- paste0(
      "`trees_poly` data must be an object of class `sf` with only POLYGON type."
      , "\nProvide an `sf` object and see `sf::st_geometry_type()`."
    )
  if(!inherits(trees_poly, "sf")){stop(sf_msg)}
  if( min(sf::st_is(trees_poly, type = c("POLYGON", "MULTIPOLYGON"))) == 0 ){stop(sf_msg)}
  
  ##################################
  # ensure the las and sf are same projection
  ##################################
  # get crs
    crs_las <- sf::st_crs(nlas_ctg)
    crs_poly <- sf::st_crs(trees_poly)
  # test equal epsg
    if(
      is.na(crs_las$epsg) |
      is.na(crs_poly$epsg) |
      crs_las$epsg != crs_poly$epsg
    ){
      stop("The `trees_poly` and `norm_las` data have differing CRS projections. Please see `sf::st_crs()` and ensure compatibility.")
    }
  
  ####################################################################
  # map over ladderfuelsr_cbh function
  ####################################################################
  cbh_df <- trees_poly %>% 
    dplyr::slice_sample(prop = min(as.numeric(tree_sample_prop), 1, na.rm = T)) %>% 
    dplyr::pull(treeID) %>% 
    purrr::map(\(x) function(
      x = x
      , min_vhp_n = min_vhp_n
      , voxel_grain_size_m = voxel_grain_size_m
      , dist_btwn_bins_m = dist_btwn_bins_m
      , min_fuel_layer_ht_m = min_fuel_layer_ht_m
      , lad_pct_gap = lad_pct_gap
      , lad_pct_base = lad_pct_base
      , num_jump_steps = num_jump_steps
      , min_lad_pct = min_lad_pct
      , frst_layer_ht_m = frst_layer_ht_m
    ){
      ##################################
      # filter sf
      ##################################
      one_tree_sf <- trees_poly %>% dplyr::filter(treeID==x)
      ##################################
      # clip the point cloud
      ##################################
      nlas_one_tree <- lidR::clip_roi(las = nlas_ctg, geometry = one_tree_sf) %>%
        lidR::filter_poi(!Classification %in% c(2,9,18)) %>% ## class 2 = ground; 9 = water; 18 = noise
        lidR::add_attribute(x = x, name = "treeID")
      ##################################
      # check for points
      ##################################
      if(nrow(nlas_one_tree@data)>10){
        # CALL ladderfuelsr_cbh
        ladderfuelsr_cbh_ans <- ladderfuelsr_cbh(
          las = nlas_one_tree
          , treeID = x
          , min_vhp_n = min_vhp_n
          , voxel_grain_size_m = voxel_grain_size_m
          , dist_btwn_bins_m = dist_btwn_bins_m
          , min_fuel_layer_ht_m = min_fuel_layer_ht_m
          , lad_pct_gap = lad_pct_gap
          , lad_pct_base = lad_pct_base
          , num_jump_steps = num_jump_steps
          , min_lad_pct = min_lad_pct
          , frst_layer_ht_m = frst_layer_ht_m
        ) 
      }else{
        ladderfuelsr_cbh_ans <- NULL
      }
      
      # build return data
      if(is.null(ladderfuelsr_cbh_ans$cbh_metrics)){
        # blank the cbh columns
        df <- one_tree_sf %>% 
          dplyr::mutate(
            maxlad_Hcbh = as.numeric(NA)
            , max_Hcbh = as.numeric(NA)
            , last_Hcbh = as.numeric(NA)
          )
      }else{
        df <- one_tree_sf %>% 
          dplyr::mutate(
            maxlad_Hcbh = ladderfuelsr_cbh_ans$cbh_metrics$maxlad_Hcbh
            , max_Hcbh = ladderfuelsr_cbh_ans$cbh_metrics$max_Hcbh
            , last_Hcbh = ladderfuelsr_cbh_ans$cbh_metrics$last_Hcbh
          )
      }
      return(df)
    }) 
    # %>% 
    # dplyr::bind_rows() %>% 
    # # get rid of treeID
    # dplyr::mutate(treeID = treeID_backup) %>% 
    # dplyr::select(-treeID_backup) %>% 
    # dplyr::relocate(treeID)
    
  # return
  return(cbh_df)
}
```

test it

```{r}
trees_cbh_ans <- trees_cbh(
  trees_poly = cloud2trees_ans$crowns_sf
  , norm_las = "../data/point_cloud_processing_temp/02_normalize/" # pull this from create_project_structure.R
  , tree_sample_prop = .1
)
trees_cbh_ans
```

