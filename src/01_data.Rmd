# Data Load and Methods Explore{#s01}

In this section we'll review the packages we'll be using to process and evaluate the lidar data. None of the analysis is happening here, just reviewing the methodologies.

Load the standard libraries

```{r, warning=FALSE, message=FALSE}
# bread-and-butter
library(tidyverse) # the tidyverse
library(viridis) # viridis colors
library(harrypotter) # hp colors
library(RColorBrewer) # brewer colors
library(scales) # work with number and plot scales
library(latex2exp)

# visualization
library(mapview) # interactive html maps
library(kableExtra) # tables
library(patchwork) # combine plots
library(ggnewscale) # ggnewscale
library(plot3D) # 3d plotting
library(rgl) # rgl plotting

# spatial analysis
library(terra) # raster
library(sf) # simple features
library(lidR) # lidar data

# models
library(brms) # bayesian modelling

# utilities
library(rvest) # web scraping
```

```{r pkg-ld, include=F, warning=F, message=F}
# knit options
knitr::opts_chunk$set(
  echo = TRUE
  , warning = FALSE
  , message = FALSE
  # , results = 'hide'
  , fig.width = 10.5
  , fig.height = 7
)
# option to put satellite imagery as base layer of mapview maps
  mapview::mapviewOptions(
    homebutton = FALSE
    # , basemaps = c("Esri.WorldImagery","OpenStreetMap")
    , basemaps = c("OpenStreetMap", "Esri.WorldImagery")
  )
# clean session
remove(list = ls())
gc()
```

Load the libraries from GitHub. Here we'll load:

* [`NeonTreeEvaluation`](https://github.com/weecology/NeonTreeEvaluation_package): benchmark data set to evaluate lidar-based tree detection ([Weinstein et al. 2021](https://scholar.google.com/scholar?cluster=4986448711981898434&hl=en&as_sdt=0,6))
* [`cloud2trees`](https://github.com/georgewoolsey/cloud2trees): routines for processing point cloud data collected by airborne lidar to detect forest trees (Woolsey and Tinkham, 2024)
* [`LadderFuelsR`](https://github.com/olgaviedma/LadderFuelsR): vertical fuel continuity quantification and crown base height (CBH) calculation ([Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427))
* [`lasR`](https://github.com/r-lidar/lasR): complex processing pipelines on lidar data ([Roussel 2024](https://r-lidar.github.io/lasR/index.html))
* [`leafR`](https://github.com/DRAAlmeida/leafR): set of functions for analyzing the ecological structure of forests based on LAI and LAD measures derived from LiDAR data ([Roussel 2024](https://r-lidar.github.io/lasR/index.html)). Data from this package used in the `LadderFuelsR` workflow even though this process is never explained by Viedma et al. 2024.

```{r, results=F}
library(pak)
# load them
c("NeonTreeEvaluation", "cloud2trees", "LadderFuelsR", "lasR", "leafR") %>% 
# install and load
  purrr::map(function(x){
    # locations
    df <- dplyr::tibble(
      p = c("NeonTreeEvaluation", "cloud2trees", "LadderFuelsR", "lasR", "leafR")
      , l = c(
        "weecology/NeonTreeEvaluation_package"
        , "georgewoolsey/cloud2trees"
        , "olgaviedma/LadderFuelsR"
        , "r-lidar/lasR"
        , "DRAAlmeida/leafR"
      )
    )
    # install if needed
    if(!require(x, character.only = T)){
      pak::pkg_install(
        pkg = df %>% dplyr::filter(tolower(p)==tolower(x)) %>% dplyr::pull(l)
        , upgrade = T
      )
    }
    # load
    library(x, character.only = T)
  })

```

## `NeonTreeEvaluation`{#neon}

Weinstein et al. ([2021](https://scholar.google.com/scholar?cluster=4986448711981898434&hl=en&as_sdt=0,6)) developed: 

>a benchmark dataset of individual canopy crowns derived from multi-sensor imagery in the National Ecological Observatory Network (Table 1) that provides: 1) co-registered remote sensing data from multiple sensors (LiDAR, RGB imagery, and hyperspectral imagery) to allow comparisons of methods based on any single sensor (e.g., for LiDAR based methods), or any combination of sensors (e.g., combining RGB and hyperspectral), and 2) three types of evaluation data to allow assessing both 'tree detection', defined as the identifying the location of individual trees using evaluation data with a point at the crown center , and 'crown delineation' defined as identifying the boundary edge of crowns across a broad range of forest types. The benchmark is designed to allow flexibility in both workflow and sensor selection. (p. 2)

**Table 1.** Summary of datasets included in the benchmark dataset. All sensor data has been cropped to the extent of NEON field sampling plots.

```{r, echo=FALSE, out.width="100%", out.height="100%", fig.align='center', fig.show='hold',results='asis'}
# https://journals.plos.org/ploscompbiol/article/figure?id=10.1371/journal.pcbi.1009180.t001
knitr::include_graphics("../data/journal.pcbi.1009180.t001.PNG")
```

The objective of the present analysis is to evaluate the use of this benchmark data set ([Weinstein et al. 2021](https://scholar.google.com/scholar?cluster=4986448711981898434&hl=en&as_sdt=0,6)) for a scientific publication describing a workflow to ingest raw LiDAR data and export a tabular tree list for use as an input to the QUIC-Fire physics-based fire spread model ([Linn et al. 2020](https://scholar.google.com/scholar?cluster=5135309566348498660&hl=en&as_sdt=0,6)).

Weinstein et al. ([2021](https://scholar.google.com/scholar?cluster=4986448711981898434&hl=en&as_sdt=0,6)) describe the LiDAR data in the benchmark data set: 

>The LiDAR data are 3D coordinates (~5 points/m2) that provide high resolution information about canopy crown shape and height. LiDAR data are stored as 1000m x 1000m.laz files (Fig 2). These files contain the x,y,z coordinates for each return, as well as metadata on return intensity and point classification. Boundaries of individual canopy crowns are often apparent due to gaps among neighboring trees or differences in height among overlapping canopy crowns. For more information on NEON LiDAR data processing see NEON technical document NEON.DOC.001292. Due to the large spatial coverage of the collection effort, the point density of the NEON LiDAR clouds is much lower than the point density used for most studies of crown detection models ([20, 21]; point densities of 8–1000 pt/m2). (p. 4)

what's in this package?

```{r}
lsf.str("package:NeonTreeEvaluation")
```

we first have to download evaluation data from the Zenodo archive (1GB), use the download() function to place the data in the correct package location. Download the much larger training data, set `training=TRUE`.

```{r}
NeonTreeEvaluation::download(training = T, force = F)
```

what data is in this package?

```{r}
# what/where is this data
paste0(system.file(package = "NeonTreeEvaluation"),"/extdata/") %>% 
  list.files(recursive = T, pattern = ".*\\.(laz|las)$", full.names = F) %>% 
  sample() %>% 
  .[1:10]
```

For a list of NEON site abbreviations [https://www.neonscience.org/field-sites/field-sites-map](https://www.neonscience.org/field-sites/field-sites-map)

`NeonTreeEvaluation::list_annotations` looks into package contents for ground truth annotations for the image-annotated crowns.

```{r}
# list_annotations
NeonTreeEvaluation::list_annotations() %>% 
  sample() %>% 
  .[1:10]
```

The field collected stems are individual points for each tree. They overlap with a subset of the sensor data. Use the `NeonTreeEvaluation::list_field_stems` function to determine which plots have stem data.

```{r}
# list_field_stems
NeonTreeEvaluation::list_field_stems() %>% 
  sample() %>% 
  .[1:10]
```

The `NeonTreeEvaluation::crown_polygons` function lists "field-annotated crowns" in which an observer annotates a polygon on the remote-sensing image on a tablet while standing in the field. From Ordway Swisher Biological Station, Florida and Mountain Lake Biological Station.

```{r}
# crown_polygons
NeonTreeEvaluation::crown_polygons %>% 
  dplyr::glimpse()
```

Sites with field annotated crowns

```{r}
# crown_polygons
NeonTreeEvaluation::crown_polygons %>% 
  sf::st_drop_geometry() %>% 
  dplyr::count(siteID)
```

hmmm this data only exists for two NEON sites

The woody vegetation structure data contains information on field estimated height and maximum crown diameter for the majority of field collected stems. We annotated all trees in the 40x40 m plot, regardless of health status, provided they were visible in the image.

```{r}
NeonTreeEvaluation::field %>% 
  dplyr::glimpse()
```

Nice, there appears to be some useful data in here: `uid`, `siteID`, `plotID`, `stemDiameter`, `height`, `maxCrownDiameter`, `ninetyCrownDiameter`, `baseCrownHeight`, `plantStatus`, `taxonID`

Also, I just found that there is a hidden function in the package to filter the field tree data

...except for I'm going to change the minimum diameter from 15 cm to 10 cm

```{r}
clean_field_data<-function(field){
  field$area<-field$maxCrownDiameter*field$ninetyCrownDiameter
  field<-field %>%  filter(!is.na(itcEasting),!stringr::str_detect(eventID,"2014"),growthForm %in% c("single bole tree","multi-bole tree","small tree","sapling"),stemDiameter>10) %>%
    droplevels() %>%
    filter(height>3|is.na(height))

  #Limit difference in heights
  to_remove<-field %>% group_by(individualID) %>%
    summarize(mean=mean(height),sum_difference = abs(sum(diff(height)))) %>%
    filter(sum_difference > 8)
  field<-field %>%
    filter(!individualID %in% to_remove$individualID)
}
```

clean this data and filter it

```{r}
# filter it
field_trees <- NeonTreeEvaluation::field %>% 
  clean_field_data() %>% 
  dplyr::select(
    uid, siteID, plotID, stemDiameter
    , height, maxCrownDiameter, ninetyCrownDiameter
    , baseCrownHeight, plantStatus, taxonID
  ) %>% 
  dplyr::filter(!is.na(maxCrownDiameter) & !is.na(height)) %>% 
  dplyr::mutate(CrownRadius = maxCrownDiameter/2)
# see it
field_trees %>% dplyr::glimpse()
```

what are these data?

```{r}
field_trees %>% 
  dplyr::select(dplyr::where(is.numeric)) %>% 
  summary()
```

status?

```{r}
field_trees %>% 
  dplyr::count(plantStatus)
```

keep only live

```{r}
field_trees <- field_trees %>% 
  dplyr::filter(plantStatus %>% tolower() %>% stringr::str_starts("live"))
```

taxonID?

```{r}
field_trees %>% 
  dplyr::count(taxonID) %>% 
  dplyr::arrange(desc(n)) %>% 
  dplyr::slice_head(n = 20)
```

let's see the height versus diameter relationship

```{r}
field_trees %>% 
  ggplot(mapping = aes(x = height, y = stemDiameter)) +
  geom_point() +
  scale_x_continuous(limits = c(0,NA)) +
  scale_y_continuous(limits = c(0,NA)) +
  theme_light()
```

let's get conifer trees only???

....sure, i found a NEON plant list with the codes: [https://data.neonscience.org/taxonomic-lists?taxonTypeCode=PLANT](https://data.neonscience.org/taxonomic-lists?taxonTypeCode=PLANT)

```{r}
conifer_spp <-
  readr::read_csv(
    "../data/OS_TAXON_PLANT-20220330T142149.csv"
    , show_col_types = F
    , progress = F
  ) %>% 
  dplyr::filter(
    tolower(family) %in% c(
      "pinaceae", "podocarpaceae", "araucariaceae"
      , "taxaceae", "cephalotaxaceae", "taxodiaceae", "cupressaceae"
    )
  ) %>% 
  dplyr::mutate(
    taxonID = toupper(taxonID)
    , vernacularName = tolower(vernacularName)
    , genus = stringr::str_to_title(genus)
  ) %>% 
  dplyr::distinct(taxonID, vernacularName, genus)
# huh?
conifer_spp %>% dplyr::slice_sample(n = 10)
```

filter that field tree list for conifers

```{r}
conifer_trees <- field_trees %>% 
  dplyr::inner_join(conifer_spp, by = "taxonID")
```

check those conifers height and diameter

```{r}
conifer_trees %>% 
  ggplot(mapping = aes(x = height, y = stemDiameter, color = genus)) +
  geom_point() +
  scale_x_continuous(limits = c(0,NA)) +
  scale_y_continuous(limits = c(0,NA)) +
  facet_wrap(facets = dplyr::vars(genus)) +
  scale_color_viridis_d(option = "turbo") +
  theme_light() + 
  theme(legend.position = "none")
```

what about this crown area data?

```{r}
conifer_trees %>% 
  ggplot(mapping = aes(x = CrownRadius, y = genus, fill = genus)) +
  geom_boxplot(width = 0.7, outliers = F) +
  scale_fill_viridis_d(option = "turbo") +
  theme_light() + 
  theme(legend.position = "none")
```

radius data

```{r}
# height
conifer_trees$height %>% 
  quantile(probs = c(0.01,0.05,0.5,0.95,0.99))
# radius
conifer_trees$CrownRadius %>% 
  quantile(probs = c(0.01,0.05,0.5,0.95,0.99))
```

let's model crown radius based on height

```{r}
lm(formula = CrownRadius ~ height, data = conifer_trees) %>% 
  broom::tidy() %>% 
  kableExtra::kbl(digits = 4) %>% 
  kableExtra::kable_styling()
```

plot this

```{r}
conifer_trees %>% 
  ggplot(mapping = aes(x = height, y = CrownRadius)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_x_continuous(limits = c(0,NA)) +
  scale_y_continuous(limits = c(0,NA)) +
  theme_light() + 
  theme(legend.position = "none")
```

what about a non-linear model?

```{r}
crown_height_model <- brms::brm(
  formula = brms::bf(
    formula = CrownRadius ~ (b1 * height) + height^b2
    , b1 + b2 ~ 1
    , nl = TRUE # !! specify non-linear
  )
  , data = conifer_trees
  , family = brms::brmsfamily("Gamma")
  , iter = 6000, warmup = 3000, chains = 4
  , cores = lasR::half_cores()
  , file = "../data/crown_height_model"
)
# plot(crown_height_model)
summary(crown_height_model)
    
## write out model estimates to tabular file
#### extract posterior draws to a df
brms::as_draws_df(
  crown_height_model
  , variable = c("^b_", "shape")
  , regex = TRUE
) %>% 
  # quick way to get a table of summary statistics and diagnostics
  posterior::summarize_draws(
    "mean", "median", "sd"
    ,  ~quantile(.x, probs = c(
      0.05, 0.95
      , 0.025, 0.975
    ))
    , "rhat"
  ) %>% 
  dplyr::mutate(
    variable = stringr::str_remove_all(variable, "_Intercept")
    , formula = summary(crown_height_model)$formula %>% 
      as.character() %>% 
      .[1]
  ) %>% 
  write.csv(
    "../data/crown_height_model.csv"
    , row.names = F
  )
```

plot this

```{r}
plot(brms::conditional_effects(crown_height_model), points = T)
```

what if we try to plot it with a function using the regression coefficients?

```{r}
ws_fn <- function(x) {
  y = dplyr::case_when(
    is.na(x) ~ 1e-3 # requires non-null
    , x < 0 ~ 1e-3 # requires positive
    , x < 2.5 ~ 1 # set lower bound
    , x > 40 ~ 6.7  # set upper bound
    # , TRUE ~ 0.75 + (x * 0.14)
    , TRUE ~ exp( (0.0446*x) + (x^-0.555) ) # used gamma regression so exp the result
  )
  return(y)
}
```

plot it

```{r}
ggplot2::ggplot() + ggplot2::xlim(0,60) + ggplot2::ylim(0,NA) +
  ggplot2::geom_point(data = conifer_trees, mapping = aes(y = CrownRadius, x = height)) +
  ggplot2::geom_function(fun = ws_fn, lwd = 1.5, color = "blue")
  
```

`NeonTreeEvaluation::get_data` is a set of utility functions for finding the path of benchmark data on disk

```{r}
NeonTreeEvaluation::get_data(plot_name = "RMNP_047", type = "lidar")
```

let's pull out all sites with `.laz` data and create a data frame for tracking purposes

```{r}
las_df <-
  paste0(system.file(package = "NeonTreeEvaluation"),"/extdata/") %>% 
    list.files(recursive = T, pattern = ".*\\.(laz|las)$", full.names = T) %>% 
    unique() %>% 
    dplyr::as_tibble() %>% 
    dplyr::rename(f_path = 1) %>% 
    # create some other variables
    dplyr::mutate(
      f_nm = f_path %>% basename() %>% stringr::str_remove_all("\\.(laz|las)$")
      , plot_nm = f_nm %>% # this matches the file name with the plot name 
        toupper() %>% 
        stringr::str_extract(
          pattern = NeonTreeEvaluation::list_field_stems() %>% 
            toupper() %>% 
            paste(collapse = "|")
        )
      , neon_site = plot_nm %>% stringr::word(start = 1, sep = fixed("_"))
    ) %>% 
    dplyr::filter(!is.na(plot_nm)) %>% # keep only las files with field stems
    dplyr::select(neon_site, plot_nm, f_nm, f_path)
# what?
las_df %>% dplyr::glimpse()
```

### Explore LiDAR data from package

which NEON sites have data?

```{r}
las_df %>% 
  dplyr::count(neon_site) %>% 
  dplyr::arrange(desc(n)) %>% 
  dplyr::mutate(neon_site = forcats::fct_reorder(neon_site, n)) %>% 
  # plot
  ggplot(aes(y = neon_site, x = n, fill = n)) +
    geom_col(width = 0.7) +
    labs(y = "NEON site", x = "lidar data plots") +
    harrypotter::scale_fill_hp("slytherin") +
    theme_light() +
    theme(legend.position = "none")
```

where is this data?

```{r}
get_site_bbox <- function(site, dta = las_df) {
# read the las files for a site  
  las_ctg = dta %>% 
    dplyr::filter(neon_site == site) %>% 
    dplyr::pull(f_path) %>% 
    lidR::readLAScatalog()
# bbox that site
  if( is.na( sf::st_crs(las_ctg@data) ) ){
    return(NULL)
  }else{
    las_ctg@data %>% 
      sf::st_bbox() %>% 
      sf::st_as_sfc() %>% 
      sf::st_as_sf() %>% 
      dplyr::mutate(neon_site = site)  %>% 
      sf::st_set_crs(sf::st_crs(las_ctg@data)) %>% 
      sf::st_transform(crs = paste0("EPSG:", 5070))
  }
}
# take this for a spin
las_df %>%
  dplyr::pull(neon_site) %>%
  unique() %>%
  purrr::map(get_site_bbox) %>% 
  dplyr::bind_rows() %>% 
  dplyr::left_join(
    las_df %>% 
      dplyr::group_by(neon_site) %>% 
      dplyr::summarise(n = dplyr::n())
    , by = "neon_site"
  ) %>% 
  st_centroid() %>% 
  mapview::mapview(
    zcol = "n"
    , layer.name = "LiDAR plots"
    , label = c("neon_site")
    , col.regions = viridis::mako(10, direction = -1)
  )
```

load one las data

```{r}
f_temp = las_df %>% dplyr::slice_sample(n = 1) %>% dplyr::pull(f_path)
las_temp = lidR::readLAS(f_temp)
# quick summary
las_temp
# data str
las_temp@data %>% 
  dplyr::glimpse()
```

summarize x, y, z

```{r}
las_temp@data %>% 
  dplyr::select(X,Y,Z) %>% 
  summary()
```

plot this las

```{r}
plot3D::scatter3D(
  x = las_temp@data$X
  , y = las_temp@data$Y
  , z = las_temp@data$Z
  , colvar = las_temp@data$Z
  , pch = 19, cex = 0.3
  , colkey = F
  , phi = 0.5
)
```

let's look at the classification (see [table 5 here](https://www.usgs.gov/ngp-standards-and-specifications/lidar-base-specification-tables))

```{r}
las_temp@data %>% 
  dplyr::count(Classification)
```

plot color by classification

```{r}
plot3D::scatter3D(
  x = las_temp@data$X
  , y = las_temp@data$Y
  , z = las_temp@data$Z
  , colvar = las_temp@data$Classification
  , pch = 19, cex = 0.3
  , colkey = F
  , phi = 0.5
)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## `cloud2trees`{#cloud2trees}

The [`cloud2trees`](https://github.com/georgewoolsey/cloud2trees) package provides routines for processing point cloud data (.las|.laz format) to detect forest trees. 

let's use it for one of the data sets from a conifer forest in the `NeonTreeEvaluation` benchmark

```{r}
# get one file
(f_temp <- las_df %>% 
    dplyr::filter(neon_site=="RMNP") %>%  # rocky mtn national park
    dplyr::slice_sample(n = 1) %>% 
    dplyr::pull(f_path))
# read in the data
las_temp <- lidR::readLAS(f_temp)
```

what is this data?

```{r}
las_temp@data %>% dplyr::glimpse()
```

We can plot the point cloud with and color by the point height

```{r, rgl = TRUE}
lidR::plot(
  las_temp
 , color = "Z", breaks = "quantile", bg = "white", legend = T
 , pal = harrypotter::hp(n=50, house = "gryffindor")
)
```

notice the Z values are in meters above sea level

```{r,echo=FALSE,message=FALSE,warning=FALSE}
# ## if want to get current rgl parameters
# par3d()$zoom
# par3d()$FOV
# par3d()$userMatrix %>% c()
# par3d()$windowRect
## set up for printing rgl graphics
r3dDefaults <- rgl::r3dDefaults
m  <- structure(c(
  # -0.54301322,-0.25636202,0.79963446,0.00000000,0.83863217,-0.21410924,0.50085258,0.00000000,0.04280954
  # ,0.94256878,0.33125746,0.00000000,0.00000000,0.00000000,0.00000000,1.00000000
  0.65544856,0.11915895,-0.74578017,0.00000000,-0.75504953,0.08122563,-0.65061742,0.00000000,-0.01695041
  ,0.98954701,0.14321014,0.00000000,0.00000000,0.00000000,0.00000000,1.00000000
), .Dim = c(4L, 4L))
r3dDefaults$FOV <- 30
r3dDefaults$userMatrix <- m
r3dDefaults$zoom <- 0.56
r3dDefaults$windowRect <- c(0,23,1536,864)
rgl::setupKnitr(autoprint = TRUE)
```

### Get tree list and normalized cloud

We'll use the `cloud2trees::cloud2trees()` function to get a tree list from the lidar data with a regional estimate of the DBH because we enabled the `estimate_tree_dbh` parameter.  Also returned is a canopy height model (CHM) raster and because we enabled the `keep_intrmdt` parameter we'll get the normalized point cloud data as well.

```{r, results=F}
cloud2trees_ans <- cloud2trees::cloud2trees(
  input_las_dir = f_temp
  , output_dir = "../data"
  , estimate_tree_dbh = T
  , keep_intrmdt = T
)
```

let's see what we got

```{r}
names(cloud2trees_ans)
```

we got a CHM

```{r}
# could make an easy plot with...
# terra::plot(cloud2trees_ans$chm_rast)
# ...but we'll customize and save it as our base plot
plt_chm <- 
  ggplot() +
    geom_tile(
      data = cloud2trees_ans$chm_rast %>% 
        as.data.frame(xy=T) %>% 
        dplyr::rename(f=3)
      , mapping = aes(x=x,y=y,fill=f)
    ) +
    harrypotter::scale_fill_hp("gryffindor", name = "height (m)") +
    theme_light() +
    theme(
      axis.text = element_blank()
    )
# view
plt_chm
```

we also got tree top points

```{r}
plt_chm +
  geom_sf(data = cloud2trees_ans$treetops_sf, color = "blue")
```

and we got tree crowns

```{r}
plt_chm +
  geom_sf(data = cloud2trees_ans$treetops_sf, color = "blue") +
  geom_sf(data = cloud2trees_ans$crowns_sf, fill = NA, color = "steelblue")
```

there is data on the individual trees in the crowns and tree tops data (which are the same data but one spaltial polygons and the other is spatial points).

```{r}
cloud2trees_ans$crowns_sf %>% 
  dplyr::glimpse()
```

let's check the height to DBH relationship

```{r}
cloud2trees_ans$crowns_sf %>% 
  ggplot(mapping = aes(x = tree_height_m, y = dbh_cm)) +
    geom_point(color = "navy") +
    labs(x = "height (m)", y = "DBH (cm)") +
    theme_light()
```

this all looks great. 

let's check the normalized point cloud. for that we'll dig in the output directory from the `cloud2trees::cloud2trees()` function (see that `output_dir` parameter).

```{r}
(n_f_temp <- list.files(
  "../data/point_cloud_processing_temp/02_normalize/"
  , pattern = ".las"
  , full.names = T
))
# read in the data
nlas_temp <- lidR::readLAS(n_f_temp)
```

plot it to check that it is height normalized

```{r, rgl = TRUE}
lidR::plot(
  nlas_temp
 , color = "Z", bg = "white", legend = T
 , pal = harrypotter::hp(n=50, house = "gryffindor")
)
```

nice! let's remove the ground points to check out potential vegetation

```{r, rgl = TRUE}
nlas_temp %>% 
  lidR::filter_poi(Classification!=2) %>% 
  lidR::plot(
    color = "Z", breaks = "quantile", bg = "white", legend = T
    , pal = harrypotter::hp(n=50, house = "gryffindor")
  )
```

that's a great workflow, guy.

i'm not your guy, buddy.

## `LadderFuelsR`{#ladr}

The `LadderFuelsR` package ([Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427)) is described as enabling the use of "LiDAR data and the LadderFuelsR package...[to] provide an automated tool for analysing the vertical fuel structure of a forest and to calculate crown base height (CBH) at tree-level, among other parameters" (p.1). 

let's check what's in this package

```{r}
lsf.str("package:LadderFuelsR")
```

### Prep for the package

For this package we need to do some cleaning of our las data and our polygon crown data. We need to attach the `treeID` column from our spatial crowns to the las data using `lidR::merge_spatial()`. This function allows for only polygons so we need to get rid of the multipolygons in the crown data. We'll keep the largest part of the multipolygon as the smaller part is usually a residual pixel from the CHM. We also generate a `tree_index` as a numeric id which is needed by the `LadderFuelsR` package since `treeID` is character.

```{r}
# the lidR::merge_spatial requires only polygons so we need to rid the multipolygons
crowns_sf_poly <-
  # start with only polygons
  cloud2trees_ans$crowns_sf %>% 
  dplyr::filter(sf::st_geometry_type(geometry)=="POLYGON") %>%
  # union on cleaned multipolygons
  dplyr::bind_rows(
    cloud2trees_ans$crowns_sf %>% 
      dplyr::filter(sf::st_geometry_type(geometry)=="MULTIPOLYGON") %>%
      sf::st_cast(to = "POLYGON", do_split = T, warn = F) %>% 
      dplyr::mutate(axxx = sf::st_area(geometry)) %>% # axxx is so we don't overwrite a column
      dplyr::group_by(treeID) %>% 
      dplyr::filter(axxx == max(axxx)) %>% # keep the biggest crown polygon by treeID
      dplyr::ungroup() %>% 
      dplyr::select(-axxx)
  ) %>% 
  # generate a treeID index because it needs to be numeric
  dplyr::ungroup() %>% 
  dplyr::mutate(tree_index = dplyr::row_number())
```

does it look good?

```{r}
plt_chm +
  geom_sf(data = cloud2trees_ans$treetops_sf, color = "blue") +
  geom_sf(data = crowns_sf_poly, fill = NA, color = "steelblue")
```

now we'll attach the `treeID` column to the normalized las file and keep only the points that fall within a tree crown.

```{r}
crowns_nlas_temp <- lidR::merge_spatial(
    las = nlas_temp
    , source = crowns_sf_poly
    , attribute = "tree_index"
  ) %>% 
  lidR::filter_poi(!is.na(tree_index)) %>% 
  lidR::filter_poi(Classification!=2)
# what is this data?
crowns_nlas_temp@data %>% dplyr::glimpse()
```

plot the las data colored by `tree_index`

```{r, rgl = TRUE}
crowns_nlas_temp %>% 
  lidR::plot(
    color = "tree_index", bg = "white", legend = F
    , pal = viridis::turbo(
    n = crowns_nlas_temp@data$tree_index %>% # this whole thing gets n unique colors 
          unique() %>% 
          length() %>% 
          `*`(2) # with some separation between the hues
      ) %>% 
      sample(
        crowns_nlas_temp@data$tree_index %>% 
          unique() %>% 
          length()
      )
  )
```

check it for one tree

```{r, include=FALSE, echo=FALSE}
r3dDefaults <- rgl::r3dDefaults
```

```{r, rgl = TRUE}
crowns_nlas_temp %>% 
  lidR::filter_poi(
    tree_index == 
      # get the tree with the most points
      crowns_nlas_temp@data %>% 
        dplyr::count(tree_index) %>% 
        dplyr::filter(n == max(n)) %>% 
        dplyr::slice_head(n=1) %>% 
        dplyr::pull(tree_index)
  ) %>% 
  lidR::plot(color = "tree_index", bg = "white", legend = F)
```

interesting, with more dense point clouds this would look more like a tree

### Defining function for computing crown-level metrics

Not sure how necessary this is, but pulling it from the [package README](https://github.com/olgaviedma/LadderFuelsR?tab=readme-ov-file#4-defining-function-for-computing-crown-level-metrics)

notice, none of these functions utilize the intensity, or "i", parameter

```{r}
custom_crown_metrics <- function(z, i) { # user-defined function
  metrics <- list(
     dz = 1,
     th = 1,
     z_max = max(z),# max height
     z_min = min(z),# min height
     z_mean = mean(z),# mean height
     z_sd = sd(z), # vertical variability of points
     z_q1=quantile(z, probs = 0.01),
     z_q5=quantile(z, probs = 0.05),
    z_q25=quantile(z, probs = 0.25),
    z_q50=quantile(z, probs = 0.50),
    z_q75=quantile(z, probs = 0.75),
    z_q95=quantile(z, probs = 0.95),
     crr=(mean(z)-min(z))/(max(z)-min(z))
   )
   return(metrics) # output
}
# idk why they did this...just for shorthand? just define it like that from the start
# ccm = ~custom_crown_metrics(z = Z, i = Intensity)
```

### Computing crown level standard metrics within all trees detected

let's see how they do it from the [package README](https://github.com/olgaviedma/LadderFuelsR?tab=readme-ov-file#5computing-crown-level-standard-metrics-within-all-trees-detected)

first, calculate metrics from the las data by tree (with code updates by gw)

```{r}
# setting a minimum Z height to look at crown metrics
fcrowns_nlas_temp <- lidR::filter_poi(crowns_nlas_temp, Z >= 1)
# Metric derivation at different levels of regularization
crowns_metrics_df <- 
  # gw updated this to do it all at once
  lidR::crown_metrics(
    las = fcrowns_nlas_temp
    , func = .stdtreemetrics # stdtreemetrics is a lidR predefined function for tree-based metrics
    , geom = "convex" # Geometry type of the output
    , attribute = "tree_index"
  ) %>% 
  dplyr::left_join(
    lidR::crown_metrics(
      las = fcrowns_nlas_temp
      , func = ~ custom_crown_metrics(z = Z) # the custom function defined above
      , geom = "convex" # Geometry type of the output
      , attribute = "tree_index"
    ) %>%
    sf::st_drop_geometry()
    , by = "tree_index"
  ) %>% 
  # define crown diameter
  dplyr::mutate(
    crown_diam = sqrt(convhull_area/ pi) * 2
  )
# a df, ok
crowns_metrics_df %>% dplyr::glimpse()
```

what "tree-based metrics" come from the `.stdtreemetrics`? maybe maximum Z, number of points, and crown area...not sure how useful these are for defining CBH. we shall see. the "z_" metrics are neat.

does every crown have some crown metrics?

```{r}
# has the same number of trees as our crown polygons?
dplyr::tibble(
  crowns_sf_poly_trees = nrow(crowns_sf_poly)
  , crowns_nlas_trees = fcrowns_nlas_temp@data$tree_index %>% unique() %>% length()
  , crowns_metrics_df_trees = nrow(crowns_metrics_df)
) %>% 
kableExtra::kbl() %>% kableExtra::kable_styling()
```

guess not. let's look at some of those metrics and the convex hull polygons created by the `lidR::crown_metrics()`

```{r}
plt_chm +
  ggnewscale::new_scale_fill() +
  geom_sf(data = crowns_metrics_df, mapping = aes(fill = z_mean), color = "steelblue") +
  harrypotter::scale_fill_hp("always", alpha = 0.8)
```

note the overlap of those polygons. what if we attach the crown metrics to the original crown polygons?

```{r}
plt_chm +
  ggnewscale::new_scale_fill() +
  geom_sf(
    data = crowns_sf_poly %>% 
      dplyr::left_join(
        crowns_metrics_df %>% sf::st_drop_geometry()
        , by = "tree_index"
      )
    , mapping = aes(fill = z_mean), color = "steelblue"
  ) +
  harrypotter::scale_fill_hp("always", alpha = 0.8, na.value = "black")
```

what is this `crr=(mean(z)-min(z))/(max(z)-min(z))` variable?

```{r}
plt_chm +
  ggnewscale::new_scale_fill() +
  geom_sf(data = crowns_metrics_df, mapping = aes(fill = crr), color = "steelblue") +
  harrypotter::scale_fill_hp("always", alpha = 0.8)
```

how about crown diameter?

```{r}
plt_chm +
  ggnewscale::new_scale_fill() +
  geom_sf(data = crowns_metrics_df, mapping = aes(fill = crown_diam), color = "steelblue") +
  harrypotter::scale_fill_hp("always", alpha = 0.8)
```

### LAI-LAD metrics by Trees

see this section of the [package README](https://github.com/olgaviedma/LadderFuelsR?tab=readme-ov-file#7lai-lad-metrics-by-trees)

>after height normalization and crown segmentation, the LiDAR returns were cropped with the crown contours being voxelized to obtain VHPs from which the absolute mean LAD at each height bin was retrieved ([Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427), p.2).

in this section, the las files cropped to individual trees (i.e. one tree at a time) are passed to the `leafR` package to calculate the LAI-LAD metrics. it seems very inefficient to perform this one-by-one for individual tree point clouds and not something that would work well if many, many trees.

let's go through the process for one tree point cloud 

```{r}
# leafR::lad.voxels requires a file location :\
fn <- paste0(tempdir(), "/temp.las")
# let's sample the tree with the most points
ti <- crowns_nlas_temp@data %>% 
  dplyr::count(tree_index) %>% 
  dplyr::arrange(desc(n)) %>% 
  dplyr::slice_head(n=1) %>% 
  dplyr::pull(tree_index)
f <- crowns_nlas_temp %>% 
    lidR::filter_poi(tree_index == ti) %>% # put this in a function and map over trees
    lidR::writeLAS(file = fn)
```

```{r, eval=FALSE, include=FALSE}
# leafR::lad.voxels requires a file location :\
fn <- paste0(tempdir(), "/temp.las")
# let's sample the tree with the most points
f <- "c:/data/cloud2trees/inst/extdata/norm_las" %>% 
    lidR::readLAScatalog() %>% 
    lidR::clip_roi(
      sf::st_read("c:/data/cloud2trees/inst/extdata/crowns_poly.gpkg") %>% 
        dplyr::slice_sample(n=1)
    ) %>% 
    lidR::writeLAS(file = fn)
pointsByZSlice <- leafR::pointsByZSlice()
```

#### `leafR::lad.voxels`

Creates a data frame of the 3D voxels information (xyz) with Leaf Area Density values from las file. 

```{r}
##### leafR::lad.voxels
  # Creates a data frame of the 3D voxels information (xyz) with Leaf Area Density values from las file
  lad_voxels <- leafR::lad.voxels(
    # normlas.file requires a file location :\
    normlas.file = f
    , grain.size = 2
  )
class(lad_voxels)
str(lad_voxels)
```

#### `leafR::lad.profile`

This function calculate the lad profile from the input lad.voxels. By "profile" I think they mean "vertical height profile"

```{r}
##### leafR::lad.profile
  # This function calculate the lad profile from the input lad.voxels
  lad_profile <- leafR::lad.profile(lad_voxels, relative = F)
  class(lad_profile)
  str(lad_profile)
```

#### `leafR::lai`

calculates the lead area index (LAI)

```{r}
lai_tot <- leafR::lai(lad_profile)
lai_understory <- leafR::lai(lad_profile, min = 0.3, max = 2.5)
class(lai_tot)
str(lai_tot)
str(lai_understory)
```

#### `leafR::LAHV`

Calculates the leaf area height volume (LAHV) metric as described in [Almeida et al. (2019)](https://scholar.google.com/scholar?cluster=7365610385622591776&hl=en&as_sdt=0,6)

```{r}
lahv_metric <- leafR::LAHV(lad_profile, LAI.weighting = FALSE, height.weighting = FALSE)
class(lahv_metric)
str(lahv_metric)
```

#### Bring together and clean{#huh}

they call this "Depurating Tree LAD profiles"

* replace missing LAD values with `0.01` (no explanation of "why")
* keep only trees where there are at least 6 profile (vertical height profile) records (>5)

```{r}
leafr_df <-
  dplyr::tibble(
    tree_index = ti # put this in a function and map over trees
  ) %>% 
  dplyr::bind_cols(lad_profile) %>% 
  dplyr::mutate(
    lad = dplyr::coalesce(lad, 0.01) # not sure why they put in 0.01 here
    , lai_tot = lai_tot[1]
    , lai_understory = lai_understory[1]
    , lahv = lahv_metric[1]
    , vhp_n = dplyr::n() # they keep trees where there are at least 6 (>5)
  ) %>% 
  dplyr::arrange(tree_index, height)
```

what is this?

```{r}
leafr_df %>% dplyr::glimpse()
```

seems like the data used to create Figure 1 (b)

```{r}
leafr_df %>% 
  ggplot(mapping = aes(x = lad, y = height)) + 
    geom_path() +
    geom_point() +
    theme_light()
```

what about the point cloud in voxels?

```{r, include=FALSE, echo=FALSE}
r3dDefaults <- rgl::r3dDefaults
```

```{r, rgl = TRUE}
# calculate voxel metrics
voxel_metrics(
  crowns_nlas_temp %>% lidR::filter_poi(tree_index == ti)
  , ~list(N = length(Z))
  , 2
) %>% 
  lidR::plot(
    color="N", pal = viridis::mako(n = 11, direction = -1)
    , size = 2, bg = "white", voxel = TRUE, legend = T
  )
```

### I quit

I quit following the [package README](https://github.com/olgaviedma/LadderFuelsR) because it's unnecessarily complex

## `LadderFuelsR` - simplified{#ladr_s}

the [package README](https://github.com/olgaviedma/LadderFuelsR) is so convoluted and difficult to follow. let's just cut the superfluity (i'll see your  ["depurating"](#huh) and raise you "superfluity"). 

someone had to identify the minimum steps needed to get CBH and cut out the superfluous clutter (bonus points if you see what i did there ;).

### Setup

the las files cropped to individual trees (i.e. one tree at a time) are passed to the `leafR` package to calculate the LAI-LAD metrics. it seems very inefficient to perform this one-by-one for individual tree point clouds and not something that would work well if many, many trees.

let's go through the process for one tree point cloud

```{r}
# leafR::lad.voxels requires a file location :\
fn <- paste0(tempdir(), "/temp.las")
# let's sample the tree with the most points
ti <- crowns_nlas_temp@data %>% 
  dplyr::count(tree_index) %>% 
  dplyr::arrange(desc(n)) %>% 
  dplyr::slice_head(n=1) %>% 
  dplyr::pull(tree_index)
(
f <- crowns_nlas_temp %>% 
    lidR::filter_poi(tree_index == ti) %>% # put this in a function and map over trees
    lidR::writeLAS(file = fn)
)
```

### Step 0 - `leafR` steps

1) `leafR::lad.voxels()` - use normalized las file to create a data frame of the 3D voxels information (xyz) with Leaf Area Density values
2) `leafR::lad.profile()` - calculate the lad profile from the input lad.voxels (step 1)
3) ensure that the data frame returned from `leafR::lad.profile()` has a column named `treeID` which uniquely identifies individual trees. also, that column has to be the first column (bad practice by the authors)

```{r}
## leafR::lad.voxels
lad_voxels <- leafR::lad.voxels(normlas.file = f, grain.size = 2)
lad_voxels %>% dplyr::glimpse()
## leafR::lad.profile
lad_profile <- leafR::lad.profile(lad_voxels, relative = F)
## add treeID column that is required by the package, though it's never stated
lad_profile <- lad_profile %>% 
  dplyr::mutate(tree_index = ti, treeID = factor(tree_index)) %>% 
  ## !!!!! not only does the treeID column have to exist...it has to be the first column
  dplyr::relocate(treeID)
lad_profile %>% dplyr::glimpse()
```

### Step 1 - `LadderFuelsR::get_gaps_fbhs`

calculates gaps and fuel layers base height (FBH) as the difference in percentiles between consecutive LAD values along the vertical tree profile (VTP). Negative differences are linked to gaps and positive differences to fuel base height.

**notice that this function is broken in the package...see [this issue](https://github.com/olgaviedma/LadderFuelsR/issues/2)**

[Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427) note:

>Function `get_gaps_fbhs()` identifies height bins with negative differences in LAD percentile for identifying gaps. When among consecutive height bins differences are negative, it selects the height bin with the lowest LAD (<= perc_gap [P25th]). Additionally, the function looks for height bins with LAD <= P25th, and when they are consecutive, it takes only the first and last values of the set being considered. For obtaining fuel layer base heights (FBHs), it identifies height bins with positive differences in LAD percentile. When such positive differences are consecutive, it selects the height bin with minimum LAD (> perc_base [P25th]). Moreover, it filters height bins with LAD > P25th, and when these are consecutive it takes only the first and last values of each set. Finally, to avoid any duplicated height bins in gaps and FBHs, it selects only the height bins identified as gaps that were not present in the FBH file, giving preference to the FBH height bins (p.3-5)

```{r}
### this function is broken!!!!!!!!!!!!!!!!!!!!!!!!!!
source("_broken_gap_fbh_from_LadderFuelsR.R") # gw fix here
## LadderFuelsR::get_gaps_fbhs
gaps_fbhs <- 
  gw_get_gaps_fbhs(
  # LadderFuelsR::get_gaps_fbhs(
    LAD_profiles = lad_profile
    , step=1
    , min_height=1.5
    , perc_gap= 25, perc_base= 25
    , verbose=TRUE
  )
gaps_fbhs %>% dplyr::glimpse()
# fix the columns that should be numeric
gaps_fbhs <- gaps_fbhs %>% 
  dplyr::mutate(dplyr::across(
    !tidyselect::starts_with("treeID")
    , as.numeric
  ))
```

let's take `LadderFuelsR::get_plots_gap_fbh()` for a spin which creates the plot in Figure 3 (plots of leaf area density profiles with fuel base heights in green and gaps >= step: Distance between bins in red).

>This function plots gaps and fuel layers base height (fbh) in the vertical tree profile (VTP).

```{r}
LadderFuelsR::get_plots_gap_fbh(
  LAD_profiles = lad_profile
  , gap_cbh_metrics = gaps_fbhs
  , min_height = 1.5
)
```

in RED are the GAPS and in GREEN the FBHs

can we re-create this?

```{r}
ggplot() + 
  geom_path(data = lad_profile, mapping = aes(x = lad, y = height)) +
  geom_point(data = lad_profile, mapping = aes(x = lad, y = height)) +
  # gaps data
  geom_hline(
    data = gaps_fbhs %>% 
      dplyr::select(
        tidyselect::starts_with("gap") & !tidyselect::starts_with("gap_")
      ) %>% 
      tidyr::pivot_longer(dplyr::everything())
    , aes(yintercept = value, color = "gaps")
    , linetype = "dotted"
    , lwd = 1.2
  ) + 
  # fbh data
  geom_hline(
    data = gaps_fbhs %>% 
      dplyr::select(
        tidyselect::starts_with("cbh") & !tidyselect::starts_with("cbh_")
      ) %>% 
      tidyr::pivot_longer(dplyr::everything())
    , aes(yintercept = value, color = "FBHs")
    , linetype = "dotdash"
    , lwd = 1.2
  ) +
  scale_color_manual(values = c("green4", "red"), name = "") +
  scale_y_continuous(breaks = scales::extended_breaks(10)) +
  theme_light() +
  theme(legend.position = "top")
```

yes. the `gap` and `cbh` columns contain the data ( but not the `gap_` and `cbh_` columns ;/ ).

but what are these columns?

* `cbh` - Height of the fuel layer base height (m)
* `gap` - Height of gap between fuel layers (m)

### Step 2 - `LadderFuelsR::calculate_gaps_perc`

this function calculates the percentile value of each height

```{r}
## LadderFuelsR::calculate_gaps_perc
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ERROR if treeID is not the first column
gaps_perc <- LadderFuelsR::calculate_gaps_perc(
  LAD_profiles = lad_profile %>% dplyr::select(-tree_index)
  , min_height=1.5
)
gaps_perc %>% dplyr::glimpse()
```

### Step 3 - `LadderFuelsR::get_distance`

calculates distances (and their heights) between fuel layers as the difference between consecutive gaps and fuel bases (the gap height always must be lower than the fuel base height).

[Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427) note:

>Function `get_distance()` calculates the distance between fuel layers as the height difference between each pair of consecutive gaps and FBHs (Figure 4a). In addition, when there are consecutive gaps, the distance is calculated as the difference between the minimum gap and the next FBH encountered (Figure 4b). Similarly, when there were consecutive FBHs, the distance was calculated as the difference between the minimum FBH and the previous gap encountered. When there are gaps above the last FBH, these values were removed for further analysis. (p.5)

```{r}
## LadderFuelsR::get_distance
metrics_distance <- LadderFuelsR::get_distance(
  gap_cbh_metrics = gaps_fbhs
  , gaps_perc = gaps_perc
  , step=1, min_height=1.5
)
metrics_distance %>% dplyr::glimpse()
```

### Step 4 - `LadderFuelsR::get_depths`

calculates fuels depth as the difference between gaps interleaved between fuel layers minus one step if the fuel depths are greater than one step.

[Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427) note:

>Function `get_depths()` calculates the depth of each fuel layer as the difference between the gaps comprising the FBHs. Finally, to get the real layer depth, and only when layer depth is greater than the step, it subtracts the step value from the depth (Figure 5). There are special cases when there are no gaps between FBHs: (i) if the gap height is less than the minimum height of the FBHs, depth is calculated as the difference between the maximum height of the FBHs set and the height of that gap minus the step (Figure 6a); (ii) if the gap height is greater than the maximum height of FBHs, depth is the difference between the maximum gap height and the minimum height of the FBHs set minus the step (Figure 6b). (p.5)

```{r}
## LadderFuelsR::get_depths
metrics_depth <- LadderFuelsR::get_depths(
  LAD_profiles = lad_profile
  , distance_metrics = metrics_distance
  , step= 1, min_height= 1.5
)
metrics_depth %>% dplyr::glimpse()
```

### Step 5 - `LadderFuelsR::get_real_fbh`

reshapes fuel layers after removing distances equal to any number of height bin steps, keeping the first "base height" from those consecutive ones separated by such distance.

[Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427) note:

>Function `get_real_fbh()` identifies the first FBH from consecutive FBHs or the first FBH from those separated by a distance equal to number of steps that can be skipped to reshape the fuel layers. For each distance value, it locates the next FBH value. If distance = num_step, the height of that FBH is propagated upwards. If distance > num_step, the height of that FBH is kept (Figure 7a,b). (p.5-6)

```{r}
## LadderFuelsR::get_real_fbh
real_fbh <- LadderFuelsR::get_real_fbh(
  depth_metrics = metrics_depth
  , step= 1, number_steps = 1, min_height=1.5
)
real_fbh %>% dplyr::glimpse()
```

### Step 6 - `LadderFuelsR::get_real_depths`

recalculates fuel layers depth after considering distances greater than the actual height bin step.

[Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427) note:

>Function `get_real_depths()` calculates the cumulative heights of depth values when distance = num_step. It iterates over each distance value and if dist[i] > num_step, it keeps the corresponding depth value. However, if dist[i] = num_step, it sums all consecutive distances and corresponding depth values (Figure 7a,b). (p.6)

```{r}
## LadderFuelsR::get_real_depths
real_depth <- LadderFuelsR::get_real_depths(effective_fbh = real_fbh, step=1, min_height=1.5)
real_depth %>% dplyr::glimpse()
```

### Step 7 - `LadderFuelsR::get_effective_gap`

recalculates the distance between fuel layers after considering distances greater than any number of height bin steps.

[Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427) note:

>Function `get_effective_gap()` calculates the effective distance between fuel layers based on the previously identified FBHs. It loops over all the FBHs and, at each iteration, it checks if the current value and the next value in FBHs are not equal. If they are not equal, it keeps the corresponding distance value, otherwise it removes it (Figure 8). (p.6)

```{r}
## LadderFuelsR::get_effective_gap
eff_gap <- LadderFuelsR::get_effective_gap(
  effective_depth = real_depth
  , number_steps = 1, min_height= 1.5
)
eff_gap %>% dplyr::glimpse()
```

### Step 8 - `LadderFuelsR::get_layers_lad`

calculates the percentage of Leaf Area Density (LAD) within each fuel layer (first output) and removes those fuel layers with LAD percentage less than a specified threshold (default 10 the depth of the remaining ones (second output).

[Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427) note:

>Function `get_layers_lad()` calculates LAD (%) within each fuel layer, which is defined by the height range between the FBH and its depth. First, it calculates the total LAD from the original profile. Next, it retrieves the beginning and end height bin of each fuel layer and calculates the percentage of total LAD that falls within that height range. Later, the fuel layers that had a LAD (%) less than a specified threshold (default 10%) were removed, recalculating the distances (Figure 9). (p.7)

```{r}
## LadderFuelsR::get_layers_lad
layers_lad_df <- LadderFuelsR::get_layers_lad(
  LAD_profiles = lad_profile
  , effective_distances = eff_gap
  , threshold=10,step = 1,min_height= 1.5
)
layers_lad_df %>% str()
```

idk why it is a list of 2 with the same data just the order of the `max_height` and `Hcbh1_Hdptf1` columns are switched. do you spot another difference??

looking through the befuddling README it looks like the authors only keep the second data frame in the list

```{r}
(layers_lad_df <- layers_lad_df[[2]])
```

is CBH in here? did we do it?

* treeID: tree ID with strings and numeric values
* treeID1: tree ID with only numeric values
* dptf: Depth of fuel layers (m) after considering distances greater than the actual height bin step
* effdist: Effective distance between consecutive fuel layers (m) after considering distances greater than any number of steps
* Hcbh: Base height of each fuel separated by a distance greater than the certain number of steps
* Hdptf: Height of the depth of fuel layers (m) after considering distances greater than the actual step
* Hdist: Height of the distance (> any number of steps) between consecutive fuel layers (m)
* Hcbh_Hdptf - Percentage of LAD values comprised in each effective fuel layer
* max_height - Maximum height of the tree profile
* nlayers - Number of effective fuel layers

is it possible to have multiple `Hcbh` values for one tree? is step 9 below even necessary at this point?

let's take the `LadderFuelsR::get_plots_effective()` function for a spin

```{r}
LadderFuelsR::get_plots_effective(
  LAD_profiles = lad_profile
  , effective_LAD = layers_lad_df
  , min_height = 1.5
)
```

maybe we'll try to recreate this plot at some point

```{r}
# wanna recreate this?
```

### Step 9 - ~~`LadderFuelsR::get_cbh_dist`~~ `LadderFuelsR::get_cbh_metrics`

`LadderFuelsR::get_cbh_dist` is described in the research article but does not exist in the package or README. Looks like `LadderFuelsR::get_cbh_metrics` is there though.

determines the CBH of a segmented tree using three criteria: maximum LAD percentage, maximum distance and the last distance.

[Viedma et al. 2024](https://doi.org/10.1111/2041-210X.14427) note:

>Function `get_cbh_dist()` applies three criteria to define the CBH in a segmented tree: the fuel layer containing the maximum LAD (%) (Figure 10a), the fuel layer located at the highest distance (Figure 10b), and the fuel layer separated by the last effective distance (Figure 10c). In the case of maximum LAD (%), the output also gives the CBH from the second fuel layer when the first one has the maximum LAD (%) but its depth is smaller than the value indicated in the parameter ‘hdepth1_height’ (default 2m). (p.8)

```{r}
## LadderFuelsR::get_cbh_metrics
cbh_metrics <- LadderFuelsR::get_cbh_metrics(effective_LAD = layers_lad_df, min_height= 1.5)
cbh_metrics %>% dplyr::glimpse()
```

what are these?

* treeID: tree ID with strings and numeric values
* treeID1: tree ID with only numeric values
* dptf: Depth of fuel layers (m) after considering distances greater than the actual height bin step
* effdist: Effective distance between consecutive fuel layers (m) after considering distances greater than any number of steps
* Hcbh: Base height of each fuel separated by a distance greater than the certain number of steps
* Hdptf: Height of the depth of fuel layers (m) after considering distances greater than the actual step
* Hdist: Height of the distance (> any number of steps) between consecutive fuel layers (m)
* Hcbh_Hdptf - Percentage of LAD values comprised in each effective fuel layer
* maxlad_Hcbh - Height of the CBH of the segmented tree based on the maximum LAD percentage
* maxlad1_Hcbh - Height of the CBH from the second fuel layer when the maximum LAD occurred in the first fuel layer but its depth <= "hdepth1_height"
* max_Hcbh - Height of the CBH of the segmented tree based on the maximum distance found in its profile
* last_Hcbh - Height of the CBH of the segmented tree based on the last distance found in its profile
* maxlad_ - Values of distance and fuel depth and their corresponding heights at the maximum LAD percentage
* maxlad1_ - Values of distance and fuel depth and their corresponding heights for the second fuel layer when the maximum LAD occurred in the first fuel layer but its depth <= "hdepth1_height"
* max_ - Values of distance and fuel depth and their corresponding heights at the maximum distance
* last_ - Values of distance and fuel depth and their corresponding heights at the last distance
* nlayers - Number of effective fuel layers
* max_height - Maximum height of the tree profile

there are also some plotting functions

```{r}
# Generate plots for fuels LAD metrics
plots_cbh_maxlad <- LadderFuelsR::get_plots_cbh_LAD(
  LAD_profiles = lad_profile
  , cbh_metrics = cbh_metrics
  , min_height=1.5
)
plots_cbh_maxdist <- LadderFuelsR::get_plots_cbh_maxdist(
  LAD_profiles = lad_profile
  , cbh_metrics = cbh_metrics
  , min_height=1.5
)
plots_cbh_lastdist <- LadderFuelsR::get_plots_cbh_lastdist(
  LAD_profiles = lad_profile
  , cbh_metrics = cbh_metrics
  , min_height=1.5
)
# patchwork them
(plots_cbh_maxlad[[1]] + labs(title = "get_plots_cbh_LAD")) +
(plots_cbh_maxdist[[1]] + labs(title = "get_plots_cbh_maxdist")) +
(plots_cbh_lastdist[[1]] + labs(title = "get_plots_cbh_lastdist")) +
  patchwork::plot_layout(ncol = 2)
```

these plots represent the three criteria to define the CBH in a segmented tree: 

* `get_plots_cbh_LAD` = the fuel layer containing the maximum LAD percentage (column named `maxlad_Hcbh`)
* `get_plots_cbh_maxdist` = the fuel layer located at the highest distance (column named `max_Hcbh`)
* `get_plots_cbh_lastdist` = the fuel layer separated by the last effective distance (column named `last_Hcbh`)

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(list = ls())
gc()
```
