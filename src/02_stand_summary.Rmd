# Forest Stand Summary

In this section we'll process the point cloud-extracted [tree list data](#processing) given stand boundaries that fall within the extent of the original point cloud data. When processing point cloud data with the objective for summarizing data within a forest stand, it is imperative to ensure that the point cloud extent completely covers and extends beyond the stand extent to avoid edge effects and tree artifacts.

```{r, warning=FALSE, message=FALSE, include=FALSE, echo=FALSE}
# bread-and-butter
library(tidyverse) # the tidyverse
library(viridis) # viridis colors
library(harrypotter) # hp colors
library(RColorBrewer) # brewer colors
library(scales) # work with number and plot scales
library(latex2exp)

# visualization
library(mapview) # interactive html maps
library(kableExtra) # tables
library(patchwork) # combine plots

# spatial analysis
library(terra) # raster
library(sf) # simple features
library(lidR) # lidar data
library(cloud2trees) # the cloud2trees

# knit options
knitr::opts_chunk$set(
  echo = TRUE
  , warning = FALSE
  , message = FALSE
  # , results = 'hide'
  , fig.width = 10.5
  , fig.height = 7
)
# option to put satellite imagery as base layer of mapview maps
  mapview::mapviewOptions(
    homebutton = FALSE
    # , basemaps = c("Esri.WorldImagery","OpenStreetMap")
    , basemaps = c("OpenStreetMap", "Esri.WorldImagery")
  )
# clean session
remove(list = ls())
gc()
```

## Load data

first, we'll load our stand data and the boundary data of the point cloud that we processed

```{r}
# las data bounds
las_ctg_sf <- sf::st_read("../data/point_cloud_processing_delivery/raw_las_ctg_info.gpkg", quiet = T)
# get our proj crs
proj_crs <- sf::st_crs(las_ctg_sf)
# stands
stand_sf <- sf::st_read("../data/QUIK-Fire_Boundary/QUIK-Fire_Boundary.shp", quiet = T) %>% 
  sf::st_transform(proj_crs) %>% 
  dplyr::rename_with(~tolower(stringr::str_replace_all(.x,"\\.", "_"))) %>% 
  dplyr::rename(unit_id = id) %>% 
  dplyr::mutate(
    stand_area_m2 = sf::st_area(.) %>% as.numeric()
    , stand_area_ha = stand_area_m2/10000
  )
# set our colors for the units
if(nrow(stand_sf)<length(harrypotter::hp_palettes$lunalovegood)){
  my_pal <- harrypotter::hp(n=nrow(stand_sf), option = "lunalovegood")
}else{
  my_pal <- viridis::turbo(n=nrow(stand_sf))
}
```

what is the stand data?

```{r}
stand_sf %>% dplyr::glimpse()
```

let's look at these bounds on a map

```{r}
mapview::mapview(
  las_ctg_sf
  , layer.name = "point cloud tile"
  , color = "black"
  , lwd = 1
  , alpha.regions = 0
  , label = FALSE
  , legend = FALSE
  , popup = FALSE
) +
mapview::mapview(
  stand_sf %>% dplyr::select(unit_name)
  , zcol = "unit_name"
  , col.regions = my_pal
  , layer.name = "stand bounds"
  , alpha.regions = 0.8
) 
```

we processed point cloud data well outside these stand bounds (it is not necessary to process data *this* far outside of our stands, a one tile buffer in this situation would have sufficed)

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

load in the tree top points data from `cloud2trees::cloud2trees()`

```{r}
# get the data from already run
treetops_sf <-
  list.files(
    "../data/point_cloud_processing_delivery"
    , pattern = "final_detected_tree_tops.*\\.gpkg$"
    , full.names = T
  ) %>% 
  normalizePath() %>% 
  purrr::map(\(x)
    sf::st_read(
      dsn = x
      , quiet = T
    )
  ) %>% 
  dplyr::bind_rows()
```

we'll keep only trees where the tree top point falls within one of our stands and then use this tree list to filter our crown data so that we get the full crown polygon even if it extends outside of the stand boundary

```{r}
treetops_sf <- treetops_sf %>% 
  sf::st_intersection(stand_sf %>% dplyr::select(unit_id,unit_name,tidyselect::starts_with("stand_area_")))
```

load in the tree crown polygon data from `cloud2trees::cloud2trees()` and filter based on the tree list

```{r, eval = F}
# get the data from already run
crowns_sf <-
  list.files(
    "../data/point_cloud_processing_delivery"
    , pattern = "final_detected_crowns.*\\.gpkg$"
    , full.names = T
  ) %>% 
  normalizePath() %>% 
  purrr::map(\(x)
    sf::st_read(
      dsn = x
      , quiet = T
    )
  ) %>% 
  dplyr::bind_rows() %>% 
  dplyr::inner_join(
    treetops_sf %>% 
      sf::st_drop_geometry() %>% 
      dplyr::select(treeID,unit_id,unit_name,tidyselect::starts_with("stand_area_"))
    , by = "treeID"
  )
# the records are the same
identical(nrow(treetops_sf), nrow(crowns_sf))
```

save the data by unit for sharing with a boss, coworker, friend, etc.

```{r}
# make a dir for saving this stand-level data to
outdir <- "../data/mogollon_rim_fire_unit_trees"
if(!dir.exists(outdir)){dir.create(outdir, showWarnings = F)}
```

```{r, eval=FALSE, message=FALSE, warning=FALSE, results=F}
# write crowns and tree tops
write_temp <- crowns_sf$unit_id %>%
  unique() %>%
  purrr::map(function(x, new_crs = proj_crs, my_outdir = outdir){
    # dsn's
    cf <- file.path( my_outdir, paste0("final_detected_crowns_unit_",x,".gpkg") )
    tf <- file.path( my_outdir, paste0("final_detected_tree_tops_unit_",x,".gpkg") )
    ### write the data to the disk
    # crown vector polygons
    sf::st_write(
      crowns_sf %>%
        dplyr::filter(unit_id == x) %>% 
        sf::st_transform(new_crs)
      , dsn = cf
      , append = FALSE
      , quiet = TRUE
    )
    # tree top vector points
    sf::st_write(
      # get tree points
      crowns_sf %>%
        dplyr::filter(unit_id == x) %>%
        sf::st_drop_geometry() %>%
        sf::st_as_sf(coords = c("tree_x", "tree_y"), crs = sf::st_crs(crowns_sf)) %>% 
        sf::st_transform(new_crs) %>% 
        dplyr::mutate(
          tree_x = sf::st_coordinates(.)[,1]
          , tree_y = sf::st_coordinates(.)[,2]
        )
      , dsn = tf
      , append = FALSE
      , quiet = TRUE
    )
  })
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

load in the DTM, aggregate to 2 m resolution, and write it

```{r}
dtm_rast <- terra::rast("../data/point_cloud_processing_delivery/dtm_1m.tif")
# quick plot
terra::plot(dtm_rast, axes = F, main = "DTM (m)")
terra::plot(terra::vect(stand_sf), add = T, col = NA, border = "black", lwd = 2)
```

aggregate to 2 m

```{r}
res_temp <- terra::res(dtm_rast)[1]
des_res_temp <- 2
if(res_temp<des_res_temp){
  dtm_rast <- terra::aggregate(
    dtm_rast
    , fact = round(des_res_temp/res_temp)
    , fun = "mean"
    , na.rm = T
    , cores = lasR::half_cores()
    , filename = file.path(outdir, paste0("dtm_",des_res_temp, "m.tif"))
    , overwrite = T
  )
}
# what is the res?
terra::res(dtm_rast)
```

```{r, include=FALSE, eval=T, echo=FALSE, warning=FALSE}
# write the stand bounds for use also
stand_sf %>% 
  sf::st_write(
    file.path(outdir, "stand_unit_bounds.gpkg")
    , quiet = T, append = FALSE
  )
```

we can also load in the CHM raster and look at that quickly

```{r, results=F, fig.show='asis'}
chm_rast <- terra::rast("../data/point_cloud_processing_delivery/chm_0.25m.tif")
# quick plot
chm_rast %>% 
  terra::aggregate(
    fact = 1/terra::res(chm_rast)[1]
    , fun = "mean"
    , na.rm = T
    , cores = lasR::half_cores()
  ) %>% 
  terra::plot(
    col = viridis::plasma(100)
    , axes = F, alpha = 0.8
    , main = "CHM (m)"
  )
terra::plot(terra::vect(stand_sf), add = T, col = NA, border = "black", lwd = 2)
```

## Silvicultural metrics

Let's look at some common stand-level forestry metrics

```{r}
### stand-level summaries
silv_metrics <-
  treetops_sf %>%
    sf::st_drop_geometry() %>% 
    # dplyr::filter(dbh_cm >= ostory_dbh_cm) %>% 
    dplyr::ungroup() %>%
    dplyr::group_by(unit_id, unit_name, stand_area_ha) %>%
    dplyr::summarise(
      n_trees = dplyr::n_distinct(treeID)
      , mean_dbh_cm = mean(dbh_cm, na.rm = T)
      , mean_tree_height_m = mean(tree_height_m, na.rm = T)
      , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T)
      , basal_area_m2 = sum(basal_area_m2, na.rm = T)
      , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T)
      , landfire_crown_biomass_kg = sum(landfire_crown_biomass_kg, na.rm = T)
      , cruz_crown_biomass_kg = sum(cruz_crown_biomass_kg, na.rm = T)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(
      trees_per_ha = (n_trees/stand_area_ha)
      , basal_area_m2_per_ha = (basal_area_m2/stand_area_ha)
      , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees)
      , landfire_cfl_kg_m2 = landfire_crown_biomass_kg/(stand_area_ha*10000)
      , cruz_cfl_kg_m2 = cruz_crown_biomass_kg/(stand_area_ha*10000)
    ) %>%
    dplyr::select(-c(sum_dbh_cm_sq,landfire_crown_biomass_kg,cruz_crown_biomass_kg))

### export tabular
write.csv(
    silv_metrics
    , file.path(outdir, "stand_silv_metrics.csv")
    , row.names = F
    , append = F
  )
```

stand-level silvicultural summary

```{r}
silv_metrics %>% 
  dplyr::select(
    unit_name
    , stand_area_ha
    , n_trees
    , mean_dbh_cm
    , qmd_cm
    , mean_tree_height_m
    , loreys_height_m
    , trees_per_ha
    , basal_area_m2_per_ha
    , landfire_cfl_kg_m2
    , cruz_cfl_kg_m2
  ) %>% 
  dplyr::mutate(
    dplyr::across(
      .cols = c(stand_area_ha, n_trees) 
      , .fns = ~ scales::comma(.x, accuracy = 1)
    )
  ) %>% 
  kableExtra::kbl(
    digits = 1
    , escape = F
    , caption = "Silvicultral metrics by stand unit"
    , col.names = c(
      "Unit Name"
      , "area (ha)"
      , "trees"
      , "mean<br>DBH (cm)"
      , "QMD (cm)"
      , "mean<br>Ht. (m)"
      , "Loreys<br>Ht. (m)"
      , "TPH"
      , "BA<br>m<sup>2</sup> ha<sup>-1</sup>"
      , "LANDFIRE CFL<br>kg m<sup>-2</sup>"
      , "Cruz CFL<br>kg m<sup>-2</sup>"
      )
  ) %>% 
  kableExtra::kable_styling()
```

### Height Distribution

```{r}
# there are always tree heights
treetops_sf %>%
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, color = unit_name, fill = unit_name)) +
  ggplot2::geom_density(alpha = 0.5) +
  ggplot2::facet_grid(cols = dplyr::vars(unit_name)) +
  ggplot2::scale_color_manual(values = my_pal) +
  ggplot2::scale_fill_manual(values = my_pal) +
  ggplot2::scale_x_continuous(breaks = scales::breaks_extended(11)) +
  ggplot2::labs(x = "tree ht. (m)", y = "", subtitle = "Distribution of tree height by stand") +
  ggplot2::theme_light() +
  ggplot2::theme(
    legend.position = "none"
    , axis.text.y = ggplot2::element_blank()
    , axis.ticks.y = ggplot2::element_blank()
    , strip.text = ggplot2::element_text(color = "black", size = 10)
  )
```

### DBH Distribution

```{r}
treetops_sf %>%
  ggplot2::ggplot(mapping = ggplot2::aes(x = dbh_cm, color = unit_name, fill = unit_name)) +
  ggplot2::geom_density(alpha = 0.5) +
  ggplot2::facet_grid(cols = dplyr::vars(unit_name)) +
  ggplot2::scale_color_manual(values = my_pal) +
  ggplot2::scale_fill_manual(values = my_pal) +
  ggplot2::scale_x_continuous(breaks = scales::breaks_extended(11)) +
  ggplot2::labs(x = "tree DBH (cm)", y = "", subtitle = "Distribution of tree DBH by stand") +
  ggplot2::theme_light() +
  ggplot2::theme(
    legend.position = "none"
    , axis.text.y = ggplot2::element_blank()
    , axis.ticks.y = ggplot2::element_blank()
    , strip.text = ggplot2::element_text(color = "black", size = 10)
  )
```

## Spatial Forest Structure

Because we have a spatial tree list, we can look at the spatial arrangement of forest structural metrics

first, let's make a function to crop the raster to a stand and plot the raster and stand together

```{r}
# function to crop and plot a raster data for a stand
plot_raster_stand_fn <- function(
    rast
    , stand
    , buffer=5
    , des_res=1
    , agg_fun = "mean"
    , stand_color = "black"
    , my_title = ""
    , scale_name = ""
    , bbox = F
) {
  # crop the raster
  crop_rast <- rast %>% 
    terra::crop(
      stand %>% 
        sf::st_bbox() %>% 
        sf::st_as_sfc() %>% 
        sf::st_buffer(buffer) %>% 
        terra::vect() %>% 
        terra::project(terra::crs(rast))
    )
  if(!bbox){
    crop_rast <- crop_rast %>% 
      terra::mask(
        stand %>% 
          sf::st_buffer(buffer) %>% 
          terra::vect() %>% 
          terra::project(terra::crs(rast))
      )
  }
  # aggregate the raster
  res_temp <- terra::res(rast)[1]
  if(res_temp<des_res){
    crop_rast <- terra::aggregate(
      crop_rast
      , fact = round(des_res/res_temp)
      , fun = agg_fun
      , na.rm = T
      , cores = lasR::half_cores()
    )
  }
  # plot it
  crop_rast %>% 
    terra::as.data.frame(xy=T) %>% 
    dplyr::rename(f=3) %>% 
    ggplot2::ggplot() +
    ggplot2::geom_tile(
      mapping = ggplot2::aes(x=x, y=y, fill = f)
    ) +
    ggplot2::geom_sf(
      data = stand %>% sf::st_transform(terra::crs(rast))
      , color = stand_color, fill = NA, lwd = 1.5
    ) +
    ggplot2::labs(title = my_title, fill = scale_name) + 
    ggplot2::theme_void() +
    ggplot2::theme(
      legend.title = ggplot2::element_text(size=7)
      , plot.title = ggplot2::element_text(size = 10)
      , plot.subtitle = ggplot2::element_text(size = 9)
    )
}
# plot_raster_stand_fn(
#   dtm_rast
#   , stand = stand_sf[1,]
#   , buffer = 5
#   , des_res = 1
#   , stand_color = my_pal[1]
#   , my_title = "DTM"
#   , scale_name = "DTM (m)"
# )
```

### CHM

the canopy height model is a raster dataset that represents the height of objects above the ground, we set the minimum height at `r min(terra::values(chm_rast), na.rm = T)` m

```{r}
# get the plot for each stand
plt_chm <- 1:nrow(stand_sf) %>% 
  purrr::map(function(x, ul = max(terra::values(chm_rast), na.rm = T), ll = 0){
    plot_raster_stand_fn(
      chm_rast
      , stand = stand_sf[x,]
      , buffer = 5
      , des_res = 2
      , stand_color = "black"
      , my_title = "Canopy Height Model"
      , scale_name = "CHM (m)"
      , agg_fun = "max"
    ) + 
    ggplot2::labs(subtitle = paste("Unit:",stand_sf[x,]$unit_name)) +
    ggplot2::scale_fill_viridis_c(option = "plasma",limits = c(ll,ul))
  })
```

check out our plots

```{r}
plt_chm
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

### Function to Rasterize

the CHM was easy to plot because it was already a raster dataset; what if we want to plot a raster of a metric based on our vector tree data?

we need to define a function to rasterize our spatial tree list by aggregating a selected metric within a raster cell

```{r}
vect_to_rast_fn <- function(
  vect
  , des_res = 1
  , buffer = 5
  , fun = "mean" # function(x){mean(x, na.rm=T)}
  , field = "your_vector_attribute"
  , zero_na = F
) {
  # sample sf object with a bounding box + buffer
  my_sf <- vect %>% 
    sf::st_bbox() %>% 
    sf::st_as_sfc(crs = sf::st_crs(vect)) %>% 
    sf::st_buffer(buffer)
  # extract bbox coordinates
  bbox <- sf::st_bbox(my_sf)
  # create a terra raster using the bbox
  my_raster <- terra::rast(
    xmin = bbox[1], ymin = bbox[2], xmax = bbox[3], ymax = bbox[4]
    , resolution = des_res
    , crs = sf::st_crs(vect)
  )
  # rasterize the vector data onto the grid, using a desired aggregation function (e.g., "mean")
  rasterized_data <- terra::rasterize(
    x = vect
    , y = my_raster
    , fun = fun
    , field = field
  )
  if(zero_na){rasterized_data <- terra::subst(rasterized_data,NA,0)}
  terra::crs(rasterized_data) <- vect %>% terra::vect() %>% terra::crs()
  return(rasterized_data)
}
# vect_to_rast_fn(
#   treetops_sf %>% dplyr::filter(unit_id==treetops_sf$unit_id[2])
#   , des_res = 10
#   , field = "dbh_cm"
#   , fun = "mean" #function(x){mean(x, na.rm=T)}
#   , zero_na = F
# ) %>%
# # terra::plot()
# terra::summary()
```

```{r, include=FALSE, eval=FALSE}
vect_to_rast_fn(
  treetops_sf %>% dplyr::filter(unit_id==treetops_sf$unit_id[2])
  , des_res = 10
  , field = "basal_area_m2"
  , fun = function(x){sum(x, na.rm=T)/((10^2)/10000)} #"sum"
  , zero_na = F
) %>% terra::plot()
```

we can combine our create a raster and plot it function

```{r}
# we can combine our create a raster and plot it function
vect_to_rast_plot_fn <- function(
  trees_vect
  , stand_vect
  , fun = "mean" # function(x){mean(x, na.rm=T)}
  , field = "your_vector_attribute"
  , zero_na = F 
  , buffer = 5
  , des_res = 10
  , stand_color = "black"
  , my_title = ""
  , scale_name = ""
) {
  # get the raster
  rast <- vect_to_rast_fn(
    vect = trees_vect
    , des_res = des_res
    , buffer = buffer
    , fun = fun
    , field = field
    , zero_na = zero_na
  )
  # plot it
  plot_raster_stand_fn(
      rast = rast
      , stand = stand_vect
      , buffer = buffer
      , des_res = des_res
      , stand_color = stand_color
      , my_title = my_title
      , scale_name = scale_name
  )
}
```

### Mean DBH

take this for a spin to get a raster of mean DBH plotted with our stand boundary

```{r}
# get the plot for each stand
plt_dbh <- 1:nrow(stand_sf) %>% 
  purrr::map(function(x, ul = max(treetops_sf$dbh_cm,na.rm = T), ll = 0){
    vect_to_rast_plot_fn(
      trees_vect = treetops_sf %>% dplyr::filter(unit_id == stand_sf[x,]$unit_id)
      , stand_vect = stand_sf[x,]
      , fun = "mean"
      , field = "dbh_cm"
      , zero_na = F 
      , buffer = 5
      , des_res = 20
      , stand_color = "black"
      , my_title = "Mean DBH"
      , scale_name = "DBH (cm)"
    ) +
    ggplot2::labs(subtitle = paste("Unit:",stand_sf[x,]$unit_name)) +
    ggplot2::scale_fill_distiller(palette = "Oranges", direction = 1, limits = c(ll,ul))
    # ggplot2::scale_fill_viridis_c(option = "mako", direction = -1, limits = c(ll,ul))
  })
```

check out our plots

```{r}
plt_dbh
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

### Mean Height

now get a raster of mean tree height plotted with our stand boundary which will be similar to the CHM but aggregated as if at the inventory plot level

```{r}
# get the plot for each stand
plt_height <- 1:nrow(stand_sf) %>% 
  purrr::map(function(x, ul = max(treetops_sf$tree_height_m,na.rm = T), ll = 0){
    vect_to_rast_plot_fn(
      trees_vect = treetops_sf %>% dplyr::filter(unit_id == stand_sf[x,]$unit_id)
      , stand_vect = stand_sf[x,]
      , fun = "mean"
      , field = "tree_height_m"
      , zero_na = F 
      , buffer = 5
      , des_res = 20
      , stand_color = "black"
      , my_title = "Mean Height"
      , scale_name = "Height (m)"
    ) +
    ggplot2::labs(subtitle = paste("Unit:",stand_sf[x,]$unit_name)) +
    ggplot2::scale_fill_distiller(palette = "YlOrBr", direction = 1, limits = c(ll,ul))
    # ggplot2::scale_fill_viridis_c(option = "mako", direction = -1, limits = c(ll,ul))
  })
```

check out our plots

```{r}
plt_height
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

### QMD

to get the quadratic mean diameter (QMD) we are going to have to create a custom function that takes a list of DBH values and returns a single value

QMD is a measure of the diameter of the tree of mean basal area:

$$
\textrm{quadratic mean diameter (QMD)} = \sqrt{\frac{\sum{d_{i}^{2}}}{n}}
$$

, where $d_{i}$ is the diameter at breast height of an individual tree, and $n$ is the total number of trees. 

```{r}
qmd_fn <- function(x) {
  sqrt(sum(x^2, na.rm=T)/length(x[!is.na(x)]))
}
# get the plot for each stand
plt_qmd <- 1:nrow(stand_sf) %>% 
  purrr::map(function(x, ul = round(qmd_fn(max(treetops_sf$dbh_cm,na.rm = T))*.95), ll = 0){
    vect_to_rast_plot_fn(
      trees_vect = treetops_sf %>% dplyr::filter(unit_id == stand_sf[x,]$unit_id)
      , stand_vect = stand_sf[x,]
      , fun = qmd_fn
      , field = "dbh_cm"
      , zero_na = F 
      , buffer = 5
      , des_res = 20
      , stand_color = "black"
      , my_title = "Quadratic Mean Diameter"
      , scale_name = "QMD (cm)"
    ) +
    ggplot2::labs(subtitle = paste("Unit:",stand_sf[x,]$unit_name)) +
    ggplot2::scale_fill_distiller(palette = "Blues", direction = 1, limits = c(ll,ul))
    # ggplot2::scale_fill_viridis_c(option = "cividis", begin = 0.55, limits = c(ll,ul))
  })
```

check out our plots

```{r}
plt_qmd
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

### Basal Area

to get Basal Area (BA) in square meters per hectare we will also need to create a function that uses the area of the raster cell

```{r}
# get the plot for each stand
# max(silv_metrics$basal_area_m2_per_ha)*2
plt_ba <- 1:nrow(stand_sf) %>% 
  purrr::map(function(x, my_res = 20, ul = NA, ll = NA){
    vect_to_rast_plot_fn(
      trees_vect = treetops_sf %>% dplyr::filter(unit_id == stand_sf[x,]$unit_id)
      , stand_vect = stand_sf[x,]
      , fun = function(x){sum(x, na.rm=T)/((my_res^2)/10000)}
      , field = "basal_area_m2"
      , zero_na = F 
      , buffer = 5
      , des_res = my_res
      , stand_color = "black"
      , my_title = "Basal Area"
      , scale_name = latex2exp::TeX("BA ($m ^ 2 \\cdot ha^{-1}$)")
    ) +
    ggplot2::labs(subtitle = paste("Unit:",stand_sf[x,]$unit_name)) +
    ggplot2::scale_fill_distiller(palette = "Purples", direction = 1, limits = c(ll,ul))
    # harrypotter::scale_fill_hp(option = "slytherin", limits = c(ll,ul))
  })
```

check out our plots

```{r}
plt_ba
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

### TPH

to get trees per hectare (TPH) we will also need to create a function that uses the area of the raster cell

```{r}
# get the plot for each stand
plt_tph <- 1:nrow(stand_sf) %>% 
  purrr::map(function(x, my_res = 20, ul = 2444, ll = NA){
    vect_to_rast_plot_fn(
      trees_vect = treetops_sf %>% dplyr::filter(unit_id == stand_sf[x,]$unit_id)
      , stand_vect = stand_sf[x,]
      , fun = function(x){length(x)/((my_res^2)/10000)}
      , field = "tree_height_m" # just need something to count 
      , zero_na = F 
      , buffer = 5
      , des_res = my_res
      , stand_color = "black"
      , my_title = "Trees per Hectare"
      , scale_name = "TPH"
    ) +
    ggplot2::labs(subtitle = paste("Unit:",stand_sf[x,]$unit_name)) +
    ggplot2::scale_fill_distiller(palette = "Greys", direction = 1, limits = c(ll,ul))
    # harrypotter::scale_fill_hp(option = "mischief", limits = c(ll,ul))
  })
```

check out our plots

```{r}
plt_tph
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

### CFL Cruz

to get canopy fuel load (CFL) we will also need to create a function that uses the area of the raster cell

CFL is the total amount of flammable material (like leaves, needles, branches) within the tree crowns in a given area and expressed in units of mass per unit area (e.g., kilograms per square meter).

First, we'll look at CFL based on the [Cruz et al. (2003)](https://scholar.google.com/scholar?cluster=316241498622221569&oi=gsb&hl=en&as_sdt=0,5) equations and the FIA forest type group

```{r}
# get the plot for each stand
plt_cfl_cruz <- 1:nrow(stand_sf) %>% 
  purrr::map(function(x, my_res = 20, ul = 6.2, ll = 0){
    vect_to_rast_plot_fn(
      trees_vect = treetops_sf %>% dplyr::filter(unit_id == stand_sf[x,]$unit_id)
      , stand_vect = stand_sf[x,]
      , fun = function(x){sum(x,na.rm = T)/(my_res^2)}
      , field = "cruz_crown_biomass_kg"
      , zero_na = F 
      , buffer = 5
      , des_res = my_res
      , stand_color = "black"
      , my_title = "Cruz estimated Canopy Fuel Load"
      , scale_name = latex2exp::TeX("Cruz CFL ($kg \\cdot m^{-2}$)")
    ) +
    ggplot2::labs(subtitle = paste("Unit:",stand_sf[x,]$unit_name)) +
    ggplot2::scale_fill_distiller(palette = "Reds", direction = 1, limits = c(ll,ul))
    # ggplot2::scale_fill_viridis_c(option = "rocket", begin = 0.5, direction = -1, limits = c(ll,ul))
  })
```

check out our plots

```{r}
plt_cfl_cruz
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

### CFL LANDFIRE

to get canopy fuel load (CFL) we will also need to create a function that uses the area of the raster cell

CFL is the total amount of flammable material (like leaves, needles, branches) within the tree crowns in a given area and expressed in units of mass per unit area (e.g., kilograms per square meter).

First, we'll look at CFL based on the [Cruz et al. (2003)](https://scholar.google.com/scholar?cluster=316241498622221569&oi=gsb&hl=en&as_sdt=0,5) equations and the FIA forest type group

```{r}
# get the plot for each stand
plt_cfl_landfire <- 1:nrow(stand_sf) %>% 
  purrr::map(function(x, my_res = 20, ul = 6.2, ll = 0){
    vect_to_rast_plot_fn(
      trees_vect = treetops_sf %>% dplyr::filter(unit_id == stand_sf[x,]$unit_id)
      , stand_vect = stand_sf[x,]
      , fun = function(x){sum(x,na.rm = T)/(my_res^2)}
      , field = "landfire_crown_biomass_kg"
      , zero_na = F 
      , buffer = 5
      , des_res = my_res
      , stand_color = "black"
      , my_title = "LANDFIRE estimated Canopy Fuel Load"
      , scale_name = latex2exp::TeX("LANDFIRE CFL ($kg \\cdot m^{-2}$)")
    ) +
    ggplot2::labs(subtitle = paste("Unit:",stand_sf[x,]$unit_name)) +
    ggplot2::scale_fill_distiller(palette = "Reds", direction = 1, limits = c(ll,ul))
  })
```

check out our plots

```{r}
plt_cfl_landfire
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
# ls()[stringr::str_starts(ls(),"plt_")]
gc()
```

### Combine by stand unit

put all desired plots into a list to combine by stand unit

```{r}
plt_list <- list(plt_ba, plt_qmd, plt_height, plt_tph, plt_cfl_cruz, plt_cfl_landfire)
```

combine the plots by stand unit

```{r}
plt_stands <- 1:nrow(stand_sf) %>% 
  purrr::map(function(x,my_stand_sf=stand_sf,my_plt_list=plt_list){
    # get just this stand plots
    plts <- my_plt_list %>%
      purrr::transpose() %>% 
      purrr::pluck(x)
    # patchwork them
    patchwork::wrap_plots(plts) +
      patchwork::plot_annotation(
        title = paste("Unit:",my_stand_sf[x,]$unit_name)
        , theme = ggplot2::theme(plot.title = ggplot2::element_text(size = 18, hjust = 0.5))
      ) &
      ggplot2::theme(
        plot.subtitle = ggplot2::element_blank()
        , legend.text = ggplot2::element_text(size=6.5)
        # , plot.background = ggplot2::element_rect(colour = "gray77", fill=NA, linewidth=1)
      )
  })
```

check out our plots

```{r}
plt_stands
```

## Canopy Cover

