# Tree Biomass Process{#s05}

In this section we'll use the benchmark data made available in the [`NeonTreeEvaluation`](https://github.com/weecology/NeonTreeEvaluation_package) data set ([Weinstein et al. 2021](https://scholar.google.com/scholar?cluster=4986448711981898434&hl=en&as_sdt=0,6)) to test a process for estimating biomass in kg at the tree level. The ultimate goal is to incorporate this process in the [`cloud2trees`](https://github.com/georgewoolsey/cloud2trees) package (Woolsey and Tinkham, 2024).

We will test out three methods for attaching biomass in kg to a spatial tree list:

1. Estimate single tree biomass (kg) using allometric equations based on predictors such as tree diameter, height, and species
    + This methodology is well represented in the literature with allometries developed for nearly all tree species ([Chojnacky et al. 2014](https://scholar.google.com/scholar?cluster=13769102016905655949&hl=en&as_sdt=0,5); [Ter-Mikaelian & Korzukhin 1997](https://scholar.google.com/scholar?cluster=6148302766104288498&hl=en&as_sdt=0,5))
    + [Gonzalez‐Akre et al. (2022)](https://scholar.google.com/scholar?cluster=14167690887599848846&oi=gsb&hl=en&as_sdt=0,5) developed an R package to perform this exact task: [`allodb`](https://github.com/ropensci/allodb).
2. Use models developed to predict canopy fuel stratum at the stand level based on common stand descriptors (e.g. TPH and  basal area) and distribute the stand-level estimate (in kg per m^2^ or kg per m^3^) across the individual trees in the stand
    + [Cruz et al. (2003)](https://scholar.google.com/scholar?cluster=316241498622221569&oi=gsb&hl=en&as_sdt=0,5) developed models to predict canopy fuel stratum at the stand level for four coniferous forest types common in the western US: Douglas-fir, ponderosa pine, lodgepole pine, and mixed conifer.
    + Models for other forests types are currently lacking which limits the scope of this methodology
3. Use raster estimates of canopy fuel stratum such as the [LANDFIRE](https://landfire.gov/fuel) database developed jointly by the USDA Forest Service and USDOI Office of Wildland Fire (OWF) and distribute the fuel estimate across the individual trees that fall in a raster cell
    + There is an R package for accessing the LANDFIRE data [`rlandfire`](https://github.com/bcknr/rlandfire)

## Preliminaries

Like [Cruz et al. (2003)](https://scholar.google.com/scholar?cluster=316241498622221569&oi=gsb&hl=en&as_sdt=0,5), we'll use the term "crown" to describe aerial fuels at the tree level and the term "canopy" at the stand level.

Below, we provide an overview of some commonly used fuel complex characteristics: canopy fuel load (CFL) and canopy bulk density (CBD). In simple terms, imagine a box filled with leaves, fuel load represents the total weight of all the leaves in the box while bulk density represents how tightly those leaves are packed within the box.

**Canopy Fuel Load**

* Definition: The total amount of flammable material (like leaves, needles, branches) within the tree crowns in a given area.
* Focus: Primarily on the mass of the fuel.
* Units: Typically expressed in units of mass per unit area (e.g., kilograms per square meter, tons per acre).
* Scope: Fuel load focuses on the overall amount of fuel.
* Significance: Important for understanding the overall fire potential of an area. A higher fuel load generally means more potential fuel for a fire to consume.

**Canopy Bulk Density**

* Definition: The mass of flammable material per unit volume of the tree crown.
* Focus: Considers both the mass of fuel and the space it occupies.
* Units: Typically expressed in units of mass per unit volume (e.g., kilograms per cubic meter).
* Scope: Bulk density considers how the fuel load is distributed within the tree crown.
* Significance: Crucial for predicting how easily a fire can spread through the tree crowns. Higher bulk density can increase the likelihood of crown fires.

## Data Load

load the libraries

```{r, warning=FALSE, message=FALSE}
# bread-and-butter
library(tidyverse) # the tidyverse
library(viridis) # viridis colors
library(harrypotter) # hp colors
library(RColorBrewer) # brewer colors
library(scales) # work with number and plot scales
library(latex2exp)

# visualization
library(mapview) # interactive html maps
library(kableExtra) # tables
library(patchwork) # combine plots
library(ggnewscale) # ggnewscale
library(rgl) # rgl plotting

# spatial analysis
library(terra) # raster
library(sf) # simple features
library(lidR) # lidar data
library(cloud2trees) # tha cloud2trees
library(NeonTreeEvaluation) # benchmark data
library(allodb) # allometric biomass (kg) estimates
```

```{r, include=F, warning=F, message=F}
# knit options
knitr::opts_chunk$set(
  echo = TRUE
  , warning = FALSE
  , message = FALSE
  # , results = 'hide'
  , fig.width = 10.5
  , fig.height = 7
)
# option to put satellite imagery as base layer of mapview maps
  mapview::mapviewOptions(
    homebutton = FALSE
    # , basemaps = c("Esri.WorldImagery","OpenStreetMap")
    , basemaps = c("Esri.WorldImagery", "OpenStreetMap")
  )
# clean session
remove(list = ls())
gc()
```

```{r, include=FALSE, eval=TRUE}
# pointsByZSlice from leafR causes errors
pointsByZSlice <- leafR::pointsByZSlice
```

## Example Lidar Data

Let's load an example lidar dataset from Weinstein et al. ([2021](https://scholar.google.com/scholar?cluster=4986448711981898434&hl=en&as_sdt=0,6)) in their `NeonTreeEvaluation` package.

We'll use data from a NEON site that we know has conifers: RMNP (Rocky Mountain National Park)

```{r}
# get the laz file path
las_f_path_temp <- system.file(package = "NeonTreeEvaluation", "extdata") %>% 
    list.files(recursive = T, pattern = ".*\\.(laz|las)$", full.names = T) %>% 
    unique() %>% 
    dplyr::as_tibble() %>%
    dplyr::rename(f_path = 1) %>% 
    dplyr::filter(
      stringr::str_detect(f_path,  "RMNP")
    ) %>% 
    dplyr::slice(15) %>% 
    dplyr::pull(f_path)
```

check the data

```{r}
# check the data
lidR::readLAS(las_f_path_temp) %>% 
  lidR::plot(
    color = "Z", breaks = "quantile", bg = "white", legend = T
   , pal = harrypotter::hp(n=50, house = "gryffindor")
  )
```

### `cloud2trees` that lidar data

extract trees from the lidar data using `cloud2trees`

we will estimate DBH, CBH, and forest type for this data

```{r, message=FALSE, results=FALSE}
# save our output_dir
od <- "c:/data/usfs/point_cloud_tree_detection_ex/data/"
  # tempdir()
chk_file_temp <- file.path(od,"biomass_point_cloud_processing_delivery","final_detected_tree_tops.gpkg")
if(!file.exists(chk_file_temp)){
  # cloud2trees
  cloud2trees_ans <- cloud2trees::cloud2trees(
    input_las_dir = las_f_path_temp
    , output_dir = od
    , keep_intrmdt = T
    , estimate_tree_dbh = T
    , estimate_tree_type = T
    , estimate_tree_hmd = T
    , estimate_tree_cbh = T, cbh_estimate_missing_cbh = T, cbh_tree_sample_n = 55
  )
}else{
  cloud2trees_ans <- list(
    treetops_sf = sf::st_read(chk_file_temp, quiet = T)
  )
}

```

```{r, include = F, eval = F, results=F, message=F}
cloud2trees_ans$treetops_sf <- cloud2trees::trees_dbh(cloud2trees_ans$treetops_sf)
```

let's see what we got

```{r}
cloud2trees_ans$treetops_sf %>% dplyr::glimpse()
```

create a column filter for columns not to see in the `glimpse()`s below

```{r}
col_not_sel <- c(
  "fia_est_dbh_cm", "fia_est_dbh_cm_lower", "fia_est_dbh_cm_upper"
  , "dbh_m", "radius_m","basal_area_ft2"           
  , "ptcld_extracted_dbh_cm","ptcld_predicted_dbh_cm","is_training_cbh"          
  , "forest_type_group", "hardwood_softwood", "comp_trees_per_ha"        
  , "comp_relative_tree_height","comp_dist_to_nearest_m","is_training_hmd"          
  , "geometry"
)
```

where is this?

```{r}
# where?
cloud2trees_ans$treetops_sf %>% 
  mapview::mapview(layer.name = "trees")
```

*zoom out if you can't see anything*

what does our CBH data look like?

```{r}
cloud2trees_ans$treetops_sf %>% 
  ggplot(mapping = aes(x = tree_height_m, y = tree_cbh_m, color = is_training_cbh)) +
  geom_point() +
  scale_color_viridis_d() +
  labs(x = "height (m)", y = "CBH (m)", color = "is CBH\nfrom cloud") +
  theme_light()
  
```

what does our DBH data look like?

```{r}
cloud2trees_ans$treetops_sf %>% 
  ggplot(mapping = aes(x = tree_height_m, y = dbh_cm)) +
  geom_point(color = "navy") +
  labs(x = "height (m)", y = "DBH (cm)") +
  theme_light()
  
```

how about the forest type?

```{r}
cloud2trees_ans$treetops_sf %>% 
  sf::st_drop_geometry() %>% 
  dplyr::count(forest_type_group)
```

## Method 1: single tree biomass (kg) using allometric equations{#method1}

The first method we'll explore for attaching biomass in kg to a spatial tree list is estimating single tree biomass (kg) using allometric equations based on predictors such as tree diameter, height, and species.

This methodology is well represented in the literature with allometries developed for nearly all tree species ([Chojnacky et al. 2014](https://scholar.google.com/scholar?cluster=13769102016905655949&hl=en&as_sdt=0,5); [Ter-Mikaelian & Korzukhin 1997](https://scholar.google.com/scholar?cluster=6148302766104288498&hl=en&as_sdt=0,5)). [Gonzalez‐Akre et al. (2022)](https://scholar.google.com/scholar?cluster=14167690887599848846&oi=gsb&hl=en&as_sdt=0,5) developed an R package to perform this exact task: [`allodb`](https://github.com/ropensci/allodb).

### Define species based on forest type group

`cloud2trees` gives us USDA Forest Inventory and Analysis (FIA) forest type group codes when we set the parameter `estimate_tree_type = T`. However, the `allodb` package requires genus and species information to estimate tree biomass. We need to make or find a lookup table to map the FIA forest type group to the genus and species.

Alternatively, we can use the `allodb::new_equations()` function to modify the set of equations that will be used to estimate the biomass

#### Manual

we can manually set the genus and species to PICO

```{r}
cloud2trees_ans$treetops_sf$allodb_biomass_kg <- allodb::get_biomass(
  dbh = cloud2trees_ans$treetops_sf$dbh_cm
  , genus = rep("Pinus", times = nrow(cloud2trees_ans$treetops_sf))
  , species = rep("contorta", times = nrow(cloud2trees_ans$treetops_sf))
  , coords = 
    cloud2trees_ans$treetops_sf %>%
      sf::st_transform(crs = sf::st_crs(4326)) %>%
      sf::st_coordinates() %>% 
      dplyr::as_tibble()
)
```

what did we get back?

```{r}
cloud2trees_ans$treetops_sf$allodb_biomass_kg %>% 
  summary()
```

let's plot biomass versus tree height because height comes directly from the point cloud

```{r}
cloud2trees_ans$treetops_sf %>% 
  ggplot(mapping = aes(x = tree_height_m, y = allodb_biomass_kg, color = allodb_biomass_kg)) +
  geom_point() +
  harrypotter::scale_color_hp(option = "slytherin") +
  scale_x_continuous(breaks = scales::extended_breaks(n = 11)) +
  scale_y_continuous(breaks = scales::extended_breaks(n = 11)) +
  labs(x = "height (m)", y = "biomass (kg)") +
  theme_light() +
  theme(legend.position = "none")

```

note that there is variation in the predicted biomass at a given height that is introduced from the variation in location of the trees

let's figure out a mapping between genus/species and FIA forest types

```{r}
fia_trees <- system.file(package = "cloud2trees", "extdata", "treemap") %>% 
  list.files(full.names = T) %>% 
  stringr::str_subset("tree_table.csv") %>% 
  readr::read_csv(show_col_types = F, progress = F) %>% 
  dplyr::rename_with(tolower)
```

what is in the FIA tree table from TreeMap?

```{r}
fia_trees %>% 
  dplyr::glimpse()
```

we could overlay the TreeMap raster with the FIA forest type raster and aggregate the tree species by forest type......but at that point it seems like we might as well utilize the TreeMap FIA data from [Riley et al. (2021)](https://doi.org/10.2737/RDS-2021-0074) to build a [softmax regression (i.e. multinomial logistic regression)](https://bookdown.org/content/3686/nominal-predicted-variable.html) to predict the nominal variable tree species using the predictors tree height and location extracted from the point cloud data. This option would most closely follow the process most represented in the existing literature. Note that to predict the nominal variable tree species we could also use a random forest classifier as in [Meng et al. (2024)](https://doi.org/10.3390/f15122110).

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Method 2: stand-level canopy fuels models{#method2}

The first method we'll explore for attaching biomass in kg to a spatial tree list is by using models developed to predict canopy fuel stratum at the stand level based on common stand descriptors (e.g. TPH and  basal area) and distribute the stand-level estimate (in kg per m^2^ or kg per m^3^) across the individual trees in the stand. The primary challenge with this methodology is that, currently a very limited set of forests types are represented in the literature by these stand-level models. This information gap limits the scope of this methodology.

### Cruz et al. 2003 equations

[Cruz et al. (2003)](https://scholar.google.com/scholar?cluster=316241498622221569&oi=gsb&hl=en&as_sdt=0,5) developed models to predict canopy fuel stratum at the stand level for four coniferous forest types common in the western US: Douglas-fir, ponderosa pine, lodgepole pine, and mixed conifer.

Let's build a function to utilize those models for data at the stand level to calculate Canopy Bulk Density (CBD) in kilograms per cubic meter

```{r}
get_cruz_stand_kg_per_m3 <- function(forest_type_group_code, basal_area_m2_per_ha, trees_per_ha){
  forest_type_group_code <- dplyr::coalesce(as.numeric(forest_type_group_code), 0)
  # Cruz et al. (2003)
  # https://scholar.google.com/scholar?cluster=316241498622221569&oi=gsb&hl=en&as_sdt=0,5
  # Page 46, Table 4
  if(!is.na(forest_type_group_code) && forest_type_group_code == 200){
    #Douglas-Fir Group
    b0 = -7.380
    b1 = 0.479
    b2 = 0.625
  }else if(!is.na(forest_type_group_code) && forest_type_group_code == 220){
    #Ponderosa Pine Group
    b0 = -6.649
    b1 = 0.435
    b2 = 0.579
  }else if(!is.na(forest_type_group_code) && forest_type_group_code == 280){
    #Lodgepole Pine Group
    b0 = -7.852
    b1 = 0.349
    b2 = 0.711
  }else if(!is.na(forest_type_group_code) && forest_type_group_code %in% c(120,260,320) ){
    #Mixed Conifer Group
    b0 = -8.445
    b1 = 0.319
    b2 = 0.859
  }else{
    #No Cruz et al. formulas for these YET!!!
    b0 = as.numeric(NA)
    b1 = as.numeric(NA)
    b2 = as.numeric(NA)
  }
  #Apply Cruz et al. if species found
  if(!is.na(b0)){
    return( 
      exp(b0 + b1 * log(basal_area_m2_per_ha) + b2 * log(trees_per_ha))
    )
  }else{
    return(as.numeric(NA))
  }
}
```

test our Cruz et al. (2003) `get_cruz_stand_kg_per_m3()` function

```{r}
get_cruz_stand_kg_per_m3(
  forest_type_group_code = 220 # ponderosa pine
  , basal_area_m2_per_ha = 25
  , trees_per_ha = 600
)
```

let's make a fake stand ID and data frame to show how to use this

```{r}
# fake a stand
cloud2trees_ans$treetops_sf <- cloud2trees_ans$treetops_sf %>% 
  dplyr::mutate(
    # ~2/3 will be "2", ~1/3 will be "1"
    stand_id = runif(n = nrow(cloud2trees_ans$treetops_sf), min = 0, max = 3) %>% 
      ceiling() %>% 
      ifelse(.==3,2,.)
  )
# aggregate
fake_stand_temp <- 
  cloud2trees_ans$treetops_sf %>% 
  sf::st_drop_geometry() %>% 
  # aggregate to stand level
  dplyr::group_by(stand_id, forest_type_group_code) %>% 
  dplyr::summarise(
    trees = dplyr::n()
    , basal_area_m2 = sum(basal_area_m2, na.rm = T)
  ) %>% 
  # fake per ha calcs
  dplyr::ungroup() %>% 
  dplyr::mutate(
    basal_area_m2_per_ha = basal_area_m2/0.1
    , trees_per_ha = trees/0.1
  )
fake_stand_temp %>% dplyr::glimpse()
```

apply our Cruz et al. (2003) `get_cruz_stand_kg_per_m3()` function to the data frame

```{r}
fake_stand_temp <- fake_stand_temp %>% 
  dplyr::ungroup() %>% 
  dplyr::rowwise() %>% # this is key
  dplyr::mutate(
    kg_per_m3 = get_cruz_stand_kg_per_m3(
      forest_type_group_code = forest_type_group_code
      , basal_area_m2_per_ha = basal_area_m2_per_ha
      , trees_per_ha = trees_per_ha
    )
  ) %>% 
  dplyr::ungroup()
fake_stand_temp %>% dplyr::glimpse()
```

looks good

### Define a "stand" using raster

for our `cloud2trees` process, we'll define a stand in the point cloud detected tree list using the USFS Forest Type Groups of the Continental United States raster Wilson (2023) available online [here](https://di-usfsdata.img.arcgis.com/arcgis/rest/services/CONUS_forest_type_group_2018_masked_202105122120120/ImageServer) with a data overview [here](https://www.arcgis.com/home/item.html?id=10760c83b9e44923bd3c18efdaa7319d) which was used to attach the tree species group to individual trees detected from the point cloud data based on spatial location.

let's read in the raster which we downloaded with `cloud2trees::get_data()`

```{r}
foresttype <- terra::rast(
  system.file(package = "cloud2trees", "extdata", "foresttype", "foresttype.tif")
)
```

what is this?

```{r}
foresttype
```

pull in the extent of our point cloud catalog

```{r}
las_ctg_sf <- sf::st_read(
  file.path(od, "biomass_point_cloud_processing_delivery", "raw_las_ctg_info.gpkg")
  , quiet = T
)
```

crop the raster to our extent with a buffer and change the cell values to the total cell area

```{r}
foresttype_crop <- foresttype %>% 
  terra::crop(
    las_ctg_sf %>% 
      sf::st_union() %>% 
      sf::st_buffer(50) %>% 
      terra::vect() %>% 
      terra::project(terra::crs(foresttype))
  ) %>% 
  terra::cellSize(transform = F)
```

we will only use the data structure of this raster and not the values because we already have the forest type group in our tree list since we set the `estimate_tree_type = T` in our call to `cloud2trees::cloud2trees()`

```{r}
plt_temp <- foresttype_crop %>% 
  terra::as.data.frame(xy=T, cells = T) %>%
  ggplot() + 
  geom_tile(mapping = aes(x=x,y=y,text=cell), fill = NA, color = "gray33") +
  geom_text(mapping = aes(x=x,y=y,label=cell), fill = NA, color = "black") +
  theme_void() +
  theme(axis.text = element_blank(), axis.title = element_blank())
plt_temp
```

we only need to get the cell id to use this to group our tree list into "stands"

```{r}
cloud2trees_ans$treetops_sf$stand_id <- 
  # use terra::extract to get the cell id
  terra::extract(
    x = foresttype_crop
    , y = cloud2trees_ans$treetops_sf %>% 
      terra::vect() %>% 
      terra::project(terra::crs(foresttype))
    , cells = T # cell numbers are also returned
  ) %>% 
  dplyr::pull(cell)
```

let's look at this spatially to make sure it makes sense

```{r}
plt_temp +
  cloud2trees_ans$treetops_sf %>% 
  sf::st_transform(crs = terra::crs(foresttype)) %>%
  geom_sf(mapping = aes(color = as.factor(stand_id))) +
  labs(color = "cell id\nwe'll call stand")
```

the challenge now is that we need to account for cases when our point cloud scan only overlaps a portion of a raster cell to scale our per hectare values

how does the point cloud extent look with our tree list?

```{r}
plt_temp <- plt_temp +
  # point cloud boundary
  geom_sf(
    data = las_ctg_sf %>% 
      sf::st_union() %>%
      sf::st_transform(crs = terra::crs(foresttype))
    , fill = NA, color = "red", lwd = 2
  ) +
  # tree points
  geom_sf(
    data = cloud2trees_ans$treetops_sf %>% 
      sf::st_transform(crs = terra::crs(foresttype))
    , mapping = aes(color = as.factor(stand_id))
  ) +
  labs(color = "cell id\nwe'll call stand")
plt_temp
```

we'll clean up our tree list columns that we just made so that we can create functions below to accomplish this process

```{r}
cloud2trees_ans$treetops_sf <- cloud2trees_ans$treetops_sf %>% 
  dplyr::select(-c(stand_id))
```

we need to get a data frame of the cell numbers with the area of the raster cells that overlap with the point cloud extent. if the extent fully covers the raster cell, the area should be the area of the cell (e.g. 90 x 90 = 8100 sq. m). if the extent only partially covers the cell, only the portion of the cell covered by the extent should be included in the area.

```{r}
overlap_df_temp <- terra::rasterize(
    x = las_ctg_sf %>% 
      sf::st_union() %>% 
      terra::vect() %>% 
      terra::project(terra::crs(foresttype))
    , y = foresttype_crop
    , field = c(1)
    , cover = T
  ) %>% 
  terra::as.data.frame(cells = T) %>% 
  dplyr::rename(pct_overlap = layer)
```

what is this?

```{r}
overlap_df_temp %>% dplyr::glimpse()
```

create a data frame of the cropped raster and join our overlap data to create a "stand" data frame

```{r}
stand_df_temp <-
  foresttype_crop %>% 
  terra::as.data.frame(xy = T, cells = T, na.rm = F) %>% 
  # join on pct overlap with las_ctg
  dplyr::left_join(
    overlap_df_temp
    , by = "cell"
  ) %>% 
  dplyr::rename(stand_id = cell) %>% 
  dplyr::mutate(
    overlap_area_m2 = ( area*dplyr::coalesce(pct_overlap, 0) )
    , overlap_area_ha = overlap_area_m2 / 10000
  )
```

what is this?

```{r}
stand_df_temp %>% dplyr::glimpse()
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(foresttype_crop, fia_trees)
gc()
```

#### Function to calculate polygon overlap of raster

let's create a function to ingest a raster and a polygon and calculate the area of each raster cell that overlaps with the polygon

```{r}
calc_rast_cell_overlap <- function(rast, poly, buff = 100) {
  if(!inherits(rast, "SpatRaster")){
    stop("must pass a SpatRaster object to `rast`")
  }
  # convert to terra vector with same projection
  if(!inherits(poly, "SpatVector") && inherits(poly, "sf")){
    poly_vect <- poly %>% 
      sf::st_union() %>% 
      terra::vect() %>% 
      terra::project(terra::crs(rast))
  }else if(inherits(poly, "SpatVector")){
    poly_vect <- poly %>% 
      terra::union() %>% 
      terra::project(terra::crs(rast))
  }else{
    stop("must pass a spatial SpatVector or sf object to `poly`")
  }
  
  # crop the raster to our extent with a buffer and change the cell values to the total cell area
  r_crop <- rast %>% 
    terra::crop(poly_vect %>% terra::buffer(width = buff)) %>% 
    terra::cellSize(transform = F) # converts cell value to cell area
  
  # get a data frame of the cell numbers with the area of the raster cells that overlap with the poly extent
  overlap_df_temp <- terra::rasterize(
    x = poly_vect
    , y = r_crop
    , field = c(1)
    , cover = T
  ) %>% 
  terra::as.data.frame(cells = T) %>% 
  dplyr::rename(pct_overlap = layer)
  
  # create a data frame of the cropped raster and join our overlap data to create a "stand" data frame
  stand_df <-
    r_crop %>% 
    terra::as.data.frame(xy = T, cells = T, na.rm = F) %>% 
    # join on pct overlap with las_ctg
    dplyr::left_join(
      overlap_df_temp
      , by = "cell"
    ) %>% 
    dplyr::mutate(
      overlap_area_m2 = ( area*dplyr::coalesce(pct_overlap, 0) )
      , overlap_area_ha = overlap_area_m2 / 10000
    )
  
  return(list(
    df = stand_df
    , rast = r_crop
  ))
}
```

test out the `calc_rast_cell_overlap()` function

```{r}
calc_rast_cell_overlap(rast = foresttype, poly = las_ctg_sf) %>% 
  purrr::pluck("df") %>% 
  dplyr::glimpse()
```

#### Function to create tree columns needed for aggregation

before we aggregate trees to the raster cell level we need to calculate tree-level values we'll need for the back transformation from stand-level metrics to tree level metrics such as crown volume in kilograms per cubed meter so that the mean stand kg/m3 * tree m3 = tree kg

```{r}
calc_tree_level_cols <- function(df){
  # # proportion of crown length to have max crown width at 
  # # 0.5 is a perfect ellipsoid, 0 is more conical, 1 looks like an icecream cone
  # # link to forest type
  # ht_to_max = 0.5 
  
  ## check for cols
  nms <- names(df) %>% dplyr::coalesce("")
  has_cols <- c("crown_area_m2", "tree_height_m", "tree_cbh_m") %>% 
    purrr::map(function(x){
      stringr::str_equal(tolower(nms), x) %>% 
      max() # do any columns match, T=1
    }) %>% 
    unlist() %>% 
    min()
  if(has_cols==0){
    stop("the `df` data does not contain the columns `crown_area_m2`, `tree_height_m`, and `tree_cbh_m`, ensure columns exist")
  }
  
  ## basal area
  if(
    !(stringr::str_detect(nms, "basal_area_m2") %>% any())
    && (stringr::str_detect(nms, "dbh_cm") %>% any())
  ){
    df <- df %>% 
      dplyr::mutate(
        dbh_cm = as.numeric(dbh_cm)
        , basal_area_m2 = pi * (((dbh_cm/100)/2)^2) 
      )
  }else if(
    !(stringr::str_detect(nms, "basal_area_m2") %>% any())
    && (stringr::str_detect(nms, "dbh_m") %>% any())
  ){
    df <- df %>% 
      dplyr::mutate(
        dbh_m = as.numeric(dbh_m)
        , basal_area_m2 = pi * ((dbh_m/2)^2) 
      )
  }else if(
    (stringr::str_detect(nms, "basal_area_m2") %>% any())
  ){
    df <- df %>% 
      dplyr::mutate(
        basal_area_m2 = as.numeric(basal_area_m2)
      )
  }else{
    stop(paste0(
      "the `df` data does not contain the columns `basal_area_m2`, `dbh_cm`, or `dbh_m`"
      , "\n .... at least one of these columns must be present"
    ))
  }
  
  ## apply the crown calculations
  r_df <- df %>% 
    dplyr::ungroup() %>% 
    dplyr::mutate(
      crown_area_m2 = as.numeric(crown_area_m2)
      , tree_height_m = as.numeric(tree_height_m)
      , tree_cbh_m = as.numeric(tree_cbh_m)
    ) %>% 
    # apply the calculations
    dplyr::mutate(
      #calculate crown diameter (m) = SQRT(area/pi) * 2
      crown_dia_m = sqrt(crown_area_m2 / pi) * 2
      #calculate crown length (m)
      , crown_length_m = tree_height_m - tree_cbh_m
      # calculate crown volume [4/3 * pi * a * b * c] 
      # which is [4/3 * pi * (crownlength/2) * (max crown radius) * (max crown radius)]
      ## !!!!!!!!!!!!!!!!!!11 source??????????????????????????????????????????????????????????????
      , crown_volume_m3 = (4/3) * pi * ((crown_length_m/2)) * ((crown_dia_m/2)^2)
      # #calculate height to max crown
      # , height_to_max = (crown_length_m * ht_to_max) + tree_cbh_m
    )
  return(r_df)
}
```

apply the `calc_tree_level_cols()` function to our tree list data

```{r}
cloud2trees_ans$treetops_sf <- cloud2trees_ans$treetops_sf %>% 
  calc_tree_level_cols()
# what?
cloud2trees_ans$treetops_sf %>% dplyr::select(-dplyr::any_of(col_not_sel)) %>% dplyr::glimpse()
```

#### Function to aggregate trees in raster cell

create a function to aggregate our tree list to the raster cell level and join to the raster cell overlap data by calling `calc_rast_cell_overlap()` within the function

```{r}
calc_rast_cell_trees <- function(rast, tree_list, poly_extent, buffer = 100, calc_tree_level_cols=T){
  if(!inherits(tree_list, "sf")){
    stop("must pass a spatial sf object to `tree_list`")
  }
  # check if not points
  if( min(sf::st_is(tree_list, type = c("POINT", "MULTIPOINT"))) == 0 ){
    stop(paste0(
      "data passed to `tree_list` is not point or multipoint data"
      , "\n see sf::st_geometry_type"
    ))
  }
  
  # calc_rast_cell_overlap
  overlap_ans <- calc_rast_cell_overlap(rast = rast, poly = poly_extent, buff = buffer)
  
  # attach cell to trees
  tree_list$cell <- 
    # use terra::extract to get the cell id
    terra::extract(
      x = overlap_ans$rast
      , y = tree_list %>% 
        terra::vect() %>% 
        terra::project(terra::crs(overlap_ans$rast))
      , cells = T # cell numbers are also returned
    ) %>% 
    dplyr::pull(cell)
  
  # check calc_tree_level_cols
  if(calc_tree_level_cols==T){
     tree_list <- tree_list %>% 
       calc_tree_level_cols()
  }
  
  # check col names
  nms <- names(tree_list) %>% dplyr::coalesce("")
  # aggregate tree list to cell
  trees_agg <- tree_list %>% 
    sf::st_drop_geometry() %>% 
    dplyr::group_by(cell)
  
  # summarize
  if(calc_tree_level_cols==T){
    trees_agg <- trees_agg %>% 
      dplyr::summarise(
        trees = dplyr::n()
        , basal_area_m2 = sum(basal_area_m2, na.rm = T)
        , mean_crown_length_m = mean(crown_length_m, na.rm = T)
        , sum_crown_volume_m3 = sum(crown_volume_m3, na.rm = T)
      ) %>% 
      dplyr::ungroup()
  }else if(stringr::str_detect(nms, "basal_area_m2") %>% any()){
    trees_agg <- trees_agg %>% 
      dplyr::summarise(
        trees = dplyr::n()
        , basal_area_m2 = sum(basal_area_m2, na.rm = T)
      ) %>% 
      dplyr::ungroup()
  }else{
    trees_agg <- trees_agg %>% 
      # aggregate to stand level
      dplyr::group_by(cell) %>% 
      dplyr::summarise(
        trees = dplyr::n()
      ) %>% 
      dplyr::mutate(basal_area_m2 = as.numeric(NA)) %>% 
      dplyr::ungroup()
  }
  
  # join to raster area data
  r_df <- overlap_ans$df %>% 
    dplyr::left_join(trees_agg, by = "cell") %>%
    dplyr::mutate(
      basal_area_m2_per_ha = basal_area_m2/overlap_area_ha
      , trees_per_ha = trees/overlap_area_ha
    ) 
  
  #return
  return(list(
    cell_df = r_df
    , tree_list = tree_list
    , rast = overlap_ans$rast
  ))
}
```

test `calc_rast_cell_trees()` out

```{r}
calc_rast_cell_trees_ans <- calc_rast_cell_trees(
    rast = foresttype
    , tree_list = cloud2trees_ans$treetops_sf
    , poly_extent = las_ctg_sf
    , calc_tree_level_cols = T
  )
# what?
calc_rast_cell_trees_ans %>% 
  purrr::pluck("cell_df") %>% 
  dplyr::glimpse()
```

### Distribute stand CBD (kg/m3) to trees

Now that we have trees grouped into "stands" (i.e. raster cells), and we have raster cell area overlaps with our point cloud catalog extent, we can use our `get_cruz_stand_kg_per_m3()` function to calculate the stand level CBH in kilograms per cubed meter and then distribute that value to our tree list

first, we'll use our `get_cruz_stand_kg_per_m3()` function to calculate the stand level CBH in kilograms per cubed meter

```{r}
distribute_stand_fuel_load <- function(cell_df, tree_list, cbd_method = "cruz") {
  # check the method
  cbd_method <- dplyr::coalesce(cbd_method[1], "") %>% tolower()
  if( !(cbd_method %in% c("cruz", "landfire")) ){
    stop("`cbd_method` parameter must be one of \"cruz\" or \"landfire\"")
  }
  
  # for cruz, need to get the forest type group code
  # we'll do this based on the most common code in the tree data
  nms <- names(tree_list) %>% dplyr::coalesce("")
  if(
    !(stringr::str_detect(nms, "cell") %>% any())
  ){
    stop("tree_list data must have the column `cell`...should be in the output of calc_rast_cell_trees()?")
  }
  if(
    cbd_method == "cruz"
    && !(stringr::str_detect(nms, "forest_type_group_code") %>% any())
  ){
    stop(paste0(
      "cbd_method set to `cruz` but the `forest_type_group_code` does not exist in the tree list data"
      , "\n try running cloud2trees::trees_type() first"
    ))
  }
  #############################################
  # CRUZ
  #############################################
  if(cbd_method == "cruz"){
    # select most common forest type group in a cell based on tree list
    cell_ft_temp <- tree_list %>% 
      sf::st_drop_geometry() %>% 
      dplyr::mutate(
        is_na_ft = ifelse(
          is.na(as.numeric(forest_type_group_code))
          , 1
          , 0
        )
      ) %>% 
      dplyr::group_by(cell, forest_type_group_code, is_na_ft) %>% 
      dplyr::summarise(trees = dplyr::n()) %>% 
      dplyr::group_by(cell) %>% 
      dplyr::arrange(cell, desc(is_na_ft), desc(trees)) %>% 
      dplyr::filter(dplyr::row_number()==1) %>% 
      dplyr::ungroup()
  
    # calculate fuel loading at the stand level
    cell_df <- cell_df %>% 
      dplyr::ungroup() %>% 
      dplyr::left_join(cell_ft_temp %>% dplyr::select(cell,forest_type_group_code), by = "cell") %>% 
      dplyr::rowwise() %>% # this is key
      dplyr::mutate(
        kg_per_m3 = get_cruz_stand_kg_per_m3(
          forest_type_group_code = forest_type_group_code
          , basal_area_m2_per_ha = basal_area_m2_per_ha
          , trees_per_ha = trees_per_ha
        )
      ) %>% 
      dplyr::ungroup() %>% 
      # tertiary columns 
      dplyr::mutate(
        # get cfl in kg/m2
        kg_per_m2 = mean_crown_length_m * kg_per_m3
        # get stand biomass in kg at the stand level
        , biomass_kg = kg_per_m2 * overlap_area_m2
        # single tree CBD in kg/m3 will be constant by stand/cell
        , tree_kg_per_m3 = biomass_kg / sum_crown_volume_m3
      )
  }
  
  #############################################
  # LANDFIRE
  #############################################
  
  
  # apply stand fuel load to trees
  tree_list <- tree_list %>% 
    dplyr::ungroup() %>% 
    dplyr::left_join(
      cell_df %>% 
        dplyr::select(cell,tree_kg_per_m3)
      , by = "cell"
    ) %>% 
    dplyr::mutate(cruz_biomass_kg = tree_kg_per_m3*crown_volume_m3) %>% 
    dplyr::select(-tree_kg_per_m3)
  
  #return
  return(list(
    cell_df = cell_df
    , tree_list = tree_list
  ))
}
```

apply the `distribute_stand_fuel_load()` function

```{r}
distribute_stand_fuel_load_ans <- distribute_stand_fuel_load(
  cell_df = calc_rast_cell_trees_ans$cell_df
  , tree_list = calc_rast_cell_trees_ans$tree_list
)
```

what does our "stand" (i.e. raster cell) data look like?

```{r}
distribute_stand_fuel_load_ans$cell_df %>% dplyr::glimpse()
```

plot our raster (e.g. "stand") kilograms per cubed meter value

```{r}
plt_temp <- distribute_stand_fuel_load_ans$cell_df %>% 
  ggplot(mapping=aes(x=x,y=y)) +
  geom_text(mapping = aes(label = cell)) +
  theme_light() +
  theme(legend.position = "top", legend.text = element_text(angle = 90,size=8), axis.text = element_blank())
# ba
p1_temp <- plt_temp +
  geom_tile(mapping = aes(fill = basal_area_m2_per_ha), color = "black", alpha = 0.9) +
  scale_fill_distiller(palette = "Blues", na.value = NA, direction = 1)
# tph
p2_temp <- plt_temp +
  geom_tile(mapping = aes(fill = trees_per_ha), color = "black", alpha = 0.9) +
  scale_fill_distiller(palette = "Oranges", na.value = NA, direction = 1)
# biomass
p3_temp <-  plt_temp +
  geom_tile(mapping = aes(fill = kg_per_m3), color = "black", alpha = 0.9) +
  scale_fill_distiller(palette = "Greens", na.value = NA, direction = 1, labels = scales::label_number())
# patchwork
(p1_temp+p2_temp)/p3_temp
```

what does our tree list data look like now?

```{r}
distribute_stand_fuel_load_ans$tree_list %>% 
  dplyr::select(-dplyr::any_of(col_not_sel)) %>% 
  dplyr::glimpse()
```

what does our biomass estimate look like?

```{r}
distribute_stand_fuel_load_ans$tree_list$cruz_biomass_kg %>% 
  summary()
```

let's plot biomass versus tree height because height comes directly from the point cloud

```{r}
distribute_stand_fuel_load_ans$tree_list %>% 
  ggplot(mapping = aes(x = tree_height_m, y = cruz_biomass_kg, color = cruz_biomass_kg)) +
  geom_point() +
  harrypotter::scale_color_hp(option = "slytherin") +
  scale_x_continuous(limits = c(0,NA), breaks = scales::extended_breaks(n = 11)) +
  scale_y_continuous(limits = c(0,NA), breaks = scales::extended_breaks(n = 11)) +
  labs(x = "height (m)", y = "biomass (kg)") +
  theme_light() +
  theme(legend.position = "none")
```

```{r, include=FALSE, eval=FALSE}
#### trying to get the biomass correct
ggsave(
  "c:/users/georg/Downloads/cruz_biomass_vs_height.jpg"
  , height = 7, width = 10
  , dpi = "print"
)

tree_list_temp %>% 
  sf::st_drop_geometry() %>% 
  dplyr::mutate(ba = pi * ((dbh_m/2)^2) ) %>% 
  dplyr::select(ba, basal_area_m2) %>% 
  dplyr::slice_head(n=22)

# what if we do this for just the las extent as the stand?

stand_temp <- tree_list_temp %>% 
  sf::st_drop_geometry() %>% 
  # aggregate to stand level
  dplyr::group_by(forest_type_group_code) %>% ## !!!! only works b/c there is one group
  dplyr::summarise(
    trees = dplyr::n()
    , basal_area_m2 = sum(basal_area_m2, na.rm = T)
    , mean_crown_length_m = mean(crown_length_m, na.rm = T)
    , sum_crown_volume_m3 = sum(crown_volume_m3, na.rm = T)
  ) %>% 
  # fake per ha calcs
  dplyr::ungroup() %>% 
  dplyr::mutate(
    basal_area_m2_per_ha = basal_area_m2/
      (
        las_ctg_sf %>% sf::st_union() %>% sf::st_area() %>% as.numeric() %>% `/`(10000)
      )
    , trees_per_ha = trees/
      (
        las_ctg_sf %>% sf::st_union() %>% sf::st_area() %>% as.numeric() %>% `/`(10000)
      )
  )
# get cruz CBD
cbd_temp <- get_cruz_stand_kg_per_m3(
  forest_type_group_code = stand_temp$forest_type_group_code[1]
  , basal_area_m2_per_ha = stand_temp$basal_area_m2_per_ha[1]
  , trees_per_ha = stand_temp$trees_per_ha[1]
)
# get cfl in kg/m2 ...stand level still
cfl_temp <- stand_temp$mean_crown_length_m[1] * cbd_temp
# get stand biomass in kg at the stand level
stand_biomass_kg_temp <-
  cfl_temp * (
    las_ctg_sf %>% sf::st_union() %>% sf::st_area() %>% as.numeric()
  )

# single tree CBD in kg/m3
tree_kg_m3 <- stand_biomass_kg_temp / stand_temp$sum_crown_volume_m3[1]

# what is the total stand volume?
tree_list_temp %>% 
  sf::st_drop_geometry() %>%
  dplyr::ungroup() %>% 
  dplyr::summarise(crown_volume_m3 = sum(crown_volume_m3))
# calc done by s.bonner
trees_sbonner_temp <- readr::read_csv("c:/Users/georg/Downloads/big_treeslist.csv") %>% 
  dplyr::rename_with(tolower)
trees_sbonner_temp %>% dplyr::glimpse()
trees_sbonner_temp %>% 
  dplyr::ungroup() %>% 
  dplyr::summarise(crown_volume = sum(crown_volume))

trees_sbonner_temp %>% 
  dplyr::select(
    treeid, tree_cbh_m, crown_dia, crown_length
    , crown_volume, height_to_max, moist
    , ss, tree_cbd, tree_bm
  ) %>%
  View()

# compare
tree_list_temp <- tree_list_temp %>% 
  dplyr::left_join(
    trees_sbonner_temp %>% 
      dplyr::select(
        treeid, tree_cbh_m, crown_dia, crown_length
        , crown_volume, height_to_max, moist
        , ss, tree_cbd, tree_bm
      ) %>% 
      dplyr::rename_with(
        ~ paste0("sb_", .x, recycle0 = TRUE)
        , .cols = -c(treeid)
      ) %>% 
      dplyr::rename(treeID = treeid)
    , by = "treeID"
  )
# plots
tree_list_temp %>% 
  ggplot() +
    geom_abline() +
    geom_point(aes(x = sb_tree_cbh_m, y = tree_cbh_m)) +
    theme_light()
# re-calc volume
tree_list_temp <- tree_list_temp %>% 
  dplyr::left_join(
    tree_list_temp %>% 
      sf::st_drop_geometry() %>% 
      dplyr::select(treeID, sb_tree_cbh_m, tree_height_m, crown_area_m2) %>% 
      dplyr::rename(tree_cbh_m=sb_tree_cbh_m) %>% 
      calc_tree_level_cols() %>% 
      dplyr::select(treeID,crown_volume_m3) %>% 
      dplyr::rename(new_crown_volume_m3=crown_volume_m3)
    , by = "treeID"
  )

# plots
stats::cor(tree_list_temp$new_crown_volume_m3, tree_list_temp$sb_crown_volume)
tree_list_temp %>% 
  ggplot() +
    geom_abline() +
    geom_point(aes(x = sb_crown_volume, y = new_crown_volume_m3)) +
    theme_light()

# what is the total stand volume?
tree_list_temp %>% 
  sf::st_drop_geometry() %>%
  dplyr::ungroup() %>% 
  dplyr::summarise(
    crown_volume_m3 = sum(crown_volume_m3)
    , sb_crown_volume = sum(sb_crown_volume)
    , new_crown_volume_m3 = sum(new_crown_volume_m3)
  )


# apply to trees
tree_list_temp %>% 
  sf::st_drop_geometry() %>% 
  dplyr::mutate(
    temp_biomass_kg = new_crown_volume_m3*tree_kg_m3
  ) %>% 
  # dplyr::select(temp_biomass_kg) %>% summary()
  ggplot(mapping = aes(x = tree_height_m, y = temp_biomass_kg, color = temp_biomass_kg)) +
  geom_point() +
  harrypotter::scale_color_hp(option = "slytherin") +
  scale_x_continuous(limits = c(0,NA), breaks = scales::extended_breaks(n = 11)) +
  scale_y_continuous(limits = c(0,NA), breaks = scales::extended_breaks(n = 11)) +
  labs(x = "height (m)", y = "biomass (kg)") +
  theme_light() +
  theme(legend.position = "none")

ggsave(
  "c:/users/georg/Downloads/cruz_biomass_vs_height.jpg"
  , height = 7, width = 10
  , dpi = "print"
)

```

## Method 3: LANDFIRE

### Get data

we first downloaded the LANDFIRE "Forest Canopy Bulk Density - CBD" raster from: https://landfire.gov/data-downloads/US_240/LF2023_CBD_240_CONUS.zip

we'll need to add this download to the `cloud2trees::get_data()` function...

```{r}
lf_dir <- "c:/data/usfs/lidar_phys_fire_mods/data/landfire/Tif/"
# read in the data
landfire_cbd <- terra::rast(file.path(lf_dir, "LC23_CBD_240.tif"))
```

what is this raster?

```{r}
landfire_cbd
```

what is in this data?

```{r}
lf_levels <- landfire_cbd %>% terra::levels()
lf_levels
```

the raster is categorical/factors

```{r}
terra::is.factor(landfire_cbd)
```

update the raster to numeric

```{r}
# update raster to numeric
landfire_cbd <- as.numeric(landfire_cbd)
```

adjust the numeric values since the units are in kg/m3*100 and set the rest to `NA`

```{r, include=FALSE, eval=FALSE}
# small the rast for testing
landfire_cbd <- landfire_cbd %>%
  terra::crop(
    cloud2trees_ans$treetops_sf %>% 
    sf::st_bbox() %>% 
    sf::st_as_sfc() %>% 
    sf::st_buffer(20000) %>% 
    terra::vect() %>% 
    terra::project(terra::crs(landfire_cbd))
  )
```


```{r}
# rcl = two column matrix ("is", "becomes") can be useful for classifying integer
 # values. In that case, the arguments right and include.lowest are ignored.
# unique type codes
#divide by 100 to get actual kg/m^3
lf_values_recode <- ifelse(
  lf_levels[[1]]$Value<=0
  , NA
  , lf_levels[[1]]$Value
  ) / 100
# matrix
rcl_temp <- c(lf_levels[[1]]$Value, lf_values_recode) %>%
  matrix(ncol=2, byrow=F)
# update raster to mark all non-forest cells as NA and convert rest to numeric
landfire_cbd_recode <- landfire_cbd %>%
  terra::classify(
    rcl = rcl_temp
    , others = NA
  )
```

this took way too long and we won't want to do this in the `cloud2trees` process every time we use the data. we could either: 

* upload the already cleaned data to Zenodo and have the `cloud2trees::get_data()` point to that source...we could put a hidden function in the package to do this
* or, have the `cloud2trees::get_data()` point to the original LANDFIRE source, download it, and clean it and write the new data only at download 

how does our new data look?

```{r}
landfire_cbd_recode
```

quick plot

```{r}
landfire_cbd_recode %>% terra::plot()
```

make a function to download, clean, and write the LANDFIRE data

```{r}
# do it
```

### Fill empty LANDFIRE cells

we want to ensure that any trees that fall within an empty LANDFIRE cell get a value. to do this we need to ensure that the LANDFIRE raster cells are all filled using nearest neighbor imputation

we can use the `fill_rast_na()` function we defined in `cloud2trees::trees_type()`

but we'll want to pass a cropped raster (potentially a coarser resolution raster if the AOI is huge) to this function

```{r}
fill_rast_na(landfire_cbd_recode)
```


### Tree overlap with raster

our `calc_rast_cell_overlap()` function to ingest a raster and a polygon and calculate the area of each raster cell that overlaps with the polygon

```{r}
calc_rast_cell_overlap_ans <- calc_rast_cell_overlap(
  rast = landfire_cbd_recode, poly = las_ctg_sf
) 
# what does the data look like?
calc_rast_cell_overlap_ans %>% 
  purrr::pluck("df") %>%
  dplyr::glimpse()
```

let's check this on the map

```{r}
ggplot(data = calc_rast_cell_overlap_ans$df) +
  geom_tile(mapping = aes(x=x,y=y,fill=overlap_area_m2), color = "gray") +
  geom_text(
    mapping = aes(x=x,y=y,label = scales::comma(overlap_area_m2, accuracy = 1))
    , color = "white"
  ) +
  geom_sf(
    data = las_ctg_sf %>% sf::st_union() %>% sf::st_transform(crs = terra::crs(landfire_cbd_recode))
    , color = "red"
    , alpha = 0
  ) +
  scale_fill_viridis_c(option = "mako", direction = -1) +
  theme_void()
```

### aggregate trees in raster cell

our `calc_rast_cell_trees()` function aggregates our tree list to the raster cell level and join to the raster cell overlap data by calling `calc_rast_cell_overlap()` within the function

```{r}
calc_rast_cell_trees_ans <- calc_rast_cell_trees(
    rast = landfire_cbd_recode
    , tree_list = cloud2trees_ans$treetops_sf
    , poly_extent = las_ctg_sf
    , calc_tree_level_cols = T
  )
# what?
calc_rast_cell_trees_ans %>% 
  purrr::pluck("cell_df") %>% 
  dplyr::filter(overlap_area_ha>0) %>% 
  dplyr::glimpse()
```


## Biomass Method Comparison

Let's compare the individual tree biomass estimates between the methods tested above. The first method relied on the `allodb` package to estimate single tree biomass (kg) based on published allometric equations. The second method we explored was using stand-level canopy fuels models ([Cruz et al. (2003)](https://scholar.google.com/scholar?cluster=316241498622221569&oi=gsb&hl=en&as_sdt=0,5)) to estimate stand-level CBD (kg per m^3^) and we distributed that fuel load across the individual trees in the stand.

```{r}
distribute_stand_fuel_load_ans$tree_list %>% 
  ggplot() +
  geom_abline() +
  geom_point(
    mapping = aes(
      x = allodb_biomass_kg
      , y = cruz_biomass_kg
      , color = tree_height_m
      # , size = tree_height_m
    )
  ) +
  scale_y_continuous(limits = c(0,max(distribute_stand_fuel_load_ans$tree_list$allodb_biomass_kg)*1.01)) +
  scale_x_continuous(limits = c(0,max(distribute_stand_fuel_load_ans$tree_list$allodb_biomass_kg)*1.01)) +
  scale_color_viridis_c(option = "mako", direction = -1) +
  labs(
    x = "`allodb` individ.\ntree biomass (kg)"
    , y = "Cruz stand to\nindivid. tree biomass (kg)"
    , color = "tree height (m)"
  ) +
  theme_light() +
  guides(size = "none")
```

summary comparison

```{r}
distribute_stand_fuel_load_ans$tree_list %>% 
  sf::st_drop_geometry() %>% 
  dplyr::mutate(
    allodb_biomass_factor_larger = allodb_biomass_kg/cruz_biomass_kg
  ) %>% 
  dplyr::select(tidyselect::contains("biomass")) %>% 
  summary()
```

The individual tree biomass estimates from the stand-level canopy fuels models distributed to the tree level were significantly lower than the biomass estimates from individual tree allometric equations. This difference is likely attributable to Cruz et al. (2003) estimating biomass of the crown portion of the tree only while the individual tree biomass equations implemented by `allodb` estimate total above ground biomass which includes biomass from foliage, stem bark, and stem wood.

To make an appropriate comparison between [method 1](#method1) and [method 2](#method2), the individual tree total above ground biomass ought to be separated into tree components. Where "components" refer to the different portions of a tree such as foliage, merchantable stem, roots, or branches. Species group ratios of the biomass of component to the total above ground biomass have been reported in prior work ([Jenkins et al. 2003](https://scholar.google.com/scholar?cluster=3792367511483812518&oi=gsb&hl=en&as_sdt=0,6)). For the present study we could implement these biomass component ratios to get biomass for the crown portion only, or we could further explore the `allodb::new_equations()` function to modify the set of equations that will be used to estimate the biomass.

## Method 1: reprise

In [method 1](#method1) above we used the `allodb` package to estimate single tree biomass (kg) using allometric equations with DBH as a predictor variable. The `allodb::get_biomass()` function we used in the above demonstration defaults to estimating total above ground biomass for individual trees.

First, let's see if we can get estimates that align with the biomass of only the crown portion of the tree. Second, let's see if we can update the set of equations to estimate biomass based on FIA forest type groups which possibly contain multiple species. Some guidance from [Gonzalez‐Akre et al. (2022)](https://scholar.google.com/scholar?cluster=14167690887599848846&oi=gsb&hl=en&as_sdt=0,5):

>User provides a dataframe with DBH (cm), parsed species Latin names and site coordinates. `allodb` estimates AGB by calibrating a new allometric equation for each taxon in the user-provided data. The equations table in `allodb` can be customized using the `new_equations()` function. Each equation is given a weight by the `weight_allom()` function and then resampled with the function `resample_agb()`. The values obtained are used in the function `est_params()` to recalibrate a new allometric equation and then used in the `get_biomass()` function. `illustrate_allodb()` is used to visualize the top resampled equations (details for each equation can be found in the equations table within `allodb`) and the final fitted equation. (Fig. 1, p. 334)

### Step 1: `allodb::new_equations()`

The equations table in `allodb` can be customized using the `new_equations()` function.

#### Equation dependent variables

The `allodb::new_equations()` function has a parameter `subset_output` that determines the dependent variable(s) to be provided by the `allodb::get_biomass()` function. The `subset_output` default is `c("Total aboveground biomass", "Whole tree (above stump)")`, other possible values are: "Bark biomass", "Branches (dead)", "Branches (live)", "Branches total (live, dead)", "Foliage total", "Height", "Leaves", "Stem (wood only)", "Stem biomass", "Stem biomass (with bark)", "Stem biomass (without bark)", "Whole tree (above and belowground)".

What equations are represented in our attempt to get the biomass of only the crown portion of the tree?

```{r}
allodb::equations %>% 
  dplyr::count(equation_taxa,dependent_variable) %>% 
  dplyr::arrange(equation_taxa,desc(n)) %>% 
  kableExtra::kbl() %>% 
  kableExtra::kable_styling()
```


```{r}
allodb::new_equations(
  subset_output = c(
    # "Total aboveground biomass" # default
    # , "Whole tree (above stump)" # default
    # , "Bark biomass"
    "Branches (dead)"
    , "Branches (live)"
    , "Branches total (live, dead)"
    , "Foliage total"
    # , "Height"
    , "Leaves"
    # , "Stem (wood only)"
    # , "Stem biomass"
    # , "Stem biomass (with bark)"
    # , "Stem biomass (without bark)"
    # , "Whole tree (above and belowground)"
  )
) %>% 
  dplyr::select(
    "dependent_variable", "equation_taxa", "equation_allometry"
    , "ecosystem_type", "ref_id"
  )
```

This list is sparse. Let's consider using species group ratios of the biomass of component to the total above ground biomass which have been reported in prior work ([Jenkins et al. 2003](https://scholar.google.com/scholar?cluster=3792367511483812518&oi=gsb&hl=en&as_sdt=0,6))

### `allodb::new_equations()` for species composition

The `allodb::new_equations()` function might allow us to modify the set of equations that will be used to estimate the biomass. can we adjust the weights used by `allodb::get_biomass()` to allow for multiple species allometries to contribute to the estimation of biomass given that we have only FIA forest type which groups multiple species together?

it looks like the `allodb::est_params()` returns the allometric equation parameters to be used to estimate biomass for each tree and it's returned data is joined with the tree list data based on the columns `c("genus", "long", "lat")` if no `species` parameter is provided (if `species` is provided, it is added to the join column list)

```{r}
# just get one coordinate location
coords_temp <- cloud2trees_ans$treetops_sf %>%
  sf::st_transform(crs = sf::st_crs(4326)) %>%
  sf::st_coordinates() %>% 
  dplyr::as_tibble() %>% 
  dplyr::slice(1)
# what parameters are default?
def_params_temp <- allodb::est_params(
  genus = "Pinus",
  coords = coords_temp,
  species = NULL,
  new_eqtable = NULL, # default for get_biomass
  wna = 0.1, # default for get_biomass
  w95 = 500, # default for get_biomass
  nres = 1e4 # default for get_biomass
)
def_params_temp
```

let's use `allodb::new_equations()` to filter the equations to use for biomass estimation

```{r}
new_eq_temp <- allodb::new_equations(
  subset_taxa = c(
    "Pinus" # in case the species doesn't exist
    , "Pinus contorta"
  )
)
```

what did we get?

```{r}
new_eq_temp %>% 
  dplyr::select(c("equation_id", "equation_taxa", "equation_allometry")) %>% 
  dplyr::glimpse()
```

now we'll update the `new_eqtable` parameter using the return from `allodb::new_equations()`

```{r}
updt_params_temp <- allodb::est_params(
  genus = "Pinus",
  coords = coords_temp,
  species = NULL,
  new_eqtable = new_eq_temp, # updated
  wna = 0.1, # default for get_biomass
  w95 = 500, # default for get_biomass
  nres = 1e4 # default for get_biomass
)
# what is the update?
updt_params_temp
```

nice! now what?

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```



